import Link from 'next/link';
import {Image} from '@swistak-codes/components';
import cover from './swistak_mag.webp';
import piet from './piet_code_file.png';
import turing from './1280px-Turing_Machine_Model_Davey_2012.jpg';

export const meta = {
  title: 'Programistyczna ezoteryka, czyli Brainfuck',
  abstract:
    'ArtykuÅ‚ opowiada o ezoterycznych jÄ™zykach programowania i bliÅ¼ej skupia siÄ™ na jednym konkretnym â€” Brainfucku.',
  firstParagraph: (
    <>
      Programowanie jeszcze do niedawna mogÅ‚o siÄ™ niektÃ³rym wydawaÄ‡ wiedzÄ… ezoterycznÄ…, tajemnÄ…, przekazywanÄ… jedynie wybranym. DziÅ› zwykÅ‚e programowanie raczej nikogo nie zadziwia, a teÅ¼ dostÄ™p do wiedzy o nim jest powszechny. Jednak coÅ› siÄ™ ostaÅ‚o â€” mamy caÅ‚Ä… kategoriÄ™ ezoterycznych jÄ™zykÃ³w programowania. A poÅ›rÃ³d nich, prawdopodobnie najbardziej rozpoznawalny z nich w duÅ¼ej mierze dziÄ™ki swojej nazwie, Brainfuck. Dowiedzmy siÄ™, na czym polega ta programistyczna ezoteryka i sprÃ³bujmy napisaÄ‡ jakiÅ› kod w ten sposÃ³b.
    </>
  ),
  keyword: 'brainfuck',
  categories: ['Programowanie'],
  tags: [
    'brainfuck',
    'ezoteryczny jÄ™zyk programowania',
    'piet',
    'maszyna Turinga',
    'kompletnoÅ›Ä‡ Turinga',
    'Turing tarpit',
    'javascript'
  ],
  slug: 'brainfxck',
  updateTime: '2024-03-20T07:00:00+00:00',
  publishTime: '2024-03-20T07:00:00+00:00',
  cover,
};

## Ezoteryczne jÄ™zyki programowania

### Czym sÄ…?

Zanim przejdziemy do gÅ‚Ã³wnego bohatera artykuÅ‚u, zacznijmy od tego, czym sÄ… ezoteryczne jÄ™zyki programowania. Wbrew temu, z czym mogÅ‚aby siÄ™ kojarzyÄ‡ nazwa, nie sÄ… to jÄ™zyki do np. stawiania horoskopÃ³w. PowstaÅ‚y jako jÄ™zyki nie do normalnego uÅ¼ycia, a raczej jako ciekawostka, swego rodzaju sztuka, czy po prostu Å¼art. SÅ‚owo *ezoteryczny* jest tu uÅ¼yte przede wszystkim po to, aby odrÃ³Å¼niÄ‡ te jÄ™zyki od zwykÅ‚ych do normalnego uÅ¼ytku.

Najbardziej charakterystycznÄ… cechÄ… ezoterycznych jÄ™zykÃ³w programowania jest nietypowa skÅ‚adnia i zarazem nietypowy zestaw instrukcji. Z jednej strony bÄ™dÄ… tu jÄ™zyki, gdzie programujemy jedynie za pomocÄ… kilku znakÃ³w (jak dzisiejszy bohater), ale teÅ¼ takie, gdzie piszemy wiele nadmiarowych rzeczy, np. Å¼eby program wyglÄ…daÅ‚ jak ksiÄ…Å¼ka kucharska (Chef). ZresztÄ… niekoniecznie musimy pisaÄ‡, bo sÄ… teÅ¼ jÄ™zyki, gdzie programujemy, rysujÄ…c (Piet).

<Image
  image={piet}
  alignCenter
  unoptimized={true}
  alt="Sekwencja kolorÃ³w ukÅ‚adajÄ…ca siÄ™ w kod napisany w jÄ™zyku programowania Piet"
  caption={<>Ten niepozorny obrazek to program â€napisanyâ€ w jÄ™zyku Piet, wypisujÄ…cy na ekranie tekst â€Å›wistak.codesâ€. JeÅ›li mi nie wierzysz, skorzystaj z jakiegoÅ› interpretera, np. <a href="https://www.bertnase.de/npiet/npiet-execute.php" target="_blank" rel="noreferrer">npiet online</a>.</>}
/>

### Co sprawia, Å¼e coÅ› jest jÄ™zykiem programowania?

WidzÄ…c powyÅ¼szy obrazek, moÅ¼na zadaÄ‡ celne pytanie â€” co sprawia, Å¼e jÄ™zyk programowania jest jÄ™zykiem programowania? Dlaczego Piet, w ktÃ³rym rysujemy obrazki, jest jÄ™zykiem programowania (co prawda ezoterycznym), a taki HTML juÅ¼ nie? OdpowiedÅº czÄ™sto sprowadza siÄ™ do jednego terminu z teorii obliczeÅ„: kompletnoÅ›ci Turinga.

Zanim przejdziemy do definicji, od razu dodam, Å¼e kompletnoÅ›Ä‡ Turinga nie jest jedynym wyznacznikiem, czy coÅ› jest jÄ™zykiem programowania. IstniejÄ… jÄ™zyki programowania, ktÃ³re tego kryterium nie speÅ‚niajÄ…, np. Charity czy LOOP. Aczkolwiek sÄ… to bardzo rzadkie i maÅ‚opopularne przypadki.

#### KompletnoÅ›Ä‡ Turinga

KompletnoÅ›Ä‡ Turinga, w duÅ¼ym uproszczeniu mÃ³wiÄ…c, to cecha modelu obliczeniowego polegajÄ…ca na tym, Å¼e da siÄ™ zasymulowaÄ‡ na nim uniwersalnÄ… maszynÄ™ Turinga. UjmujÄ…c to w inny sposÃ³b, moÅ¼na rozwiÄ…zaÄ‡ tÄ™ samÄ… klasÄ™ problemÃ³w obliczeniowych co maszyna Turinga.

Tylko czym jest maszyna Turinga? Jest to abstrakcyjny model urzÄ…dzenia sÅ‚uÅ¼Ä…cego do wykonywania algorytmÃ³w. W zaÅ‚oÅ¼eniu skÅ‚ada siÄ™ ona z bloku sterowania, nieskoÅ„czonej taÅ›my (podzielonej na pola) i gÅ‚owicy, ktÃ³ra zapisuje i odczytuje symbole. GÅ‚owica zawsze jest ustawiona na jakimÅ› polu i znajduje siÄ™ w jednym z odgÃ³rnie zdefiniowanych stanÃ³w. CaÅ‚e zachowanie definiowane jest matematycznie. Nie wchodzÄ…c w szczegÃ³Å‚y, jak to wyglÄ…da matematycznie, moglibyÅ›my na tym modelu zaimplementowaÄ‡ dowolny algorytm.

OczywiÅ›cie z racji tego, Å¼e maszyna Turinga ma nieskoÅ„czonÄ… pamiÄ™Ä‡ (taÅ›mÄ™), nigdy Å¼aden jÄ™zyk programowania nie bÄ™dzie w stanie jej w peÅ‚ni zasymulowaÄ‡. Jednak o kompletnoÅ›ci Turinga mÃ³wimy wtedy, gdy jeÅ›li byÅ‚by dostÄ™p do nieskoÅ„czonej pamiÄ™ci, to czy moglibyÅ›my w peÅ‚ni odwzorowaÄ‡ maszynÄ™ Turinga.

<Image
  image={turing}
  alignCenter
  alt="UrzÄ…dzenie skÅ‚adajÄ…ce siÄ™ z taÅ›my, gÅ‚owicy i bloku sterowania."
  caption={<>Mniej wiÄ™cej tak mogÅ‚aby wyglÄ…daÄ‡ fizyczna wersja maszyny Turinga. Musisz sobie tylko dopowiedzieÄ‡, Å¼e na rolkach po obu stronach gÅ‚owicy jest nieskoÅ„czona iloÅ›Ä‡ taÅ›my.<br /> (ÅºrÃ³dÅ‚o: <a href="https://commons.wikimedia.org/wiki/File:Turing_Machine_Model_Davey_2012.jpg">Rocky Acosta</a>, <a href="https://creativecommons.org/licenses/by/3.0">CC BY 3.0</a>, via Wikimedia Commons)</>}
/>

UproÅ›Ä‡my to jednak do jeszcze prostszej definicji, bardzo intuicyjnej â€” jÄ™zyk programowania jest kompletny (zupeÅ‚ny) w sensie Turinga, jeÅ›li moÅ¼emy w nim zaprogramowaÄ‡ dowolny algorytm.

#### Turing tarpit

W 1982 r. Alan Perlis opublikowaÅ‚ Å¼artobliwy artykuÅ‚ w czasopiÅ›mie ACM SIGPLAN o tytule *Epigrams on Programming*. SzczegÃ³lnie zasÅ‚ynÄ…Å‚ on z 54. punktu, ktÃ³ry w tÅ‚umaczeniu na polski brzmi nastÄ™pujÄ…co:

> StrzeÅ¼ siÄ™ grzÄ™zawiska Turinga, w ktÃ³rym wszystko jest moÅ¼liwe, ale nic co warte uwagi nie jest Å‚atwe.

StÄ…d wziÄ™Å‚o siÄ™ pojÄ™cie *Turing tarpit* (po polsku *grzÄ™zawisko Turinga*). Nazywamy tak modele, ktÃ³re sÄ… kompletne w sensie Turinga, czyli moglibyÅ›my za ich pomocÄ… przedstawiÄ‡ dowolny algorytm, jednak sÄ… bardzo niepraktyczne. CharakteryzujÄ… siÄ™ bardzo uproszczonym podejÅ›ciem do tematu rozwiÄ…zywania obliczeÅ„, w zasadzie minimalnym, przez co sÄ… trudne w uÅ¼yciu. Do tej kategorii zaliczamy czÄ™Å›Ä‡ ezoterycznych jÄ™zykÃ³w programowania â€” w szczegÃ³lnoÅ›ci te, ktÃ³re charakteryzujÄ… siÄ™ bardzo maÅ‚Ä… liczbÄ… instrukcji, np. Brainfuck, w ktÃ³rego siÄ™ zaraz mocniej zagÅ‚Ä™bimy.

#### Nieprogramistyczne i nietypowe przykÅ‚ady kompletnoÅ›ci Turinga

Zanim przejdziemy do Brainfucka, jeszcze chciaÅ‚em dodaÄ‡, Å¼e o ile kompletnoÅ›Ä‡ Turinga kojarzy siÄ™ (informatykom) przede wszystkim z jÄ™zykami programowania, to celowo wczeÅ›niej uÅ¼ywaÅ‚em sÅ‚owa model obliczeniowy. PrzykÅ‚adowo, o kompletnoÅ›ci Turinga moÅ¼emy mÃ³wiÄ‡ w przypadku architektury von Neumanna (na ktÃ³rej bazujÄ… komputery), bo moÅ¼emy na niej zasymulowaÄ‡ maszynÄ™ Turinga. Tak samo kompletny w sensie Turinga jest najbardziej znany automat komÃ³rkowy, czyli gra w Å¼ycie.

WiÄ™kszym zainteresowaniem Å‚owcÃ³w ciekawostek cieszÄ… siÄ™ jednak nietypowe przykÅ‚ady kompletnoÅ›ci Turinga, bo jak siÄ™ okazuje, moÅ¼e byÄ‡ na przykÅ‚ad caÅ‚kowicie niezamierzona. Moje ulubione przykÅ‚ady:

- W 2017 r. pojawiÅ‚ siÄ™ artykuÅ‚ *On the Turing Completeness of MS PowerPoint*, gdzie pokazano, Å¼e w PowerPoincie moÅ¼na zasymulowaÄ‡ maszynÄ™ Turinga. [Tutaj znajdziesz prezentacjÄ™ na ten temat](https://www.youtube.com/watch?v=uNjxe8ShM-8).
- ZostajÄ…c przy pakiecie Office, Excel jest rÃ³wnieÅ¼ kompletny w sensie Turinga. A staÅ‚o siÄ™ tak, odkÄ…d wprowadzono do Excela formuÅ‚Ä™ [LAMBDA](https://support.microsoft.com/pl-pl/office/funkcja-lambda-bd212d27-1cd1-4321-a34a-ccbf254b8b67), ktÃ³ra dosÅ‚ownie pozwala tworzyÄ‡ wÅ‚asne funkcje w formie rachunku lambda. ZresztÄ… [ktoÅ› nawet stworzyÅ‚ 16-bitowy procesor w Excelu](https://www.youtube.com/watch?v=5rg7xvTJ8SU). Gwoli Å›cisÅ‚oÅ›ci â€” nie mÃ³wimy tu w ogÃ³le o uÅ¼ywaniu makr, bo za nimi stoi prawdziwy jÄ™zyk programowania (Visual Basic).
- Minecraft rÃ³wnieÅ¼ ma tÄ™ cechÄ™. [Tutaj znajdziesz filmik z procesorem stworzonym w Minecrafcie](https://www.youtube.com/watch?v=FDiapbD0Xfg).
- Jeszcze zupeÅ‚nie innÄ… kategoriÄ… sÄ… elementy jÄ™zykÃ³w programowania, ktÃ³re z zamysÅ‚u nie miaÅ‚y sÅ‚uÅ¼yÄ‡ do obliczeÅ„, ale speÅ‚niajÄ… zaÅ‚oÅ¼enia kompletnoÅ›ci Turinga. Najbardziej znane przykÅ‚ady to szablony w C++, instrukcja `MOV` z asemblera x86 czy system typÃ³w <Link href="/post/teoria-zbiorow-typescript">TypeScripta</Link>.

W przypadku tego ostatniego polecam zainteresowaÄ‡ siÄ™ grudniowÄ… zabawÄ… *Advent of TypeScript* organizowanÄ… przez [TypeHero](https://typehero.dev/). PoniÅ¼ej przykÅ‚ad mojego rozwiÄ…zania (niekoniecznie idealnego) jednej z prostszych zagadek z zeszÅ‚ego roku â€” wyszukiwanie liniowe (szukane byÅ‚o emoji z MikoÅ‚ajem) caÅ‚kowicie zrobione w systemie typÃ³w:

```typescript
type Increment<N extends number> = [1,2,3,4,5,6,7,8,9,10][N]
type FindSanta<T1, T2 extends number = 0> = T1 extends [infer First, ...infer Rest]
  ? First extends 'ğŸ…ğŸ¼'
    ? T2
    : FindSanta<Rest, Increment<T2>>
  : never;

// test rozwiÄ…zania:
type Forest2 = ['ğŸ„', 'ğŸ„', 'ğŸ…ğŸ¼', 'ğŸ„'];
type test_2_actual = FindSanta<Forest2>; // 2
```

## Brainfuck

PrzejdÅºmy w koÅ„cu do gÅ‚Ã³wnego bohatera artykuÅ‚u, czyli ezoterycznego jÄ™zyka programowania Brainfuck. Jego nazwÄ™ moglibyÅ›my luÅºno przetÅ‚umaczyÄ‡ na polski jako mÃ³zgoj\*b, wiÄ™c to juÅ¼ powinno nam wiele mÃ³wiÄ‡. SkÅ‚adnia tego jÄ™zyka skÅ‚ada siÄ™ jedynie z oÅ›miu instrukcji, kaÅ¼da jednoznakowa.

### Historia

JÄ™zyk jest juÅ¼ doÅ›Ä‡ wiekowy. StworzyÅ‚ go w 1993 r. Urban MÃ¼ller i opublikowaÅ‚ jego kompilator pod AmigÄ™ na Aminecie. Pierwsza wersja waÅ¼yÅ‚a 296 bajtÃ³w, natomiast druga juÅ¼ tylko 240. ZresztÄ… samÄ… publikacjÄ™ na Aminet o drugiej wersji jÄ™zyka moÅ¼ecie znaleÅºÄ‡ tutaj: https://aminet.net/package/dev/lang/brainfuck-2. MoÅ¼na tam teÅ¼ Å›ciÄ…gnÄ…Ä‡ oryginalny kompilator â€” moÅ¼e ktoÅ› jest chÄ™tny sprÃ³bowaÄ‡ <Link href="/post/komputer-w-komputerze-czyli-emulacja-wirtualizacja-i-konteneryzacja">zemulowaÄ‡</Link>?

### SkÅ‚adnia

Idea jÄ™zyka Brainfuck jest taka â€” rozpoczynajÄ…c aplikacjÄ™, mamy zainicjowanÄ… tablicÄ™ bajtÃ³w (co najmniej 30 000 elementÃ³w) wypeÅ‚nionÄ… zerami i wskaÅºnik elementu w tablicy (zainicjowany na jej zerowym elemencie). NastÄ™pnie caÅ‚oÅ›ciÄ… wykonania operujemy, stosujÄ…c instrukcje:

- `>` â€” zwiÄ™kszenie wskaÅºnika elementu tablicy o 1
- `<` â€” zmniejszenie wskaÅºnika o 1
- `+` â€” zwiÄ™kszenie o 1 wartoÅ›ci w tablicy wskazywanej przez wskaÅºnik
- `-` â€” zmniejszenie o 1 wartoÅ›ci wskazywanej przez wskaÅºnik
- `.` â€” wyÅ›wietlenie wartoÅ›ci w tablicy jako znak w kodowaniu ASCII
- `,` â€” pobranie znaku od uÅ¼ytkownika i wstawienie jego wartoÅ›ci (ASCII) w aktualnie wskazywanej pozycji w tablicy
- `[` â€” rozpoczÄ™cie pÄ™tli; jeÅ›li na aktualnej pozycji w tablicy znajduje siÄ™ 0, przeskakujemy za znak zakoÅ„czenia pÄ™tli
- `]` â€” zakoÅ„czenie pÄ™tli; w przypadku napotkania na ten znak przeskakujemy do odpowiadajÄ…cego mu rozpoczÄ™cia pÄ™tli

Wszystkie inne znaki sÄ… traktowane jako komentarze.

Warto dodaÄ‡, Å¼e bardzo podobny zestaw instrukcji ma jÄ™zyk $$\textstyle{\mathcal{P}}^{\prime\prime}$$ z 1964 r. Jednak tamten jÄ™zyk byÅ‚ teoretyczny, eksperymentalny, majÄ…cy dowodziÄ‡, Å¼e nawet najprostszy zestaw instrukcji moÅ¼e byÄ‡ wystarczajÄ…cy do stworzenia maszyny Turinga.

### PrzykÅ‚adowe programy

Czy da siÄ™ tak pisaÄ‡ kod? Tak, jest to peÅ‚noprawny jÄ™zyk programowania. Czy warto? Dla zabawy, czemu nie. W Internecie znajdziemy bardzo ciekawe przykÅ‚ady kodu napisanego w Brainfucku, np. na angielskiej Wikipedii znajdziemy implementacjÄ™ algorytmu szyfrowania [ROT13](https://en.wikipedia.org/wiki/Brainfuck#ROT13). My jednak ograniczmy siÄ™ teraz w przykÅ‚adzie do najprostszego programu, jaki moÅ¼emy napisaÄ‡ â€” Hello World:

```brainfuck
H: ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
e: +++++++++++++++++++++++++++++.
l: +++++++.
l: .
o: +++.
spacja: -------------------------------------------------------------------------------.
W: +++++++++++++++++++++++++++++++++++++++++++++++++++++++.
o: ++++++++++++++++++++++++.
r: +++.
l: ------.
d: --------.
```

NapisaÅ‚em go w bardzo naiwny sposÃ³b, bo jedynie zwiÄ™kszajÄ…c i pomniejszajÄ…c wartoÅ›Ä‡. `H` to w ASCII 72, wiÄ™c mamy 72 plusy zakoÅ„czone kropkÄ…. `e` to 101, wiÄ™c dodajemy 29 itd. Kod moÅ¼na zdecydowanie skrÃ³ciÄ‡, wykorzystujÄ…c pÄ™tle i przesuwanie wskaÅºnika. Na angielskiej Wikipedii znajdziemy nastÄ™pujÄ…cÄ… implementacjÄ™ Hello World:

```brainfuck
+[-->-[>>+>-----<<]<--<---]>-.>>>+.>>..+++[.>]<<<<.+++.------.<<-.>>>>+.
```

Jednak tutaj krÃ³tszy zdecydowanie nie oznacza prostszy.

## Generowanie kodu

Pobawmy siÄ™ nieco Brainfuckiem, ale moÅ¼e niekoniecznie w robienie w nim aplikacji. Zacznijmy od najprostszej rzeczy, ktÃ³rÄ… moÅ¼emy zrobiÄ‡ wokÃ³Å‚ tematu tego jÄ™zyka, czyli zrÃ³bmy aplikacjÄ™ generujÄ…cÄ… kod. Jako Å¼e najprostsze jest wypisywanie tekstu, a w Brainfucku nie odbywa siÄ™ to przez podanie w kodzie tekstu do wyÅ›wietlenia, to zrÃ³bmy taki generator.

Jak pisaÅ‚em wczeÅ›niej, Brainfuck operuje na ustawianiu kodÃ³w ASCII. MoÅ¼emy za ich pomocÄ… przedstawiÄ‡ 95 znakÃ³w â€” alfabet Å‚aciÅ„ski, cyfry, spacjÄ™ i podstawowe symbole. JeÅ›li potrzebujesz na ten temat nieco wiÄ™cej informacji, ASCII opisaÅ‚em pokrÃ³tce w artykule *<Link href="/post/nie-liczby-jako-liczby-czyli-zapis-danych-cyfrowych">Nie-liczby jako liczby, czyli zapis danych cyfrowych</Link>*. Dodam tylko, Å¼e ASCII ma tÄ™ zaletÄ™, Å¼e jest to najbardziej podstawowe kodowanie znakÃ³w, ktÃ³re istnieje. O tyle podstawowe, Å¼e wszystkie inne, ktÃ³re zachowaÅ‚y siÄ™ do dziÅ›, sÄ… jego rozszerzeniami. Oznacza to tyle, Å¼e dla tego podstawowego zestawu znakÃ³w powinniÅ›my bez problemu pobraÄ‡ kod znaku w dowolnym jÄ™zyku programowania. Nawet nie znam â€normalnegoâ€ jÄ™zyka, ktÃ³ry by tego nie umoÅ¼liwiaÅ‚.

A jak taki generator najproÅ›ciej zrobiÄ‡? Z podanego tekstu pobieramy pierwszy znak i dajemy w rezultacie tyle plusÃ³w, ile wynosi wartoÅ›Ä‡ ASCII, co koÅ„czymy kropkÄ…. Dla kolejnych znakÃ³w obliczamy juÅ¼ rÃ³Å¼nicÄ™ miÄ™dzy kodami i uÅ¼ywamy odpowiedniej liczby plusÃ³w bÄ…dÅº minusÃ³w, zawsze koÅ„czÄ…c ciÄ…g kropkÄ…. W JavaScript wyglÄ…daÅ‚oby to nastÄ™pujÄ…co:

```javascript
// funkcja generujÄ…ca kod brainfuckowy
// zakÅ‚adam, Å¼e text jest typu znakowego
// i zawiera jedynie znaki zawarte w kodowaniu ASCII
function generateBf(text) {
  // zmienna, ktÃ³ra przechowa docelowy kod
  let code = "";
  // zmienna przechowujÄ…ca aktualny stan pamiÄ™ci
  let currentCellValue = 0;

  // iterujemy po kaÅ¼dym znaku w tekÅ›cie
  for (let i = 0; i < text.length; i++) {
    // wyciÄ…gamy znak z tekstu
    let char = text[i];
    // pobieramy jego kod ASCII
    let targetValue = char.charCodeAt(0);
    // obliczamy rÃ³Å¼nicÄ™ z aktualnym stanem pamiÄ™ci
    let difference = targetValue - currentCellValue;
    if (difference > 0) {
      // jeÅ›li rÃ³Å¼nica jest wiÄ™ksza od 0, zwiÄ™kszamy stan plusami
      code += "+".repeat(difference);
    } else if (difference < 0) {
      // jeÅ›li nie, zmniejszamy minusami
      // -difference, poniewaÅ¼ wartoÅ›Ä‡ jest ujemna, a chcemy mieÄ‡ dodatniÄ… liczbÄ™
      code += "-".repeat(-difference);
    }
    // koÅ„czymy kropkÄ…, czyli wypisaniem znaku
    code += ".";
    // zapamiÄ™tujemy aktualny stan pamiÄ™ci
    currentCellValue = targetValue;
  }
  // zwracamy wygenerowany kod
  return code;
}
```

Kod znajdziesz w wersji interaktywnej na [Replit](https://replit.com/@tswistak/bf-generator#index.js).

## Konwerter Brainfuck -> JavaScript

Kolejne, co moÅ¼emy zrobiÄ‡ w ramach naszej zabawy Brainfuckiem, to â€tÅ‚umaczâ€ tego jÄ™zyka na bardziej zrozumiaÅ‚y. Mimo Å¼e widzÄ…c sÅ‚owo *wskaÅºnik*, do gÅ‚owy szybciej moÅ¼e przyjÅ›Ä‡ np. C, to jednak postawiÅ‚em na JavaScript. ZrobiÅ‚em tak, Å¼eby juÅ¼ nie wprowadzaÄ‡ dodatkowego jÄ™zyka programowania do tego artykuÅ‚u.

### Interpretacja skÅ‚adni

GÅ‚Ã³wnÄ… pracÄ…, ktÃ³rÄ… mamy do wykonania, jest napisanie sÅ‚ownika tÅ‚umaczÄ…cego symbole brainfuckowe na czytelny kod JavaScriptowy.

#### Inicjalizacja

Zacznijmy od inicjalizacji, kiedy tworzona jest tablica bajtÃ³w (w silnie typowanych jÄ™zykach byÅ‚oby to `char[]` lub `byte[]`) wypeÅ‚niona zerami i wskaÅºnik na jej pierwszy element. BÄ™dzie to po prostu:

```javascript
const memory = new Array(30000).fill(0);
let pointer = 0;
```

#### Podstawowe symbole

PrzejdÅºmy wiÄ™c po kolei do symboli:

- `>` â€” `pointer++`
- `<` â€” `pointer--`
- `+` â€” `memory[pointer]++`
- `-` â€” `memory[pointer]--`
- `[` â€” `while(memory[pointer] > 0) {`
- `]` â€” `}`

PozostaÅ‚y nam tylko dwa problematyczne zwiÄ…zane z obsÅ‚ugÄ… wejÅ›cia i wyjÅ›cia.

#### WyjÅ›cie

Prostszym przypadkiem jest wyjÅ›cie, czyli wypisanie tekstu w konsoli (symbol `.`). W jÄ™zyku C wystarczyÅ‚oby zrobiÄ‡ `putchar(*pointer)`, co od razu teÅ¼ zinterpretuje kod ASCII. Jednak jak to zrobiÄ‡ w JavaScript?

Najbardziej ogÃ³lny sposÃ³b, ktÃ³ry zadziaÅ‚a i w przeglÄ…darce, i w NodeJS, to utworzenie podczas inicjalizacji pustego ciÄ…gu znakÃ³w i przy kaÅ¼dym `.` dodajemy do niego znak. NastÄ™pnie na samym koÅ„cu wypisujemy caÅ‚oÅ›Ä‡. CoÅ› w takim stylu:

```javascript
// inicjalizacja pustego ciÄ…gu
let output = '';

// ...

// dodanie znaku z kodu ASCII zapisanego w tablicy memory
output += String.fromCharCode(memory[pointer]);

// ...

// wypisanie zmiennej na koniec wykonania aplikacji
console.log(output);
```

Kod ten ma jednak taki problem, Å¼e moÅ¼na wprowadzaÄ‡ znaki (o tym za chwilÄ™), co moÅ¼e namieszaÄ‡ w kontekÅ›cie wypisywania tekstu, odbierajÄ…c czÄ™Å›ciowo interaktywnoÅ›Ä‡. Dlatego teÅ¼ tutaj tego sposobu nie uÅ¼yjemy.

Co mniej znane, w NodeJS jesteÅ›my w stanie wypisaÄ‡ pojedynczy znak w konsoli analogicznie jak dziaÅ‚a `putchar`. Wykorzystamy do tego bezpoÅ›redni dostÄ™p do wyjÅ›cia standardowego. MoÅ¼emy to zrobiÄ‡ nastÄ™pujÄ…co:

```javascript
process.stdout.write(String.fromCharCode(memory[pointer]));
```

Ten sposÃ³b wykorzystamy w naszym interpreterze jako dziaÅ‚ajÄ…cy dokÅ‚adnie tak, jak jest to w zaÅ‚oÅ¼eniach jÄ™zyka Brainfuck.

#### WejÅ›cie

Pobranie wejÅ›cia (symbol `,`) jest jednak trudniejsze, szczegÃ³lnie gdy mÃ³wimy o NodeJS. O ile w C wykorzystalibyÅ›my funkcjÄ™\* `getchar()`, to niestety nie mamy w JavaScript jej bezpoÅ›redniego odpowiednika. Jednak moÅ¼emy jej dziaÅ‚anie odwzorowaÄ‡, wykorzystujÄ…c bezpoÅ›redni dostÄ™p do wejÅ›cia standardowego.

W tym celu napiszemy funkcjÄ™, ktÃ³rÄ… bÄ™dziemy dalej do tego wykorzystywaÄ‡. WyglÄ…daÄ‡ bÄ™dzie nastÄ™pujÄ…co:

```javascript
// importujemy moduÅ‚ readline do odczytu linii ze strumieni
const readline = require('readline');

// asynchroniczna funkcja odczytujÄ…ca znak
function getChar() {
  return new Promise((resolve) => {
    // dodajemy do wejÅ›cia standardowego zdarzenie naciÅ›niÄ™cia klawisza
    readline.emitKeypressEvents(process.stdin);
    // przywracamy odczyt strumienia, jeÅ›li byÅ‚ wstrzymany
    process.stdin.resume();
    // uzyskujemy bezpoÅ›redni dostÄ™p do wejÅ›cia standardowego
    // tylko w ten sposÃ³b moÅ¼emy odczytywaÄ‡ pojedyncze znaki
    process.stdin.setRawMode(true);
    // definiujemy zdarzenie na naciÅ›niÄ™cie przycisku, wykona siÄ™ tylko raz
    process.stdin.once('keypress', (string, key) => {
      // musimy rÄ™cznie dodaÄ‡ obsÅ‚ugÄ™ wyÅ‚Ä…czania aplikacji
      // przez naciÅ›niÄ™cie CTRL + C
      if (key.ctrl && key.name === 'c') {
        process.exit();
      }
      // wstrzymujemy odczyt strumienia
      process.stdin.pause();
      // wyÅ‚Ä…czamy bezpoÅ›redni dostÄ™p
      process.stdin.setRawMode(false);
      // zwracamy jako rezultat funkcji asynchronicznej kod ASCII
      resolve(string.charCodeAt(0));
    });
  });
}
```

BÄ™dziemy jÄ… wykonywaÄ‡ nastÄ™pujÄ…co:

```javascript
memory[pointer] = await getChar();
```

FunkcjÄ™ moÅ¼na by poprawiÄ‡ o sprawdzanie, czy wprowadzony znak mieÅ›ci siÄ™ w zakresie kodowania ASCII (0-127). JeÅ›li nie, trzeba by czekaÄ‡, aÅ¼ uÅ¼ytkownik wprowadzi prawidÅ‚owy.

\* Drobna uwaga na boku odnoÅ›cie uÅ¼ycia `getchar()` z jÄ™zyka C. MoÅ¼e siÄ™ okazaÄ‡ po wywoÅ‚aniu funkcji, Å¼e nie jest pobierany pojedynczy znak, tylko wiele, aÅ¼ nie naciÅ›niemy Enter. Dzieje siÄ™ tak, gdy terminal dziaÅ‚a w trybie kanonicznym, co oznacza, Å¼e przekazuje wejÅ›cie ze strumienia linia po linii, a nie znak po znaku. MoÅ¼emy to wyÅ‚Ä…czyÄ‡, uÅ¼ywajÄ…c [`tcsetattr`](https://linux.die.net/man/3/tcsetattr).

#### Napisanie konwertera

Mamy w tym momencie wszystko, czego potrzebujemy do napisania konwertera. To, co musimy zrobiÄ‡, to stworzyÄ‡ ciÄ…g znakÃ³w zapoczÄ…tkowany kodem inicjujÄ…cym (razem z funkcjÄ… do odczytu znakÃ³w, jeÅ›li bÄ™dzie potrzebna), a potem iterowaÄ‡ znak po znaku kod Brainfuckowy i wstawiaÄ‡ odpowiednie instrukcje zamiast symboli. MoÅ¼emy dodatkowo albo formatowaÄ‡ kod wciÄ™ciami podczas wstawiania instrukcji, albo na sam koniec wywoÅ‚aÄ‡ gotowe narzÄ™dzie do tego celu (np. [Prettier](https://prettier.io/) dla JavaScriptu).

Funkcja konwertujÄ…ca mogÅ‚aby wyglÄ…daÄ‡ nastÄ™pujÄ…co:

```javascript
const prettier = require("prettier");

// kod pobierania znaku
const getChar = `
  const readline = require('readline');

  function getChar() {
    // ...
  }
`;

// kod inicjujÄ…cy
const init = `
  const memory = new Array(30000).fill(0);
  let pointer = 0;

  (async () => {
`;

// kod koÅ„czÄ…cy aplikacjÄ™
const end = `
  })();
`;

// mapa symbol BF -> instrukcja JS
const symbolToJs = {
  ">": "pointer++;",
  "<": "pointer--;",
  "+": "memory[pointer]++;",
  "-": "memory[pointer]--;",
  ".": "process.stdout.write(String.fromCharCode(memory[pointer]));",
  ",": "memory[pointer] = await getChar();",
  "[": "while (memory[pointer] !== 0) {",
  "]": "}",
};

async function bfToJs(bfCode) {
  // zmienna przechowujÄ…ca kod w JavaScript
  let result = "";
  if (bfCode.includes(",")) {
    // kod pobierania znaku dodajemy tylko wtedy, gdy jest potrzebny
    result += getChar;
  }
  // dodajemy kod inicjujÄ…cy aplikacjÄ™
  result += init;
  // iterujemy po kolejnych znakach, aby je przekonwertowaÄ‡
  for (let i = 0; i < bfCode.length; i++) {
    // pobieramy instrukcjÄ™ dla aktualnego znaku
    const instruction = symbolToJs[bfCode[i]];
    // jeÅ›li symbol byÅ‚ prawidÅ‚owy, dodajemy instrukcjÄ™ kodu
    if (instruction) {
      result += instruction;
    }
  }
  // dodajemy kod zakaÅ„czajÄ…cy aplikacjÄ™
  result += end;
  // formatujemy kod Prettierem
  result = await prettier.format(result, { parser: "babel" });
  // zwracamy kod
  return result;
}
```

PeÅ‚en kod wraz z zapisem wynikowego kodu do pliku znajdziesz na [Replit](https://replit.com/@tswistak/bf-converter#index.js).

Sam kod moÅ¼na by poprawiÄ‡. Na przykÅ‚ad, jeÅ›li nie pobieramy znaku, nie musimy tworzyÄ‡ [IIFE z funkcjÄ… asynchronicznÄ…](https://developer.mozilla.org/en-US/docs/Glossary/IIFE). Teoretycznie w ogÃ³le nie potrzeba by go robiÄ‡, jeÅ›li kod byÅ‚by pisany w formacie [ECMAScript Modules](https://nodejs.org/api/esm.html#modules-ecmascript-modules), ale Å¼e wciÄ…Å¼ domyÅ›lnym trybem w NodeJS jest [CommonJS](https://nodejs.org/api/modules.html#modules-commonjs-modules), to nie robiÅ‚em w taki sposÃ³b.

Alternatywny konwerter, generujÄ…cy kod w C, znajdziesz [na tym Replit](https://replit.com/@tswistak/bf-converter-c#index.js). Kod jest napisany z myÅ›lÄ… o Linuksach, wiÄ™c moÅ¼e nie dziaÅ‚aÄ‡ prawidÅ‚owo na innych systemach. MoÅ¼esz tam teÅ¼ zobaczyÄ‡, jak wyÅ‚Ä…czyÄ‡ w C tryb kanoniczny terminala, o ktÃ³rym wspominaÅ‚em wczeÅ›niej.

## Interpreter kodu

Skoro wiemy juÅ¼ jak tÅ‚umaczyÄ‡ Brainfucka na inny jÄ™zyk, to dlaczego nie zabraÄ‡ siÄ™ od razu za wykonywanie kodu? Teoretycznie mamy juÅ¼ wszystko, co potrzebne.

### ObsÅ‚uga pÄ™tli

Teoretycznie, bo nie wszystko przeÅ‚oÅ¼ymy jeden do jednego. Problematyczne bÄ™dÄ… symbole `[` i `]`, czyli pÄ™tla. Jest to jedyna rzecz, ktÃ³rej nie moÅ¼emy ot tak sobie wywoÅ‚aÄ‡, interpretujÄ…c kod. Jak wiÄ™c do tego podejÅ›Ä‡?

Co opisaÅ‚em w swoim starszym artykule *<Link href="/post/iteracja-co-to-jest">Iteracja â€” co to jest?</Link>*, pÄ™tle (w uproszczeniu) polegajÄ… na przeskakiwaniu miÄ™dzy wskazanymi punktami w kodzie aplikacji. W asemblerach, gdzie pÄ™tle opierajÄ… siÄ™ tylko na skokach, wskazujemy konkretnÄ… liniÄ™ kodu, do ktÃ³rej przechodzimy. W Brainfucku mamy do czynienia z blokiem wyznaczanym przez `[` i `]`. Jak wiÄ™c zrobiÄ‡ pÄ™tlÄ™? NaleÅ¼y zapamiÄ™taÄ‡ pozycjÄ™, na ktÃ³rej byÅ‚o `[`, i przy napotkaniu `]` przeskoczyÄ‡ w kodzie do tamtego miejsca.

Problem jednak pojawia siÄ™, gdy mamy zagnieÅ¼dÅ¼one pÄ™tle. W takim przypadku musimy pamiÄ™taÄ‡ wiÄ™cej pozycji, tylko jak? Najlepiej sprawdzi siÄ™ do tego <Link href="/post/odwrotna-notacja-polska/#stos">stos</Link>. WÃ³wczas co wejÅ›cie w pÄ™tle dodajemy adres poczÄ…tku pÄ™tli na szczyt stosu, i napotykajÄ…c `]`, Å›ciÄ…gamy go. Zapewni nam to, Å¼e zawsze na gÃ³rze stosu bÄ™dzie najÅ›wieÅ¼sze otwarcie pÄ™tli, wiÄ™c trafiajÄ…c na jej zakoÅ„czenie, wiemy, gdzie wrÃ³ciÄ‡. Problemem jest jednak to, Å¼e bÄ™dziemy musieli znaleÅºÄ‡ `]`, do ktÃ³rego naleÅ¼y przeskoczyÄ‡, gdy nie wykonamy znowu pÄ™tli, ale tutaj moÅ¼emy posiÅ‚kowaÄ‡ siÄ™ wyszukiwaniem liniowym.

### Implementacja

CaÅ‚y kod interpretera w JavaScript bÄ™dzie wyglÄ…daÄ‡ jak poniÅ¼ej. ZwrÃ³Ä‡ szczegÃ³lnÄ… uwagÄ™ na kod obsÅ‚ugi `[` i `]`, gdyÅ¼ jak napisaÅ‚em chwilÄ™ temu, jest tutaj najbardziej podchwytliwy.

```javascript
async function bfInterpreter(bfCode) {
  // pamiÄ™Ä‡ Brainfucka
  const memory = new Array(30000).fill(0);
  // stos przechowujÄ…cy poczÄ…tki pÄ™tli
  const loopStack = [];
  // aktualna pozycja wskaÅºnika
  let pointer = 0;
  for (let i = 0; i < bfCode.length; i++) {
    const symbol = bfCode[i];
    switch (symbol) {
      case ">":
        pointer++;
        break;
      case "<":
        pointer--;
        break;
      case "+":
        memory[pointer]++;
        break;
      case "-":
        memory[pointer]--;
        break;
      case ".":
        process.stdout.write(String.fromCharCode(memory[pointer]));
        break;
      case ",":
        memory[pointer] = await getChar();
        break;
      case "[":
        // jeÅ›li nie chcemy wykonaÄ‡ pÄ™tli, musimy znaleÅºÄ‡ jej zakoÅ„czenie
        if (memory[pointer] === 0) {
          // tÄ… zmiennÄ… bÄ™dziemy odmierzaÄ‡, ile poczÄ…tkÃ³w pÄ™tli napotkaliÅ›my,
          // Å¼eby wiedzieÄ‡, ile razy musimy zignorowaÄ‡ symbol `]`
          let loop = 1;
          // bÄ™dziemy iterowaÄ‡ tak dÅ‚ugo, aÅ¼ trafimy na zakoÅ„czenie aktualnej pÄ™tli
          while (loop > 0) {
            // zwiÄ™kszamy indeks o 1, aby przejÅ›Ä‡ do nastÄ™pnego symbolu
            i++;
            if (bfCode[i] === "[") {
              // jeÅ›li napotkaliÅ›my poczÄ…tek pÄ™tli, zwiÄ™kszamy licznik pÄ™tli
              loop++;
            } else if (bfCode[i] === "]") {
              // w przeciwnym wypadku zmniejszamy
              // gdy osiÄ…gnÄ™liÅ›my 0, oznacza to, Å¼e trafiliÅ›my na szukany `]`
              loop--;
            }
          }
        } else {
          // wykonujemy pÄ™tlÄ™, dlatego zapisujemy adres jej poczÄ…tku na stosie
          loopStack.push(i);
        }
        break;
      case "]":
        if (memory[pointer] !== 0) {
          // cofamy siÄ™ do poczÄ…tku pÄ™tli
          // odejmujemy 1, bo pÄ™tla for zawsze zwiÄ™ksza licznik na koÅ„cu
          i = loopStack.pop() - 1;
        } else {
          // jeÅ›li w pamiÄ™ci aktualna komÃ³rka jest rÃ³wna 0,
          // to nie ma sensu siÄ™ cofaÄ‡, usuwamy zapamiÄ™tany adres
          loopStack.pop();
        }
        break;
    }
  }
}
```

CaÅ‚oÅ›Ä‡ w interaktywnej formie znajdziesz na [Replit](https://replit.com/@tswistak/bf-interpreter#index.js).

Przy okazji powyÅ¼szego interpretera dodam ciekawostkÄ™, Å¼e dowolnÄ… aplikacjÄ™ moÅ¼na w JavaScript zapisaÄ‡ jedynie za pomocÄ… szeÅ›ciu symboli: `[`, `]`, `(`, `)`, `!` i `+`. Nazwano to *JSFuck* (kto by siÄ™ spodziewaÅ‚) i na stronie [jsfuck.com](https://jsfuck.com/) znajdziesz konwerter dowolnego kodu JavaScriptowego na jego szeÅ›cioznakowy podzbiÃ³r. OczywiÅ›cie skrypty takie bÄ™dÄ… dziaÅ‚aÄ‡ o wiele wolniej, ale bÄ™dÄ… dziaÅ‚aÄ‡.

## Podsumowanie

Chyba nie muszÄ™ mÃ³wiÄ‡, Å¼e Brainfuck sam z siebie szczegÃ³lnych zastosowaÅ„ nie ma. NaleÅ¼y traktowaÄ‡ go bardziej jako ciekawostkÄ™, Å¼e kompletny jÄ™zyk programowania moÅ¼e byÄ‡ tak minimalistyczny, a takÅ¼e moÅ¼emy pokombinowaÄ‡ z pisaniem w nim prostych programÃ³w. Warto jednak zauwaÅ¼yÄ‡, Å¼e obsÅ‚uga nawet tak prostego jÄ™zyka w celu jego konwersji na inny, czy w ogÃ³le interpretacji, jest ciekawym zagadnieniem algorytmicznym i liczÄ™, Å¼e dziÄ™ki temu mogÅ‚eÅ›(-aÅ›) odkryÄ‡ coÅ› nowego. OczywiÅ›cie zwykÅ‚ych jÄ™zykÃ³w programowania nie odczytywalibyÅ›my tak jak tu linijka po linijce, tylko transformowalibyÅ›my je do struktur takich jak AST, ale to opowieÅ›Ä‡ na zupeÅ‚nie inny artykuÅ‚.

## Literatura

- Esoteric programming language, https://esolangs.org/w/index.php?title=Esoteric_programming_language&oldid=122980 (ostatni dostÄ™p 7.03.2024)
- Piet, https://esolangs.org/w/index.php?title=Piet&oldid=116788 (ostatni dostÄ™p 7.03.2024)
- Turing machine, https://en.wikipedia.org/w/index.php?title=Turing_machine&oldid=1210672492 (ostatni dostÄ™p 7.03.2024)
- Perlis, A. J. (September 1982). "Epigrams on programming". ACM SIGPLAN Notices. New York, NY, USA: Association for Computing Machinery. 17 (9): 7â€“13. [doi:10.1145/947955.1083808](https://doi.org/10.1145/947955.1083808).
- Aminet - `dev/lang/brainfuck-2.lha`, https://aminet.net/package/dev/lang/brainfuck-2 (ostatni dostÄ™p 7.03.2024)
- B. Raiter, *Brainfuck, An Eight-Instruction Turing-Complete Programming Language*, https://muppetlabs.com/~breadbox/bf/ (ostatni dostÄ™p 7.03.2024)
- tcsetattr(3) - Linux man page, https://linux.die.net/man/3/tcsetattr (ostatni dostÄ™p 7.03.2024)

<small>ZdjÄ™cie na okÅ‚adce wygenerowane przez DALL-E.</small>
