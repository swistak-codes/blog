import Link from 'next/link';
import {Image} from '@swistak-codes/components';
import cover from './rzymski-swistak.jpg';

export const meta = {
  title: 'Liczby rzymskie',
  abstract:
    'W artykule opisujÄ™, jak wyglÄ…da rzymski system zapisu liczb oraz jak moÅ¼emy do niego podejÅ›Ä‡ algorytmicznie.',
  firstParagraph: (
    <>
      W codziennym zastosowaniu oprÃ³cz wszechobecnego systemu dziesiÄ™tnego utrzymaÅ‚ siÄ™ do naszych czasÃ³w rÃ³wnieÅ¼ system rzymski. ZapisujÄ…c wiele nazw czy imion, nie wyobraÅ¼amy sobie, Å¼eby zapisaÄ‡ je z uÅ¼yciem cyfr arabskich â€” w koÅ„cu â€Benedykt XVIâ€ wyglÄ…da znacznie powaÅ¼niej niÅ¼ â€Benedykt 16.â€. Nas jednak interesuje inna strona systemu rzymskiego, czyli jak zaprogramowaÄ‡ jego obsÅ‚ugÄ™. StojÄ… za tym proste algorytmy, ktÃ³re sÄ… zwykle zadaniami na kursach podstaw programowania, dlatego sprÃ³bujmy napisaÄ‡ je wspÃ³lnie.
    </>
  ),
  keyword: 'liczby rzymskie',
  categories: ['Matematyka', 'Algorytmy'],
  tags: [
    'systemy addytywne',
    'matematyka',
    'liczby rzymskie',
    'javascript',
    'wyraÅ¼enia regularne'
  ],
  slug: 'liczby-rzymskie',
  updateTime: '2022-11-16T07:00:00+00:00',
  publishTime: '2022-11-16T07:00:00+00:00',
  cover,
};

## System rzymski

Rzymski system zapisu liczb miaÅ‚em juÅ¼ okazjÄ™ opisaÄ‡ na blogu w artykule *<Link href="/post/systemy-liczbowe-uzupelnienie">Systemy liczbowe â€” uzupeÅ‚nienie</Link>*. Rozpiszmy sobie jednak ten system nieco bardziej szczegÃ³Å‚owo, raczej pod kÄ…tem tego, Å¼eby zrozumieÄ‡ podstawowe zasady jego dziaÅ‚ania.

### System addytywny

Zacznijmy od tego, Å¼e system rzymski to system addytywny. Oznacza to tyle, Å¼e aby odczytaÄ‡ zapisanÄ… w nim wartoÅ›Ä‡, musimy zsumowaÄ‡ symbole reprezentujÄ…ce konkretne liczby, a ich pozycja nie ma w tym przypadku znaczenia. Przy czym pozycje w systemie rzymskim majÄ… znaczenie, chociaÅ¼ inne niÅ¼ w systemach pozycyjnych:

- Znaki sÄ… zapisywane od lewej strony w kolejnoÅ›ci od reprezentujÄ…cego najwiÄ™kszÄ… liczbÄ™ do reprezentujÄ…cego najmniejszÄ… liczbÄ™.
- Od tej reguÅ‚y jest jednak wyjÄ…tek, Å¼e moÅ¼emy poÅ‚Ä…czyÄ‡ ze sobÄ… znak reprezentujÄ…cy mniejszÄ… liczbÄ™ ze znakiem reprezentujÄ…cym liczbÄ™ wiÄ™kszÄ…. WÃ³wczas zamiast dodawaÄ‡, to od liczby wiÄ™kszej odejmujemy tÄ… mniejszÄ….

### Symbole systemu rzymskiego

PrzejdÅºmy jednak do samych znakÃ³w uÅ¼ywanych w systemie rzymskim. MoÅ¼emy wyrÃ³Å¼niÄ‡:

| symbol | wartoÅ›Ä‡ |
| :-: | :-: |
| M | 1000 |
| D | 500 |
| C | 100 |
| L | 50 |
| X | 10 |
| V | 5 |
| I | 1 |

Symbole moÅ¼emy Å‚Ä…czyÄ‡ ze sobÄ… analogicznie, jak opisaÅ‚em wczeÅ›niej, stÄ…d: III to 3, VI to 6, MMXI to 2011.

NaleÅ¼y wspomnieÄ‡, Å¼e kaÅ¼dy z symboli moÅ¼e byÄ‡ powtÃ³rzony co najwyÅ¼ej 3 razy. Oznacza to, Å¼e domyÅ›lnie nie jesteÅ›my w stanie zapisaÄ‡ takich liczb jak np. 4, 9, 40, 90, 900. Jak wspomniaÅ‚em wczeÅ›niej, moÅ¼emy Å‚Ä…czyÄ‡ wiÄ™kszy znak z mniejszym w celu odejmowania, tym samym zyskujÄ…c nastÄ™pujÄ…ce kombinacje:

| symbol | wartoÅ›Ä‡ |
| :-: | :-: |
| CM | 900 |
| CD | 400 |
| XC | 90 |
| XL | 40 |
| IX | 9 |
| IV | 4 |

DziÄ™ki temu moÅ¼emy tworzyÄ‡ kombinacje takie jak: XIV to 14, DIX to 509, MMMCXL to 3140. MoÅ¼emy teÅ¼ uÅ‚oÅ¼yÄ‡ najwiÄ™kszÄ… liczbÄ™ dostÄ™pnÄ… w standardowym systemie rzymskim â€” MMMCMXCIX, czyli 3999.

SwojÄ… drogÄ… warto dodaÄ‡, Å¼e symbole D i M zostaÅ‚y wprowadzone pÃ³Åºniej niÅ¼ pozotaÅ‚e. Rzymianie liczbÄ™ 500 zapisywali poczÄ…tkowo jako Iâ†ƒ (z czasem uproszczone do D), a 1000 jako CIâ†ƒ (z czasem uproszczone do â†€ i utrzymaÅ‚o siÄ™ tak aÅ¼ do wprowadzenia M w Å›redniowieczu).

### Zapis liczb spoza zakresu 1-3999

WedÅ‚ug powyÅ¼szej definicji moÅ¼emy zauwaÅ¼yÄ‡, Å¼e system rzymski jest w stanie zapisaÄ‡ nam jedynie liczby z zakresu od 1 do 3999. Jednak system ten byÅ‚ w Europie wykorzystywany w matematyce przez bardzo dÅ‚ugi czas i istniaÅ‚a moÅ¼liwoÅ›Ä‡ zapisu innych liczb. Z racji tego, Å¼e dziÅ› siÄ™ tego nie stosujÄ™, nie rozpiszÄ™ siÄ™ szczegÃ³Å‚owo na ten temat, a jedynie rozpiszÄ™ w ramach ciekawostki.

- Przez dÅ‚ugi czas w matematyce nie znano koncepcji liczby zero, stÄ…d system rzymski jej nie posiadaÅ‚. Z czasem zaczÄ™to oznaczaÄ‡ je literÄ… N od Å‚aciÅ„skiego *nihil* (po polsku: *nic*).
- W kwestii uÅ‚amkÃ³w najpowszechniejsze wÅ›rÃ³d rzymian byÅ‚o dzielenie na dwanaÅ›cie czÄ™Å›ci (system dwunastkowy). UÅ‚amki od $$\frac{1}{12}$$ do $$\frac{5}{12}$$ zapisywano przez stawianie kropek, np. $$\frac{4}{12}$$ to Â·Â·Â·Â· (lub âˆ·). PoÅ‚owa, czyli $$\frac{6}{12}$$, byÅ‚a oznaczana literÄ… S (od Å‚aciÅ„skiego *semis*), a potem kolejne uÅ‚amki konstruowano przez dokÅ‚adanie kropek, np. $$\frac{11}{12}$$ to SÂ·Â·Â·Â·Â· (lub Sâ™). OprÃ³cz tego istniaÅ‚y symbole uÅ¼ywane do bardziej specjalistycznych uÅ‚amkÃ³w, np. $$\frac{1}{72}$$ ($$\frac{1}{6}$$ uncji) to ğ†“.
- Nie powstaÅ‚ nigdy jeden standard zapisu liczb wiÄ™kszych niÅ¼ 3999. Rzymianie w swoim oryginalnym zapisie liczby 1000 dodawali po obu stronach litery C, aby uzyskaÄ‡ wiÄ™ksze liczby, np. CCIâ†ƒâ†ƒ to 10000, a samo Iâ†ƒâ†ƒ to 5000. Innym, bardziej wspÃ³Å‚czesnym sposobem jest stosowanie poziomej kreski nad liczbÄ… w celu pomnoÅ¼enia jej przez 1000, np. $$\overline{\text{IV}}$$ to 4000. Jednak to zapis mylÄ…cy, bo powszechne jest dekorowanie liczb rzymskich przez dodanie nad i pod nimi poziomych linii.

### OdstÄ™pstwa od reguÅ‚

OczywiÅ›cie niemoÅ¼liwe jest, Å¼eby przez okoÅ‚o trzy tysiÄ…ce lat ludzie trzymali siÄ™ idealnie jednego ustandaryzowanego systemu zapisu. ZresztÄ… standard w znaczeniu takim, jak dziÅ› to rozumiemy, nigdy nie powstaÅ‚. Dlatego o ile symbole i zasady uÅ¼ywane dla liczb 1-3999 sÄ… powszechnie znane i uÅ¼ywane, tak przez lata byÅ‚o wiele odstÄ™pstw:

- CzÄ™sto Å‚amano zasadÄ™, Å¼e moÅ¼na zapisaÄ‡ maksymalnie trzy takie same znaki. Najpowszechniejsze jest uÅ¼ywanie IIII zamiast IV, co po dziÅ› moÅ¼emy spotkaÄ‡ na zegarach.
- W Å›redniowieczu powstaÅ‚o wiele dodatkowych symboli, np. F to 40, Y to 150, O to 11.
- Zapis duÅ¼ych liczb bywaÅ‚ upraszczany zgodnie z tym, jak wymawiano je w rÃ³Å¼nych jÄ™zykach. Np. w jÄ™zyku angielskim rok 1612 wymawia siÄ™ jako szesnaÅ›cie-dwanaÅ›cie (sixteen-twenty), stÄ…d zapis rzymski to XVIXII. Innym przykÅ‚adem sÄ… teksty francuskie, w ktÃ³rych moÅ¼emy znaleÅºÄ‡ powiÄ™kszanie liczb przez zapis w indeksie gÃ³rnym, np. IIII<sup>XX</sup>XIX, co dosÅ‚ownie odpowiada francuskiej wymowie tej liczby jako cztery-dwadzieÅ›cia-dziewiÄ™tnaÅ›cie (quatre-vingt-dix-neuf).
- Bardziej wspÃ³Å‚czesny przykÅ‚ad: Microsoft Excel w implementacji funkcji `=RZYMSKIE()` oferuje 5 rÃ³Å¼nych sposobÃ³w zapisu liczb rzymskich. Ich podsumowanie moÅ¼esz znaleÅºÄ‡ [w dokumentacji Excela](https://support.microsoft.com/pl-pl/office/rzymskie-funkcja-d6b0b99e-de46-4704-a518-b45a0f8b56f5?ns=macexcel&version=90&ui=pl-pl&rs=pl-pl&ad=pl).

Warto jednak wiedzieÄ‡, Å¼e w wiÄ™kszoÅ›ci przypadkÃ³w nie musimy przejmowaÄ‡ siÄ™ tymi rzeczami. Przy dalej tÅ‚umaczonych przeze mnie podejÅ›ciach algorytmicznych caÅ‚kowicie zignorujÄ™ te odstÄ™pstwa, jak i to, Å¼e moÅ¼na zapisywaÄ‡ liczby inne niÅ¼ naturalne z przedziaÅ‚u 1-3999.

## Zamiana systemu rzymskiego na dziesiÄ™tny

Zacznijmy od moim zdaniem najprostszej operacji, czyli przeksztaÅ‚cenia liczby w systemie rzymskim na system dziesiÄ™tny (zapisany cyframi arabskimi).

Wszystko, co musimy wiedzieÄ‡, aby tego dokonaÄ‡, to znaÄ‡ 7 symboli zapisu rzymskiego. Wtedy odczytujemy po kolei znaki i sumujemy ich wartoÅ›ci. NaleÅ¼y jednak pamiÄ™taÄ‡, Å¼e znak o wyÅ¼szej wartoÅ›ci moÅ¼e byÄ‡ poprzedzony znakiem o niÅ¼szej wartoÅ›ci â€” wÃ³wczas odejmujemy wartoÅ›Ä‡.

### Algorytm

SposobÃ³w na zalgorytmizowanie tego zapewne znalazÅ‚oby siÄ™ kilka. My przeÅ‚Ã³Å¼my wprost to, co opisaÅ‚em powyÅ¼ej. MoÅ¼emy rozpisaÄ‡ to algorytmicznie na nastÄ™pujÄ…ce kroki:

1. Zainicjujmy zmiennÄ…, ktÃ³ra przechowa wynik. Z racji tego, Å¼e bÄ™dziemy sumowaÄ‡, poczÄ…tkowÄ… wartoÅ›ciÄ… musi byÄ‡ 0.
2. Przechodzimy po kolei (od lewej do prawej) po znakach liczby zapisanej w systemie rzymskim:
    1. ZamieÅ„my aktualny znak na jego wartoÅ›Ä‡ w systemie dziesiÄ™tnym i przechowajmy tÄ™ wartoÅ›Ä‡.
    2. JeÅ›li istnieje, pobierzmy nastÄ™pny znak:
        1. ZamieÅ„my ten znak na jego wartoÅ›Ä‡ w systemie dziesiÄ™tnym. JeÅ›li wartoÅ›Ä‡ jest wiÄ™ksza niÅ¼ poprzedniego znaku, odejmijmy od niej wartoÅ›Ä‡ poprzedniego i przechowajmy tÄ™ wartoÅ›Ä‡ (zamiast wartoÅ›ci poprzedniego znaku).
        2. W tym momencie naleÅ¼y pamiÄ™taÄ‡, Å¼e rozpatrzyliÅ›my kolejny znak niÅ¼ aktualny w iteracji, wiÄ™c powinniÅ›my go pominÄ…Ä‡.
    3. Do wyniku dodajmy przechowanÄ… wartoÅ›Ä‡.
3. Zwracamy zmiennÄ… z wynikiem.

### Implementacja

Opisany powyÅ¼ej algorytm moÅ¼emy przenieÅ›Ä‡ na jÄ™zyk JavaScript w nastÄ™pujÄ…cy sposÃ³b:

```javascript
// sÅ‚ownik konwersji wyznaczajÄ…cy, ktÃ³ry symbol
// odpowiada ktÃ³rej liczbie
const CONVERSION_MAP = {
  M: 1000,
  D: 500,
  C: 100,
  L: 50,
  X: 10,
  V: 5,
  I: 1
};

function romanToInt(numeral) {
  // zmienna, ktÃ³ra przechowa wynik
  let result = 0;

  // przechodzimy po kolejnych znakach stringa zawierajÄ…cego liczbÄ™ rzymskÄ…
  for (let i = 0; i < numeral.length; i++) {
    // pobieramy wartoÅ›Ä‡ aktualnego znaku
    let value = CONVERSION_MAP[numeral[i]];
    // jeÅ›li nie jesteÅ›my na koÅ„cu, moÅ¼e byÄ‡ sytuacja,
    // Å¼e trzeba bÄ™dzie wykonaÄ‡ odejmowanie
    if (i < numeral.length - 1) {
      // sprawdzamy wartoÅ›Ä‡ nastÄ™pnego znaku
      const nextValue = CONVERSION_MAP[numeral[i + 1]];
      // jeÅ›li jest wyÅ¼sza, to znaczy,
      // Å¼e bÄ™dziemy musieli odejmowaÄ‡
      if (nextValue > value) {
        // przypisujemy pomniejszonÄ… wartoÅ›Ä‡
        value = nextValue - value;
        // poniewaÅ¼ rozpatrzyliÅ›my kolejny znak,
        // musimy przeskoczyÄ‡ o jednÄ… iteracjÄ™
        i++;
      }
    }
    // dodajemy wyliczonÄ… liczbÄ™ do aktualnego wyniku
    result += value;
  }

  // zwracamy wynik
  return result;
}
```

ImplementacjÄ™ moÅ¼esz przetestowaÄ‡ [na stronie repl.it](https://replit.com/@tswistak/roman-to-int#index.js).

## Zamiana systemu dziesiÄ™tnego na rzymski

DziaÅ‚anie w drugÄ… stronÄ™ jest juÅ¼ nieco mniej intuicyjne, jednak wciÄ…Å¼ jest to bardzo prosta operacja.

Aby liczbÄ™ zapisanÄ… w systemie dziesiÄ™tnym zapisaÄ‡ w systemie rzymskim, najproÅ›ciej jest sprawdzaÄ‡, ile razy dany znak mieÅ›ci siÄ™ w naszej liczbie. Zaczynamy od najwiÄ™kszego znaku, czyli od M, sprawdzamy, ile w liczbie jest tysiÄ™cy, i tyle razy zapisujemy symbol M. Potem schodzimy po kolei, aÅ¼ do najmniejszej wartoÅ›ci, czyli I (1). Musimy jednak pamiÄ™taÄ‡, Å¼e zamiast powtarzaÄ‡ symbol 4 razy, powinniÅ›my zastosowaÄ‡ odejmowanie, stÄ…d w kaÅ¼dym takim przypadku zamieniamy 4 symbole na odpowiadajÄ…ce im odejmowanie pokazane przeze mnie wczeÅ›niej. Ewentualnie moÅ¼emy te zÅ‚Ä…czenia symboli rÃ³wnieÅ¼ wÅ‚Ä…czyÄ‡ do â€schodzenia po kolei po wartoÅ›ciachâ€ â€” wÃ³wczas zamiast sprawdzaÄ‡ M, potem D, sprawdzimy: M, CM i D.

### Algorytm

Podobnie jak poprzednio, nie ma jednego konkretnego algorytmu jak zamieniaÄ‡, dlatego przeÅ‚Ã³Å¼my na jÄ™zyk algorytmiki wprost to, co opisaÅ‚em powyÅ¼ej. Zastosujemy uproszczenie polegajÄ…ce na tym, Å¼e nie bÄ™dziemy rÄ™cznie odejmowaÄ‡ symboli, tylko wÅ‚Ä…czymy te kombinacje do iteracji. Warto takÅ¼e wspomnieÄ‡, Å¼e w jÄ™zyku matematyki to, ile razy coÅ› siÄ™ mieÅ›ci w czymÅ›, wyznacza nam dzielenie, natomiast ile po takiej operacji pozostaje â€” <Link href="/post/dziwny-przypadek-reszty-z-dzielenia">reszta z dzielenia</Link>.

MoÅ¼emy w takim razie przejÅ›Ä‡ do krokÃ³w algorytmu:

1. Zainicjujmy zmiennÄ… przechowujÄ…cÄ… wynik, ktÃ³ra na starcie bÄ™dzie pustym Å‚aÅ„cuchem znakÃ³w*.
2. PrzechodÅºmy po kolei po symbolach (M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I):
    1. Pobierzmy wartoÅ›Ä‡ symbolu w systemie dziesiÄ™tnym.
    2. Podzielmy liczbÄ™ przez wartoÅ›Ä‡ symbolu, co wyznaczy, ile razy mamy symbol powtÃ³rzyÄ‡.
    3. ZapamiÄ™tajmy do nastÄ™pnej iteracji resztÄ™ z dzielenia liczby przez wartoÅ›Ä‡ symbolu.
    4. Dodajmy do wyniku symbol tyle razy, ile wyznaczyliÅ›my w punkcie 2.2.
3. Zwracamy zmiennÄ… z wynikiem.

\* W zaleÅ¼noÅ›ci od jÄ™zyka programowania warto siÄ™ zapoznaÄ‡, ktÃ³ry sposÃ³b rozbudowywania Å‚aÅ„cucha o kolejne znaki bÄ™dzie najszybszy, np. stosujÄ…c obiekty typu StringBuilder (Java, C#). WeÅº jednak pod uwagÄ™, Å¼e w przypadku liczb rzymskich moÅ¼emy mieÄ‡ do czynienia z ok. 10 konkatenacjami, co przy zwykÅ‚ym typie znakowym bÄ™dzie nieodczuwalne wydajnoÅ›ciowo.

### Implementacja

Opisany powyÅ¼ej algorytm moÅ¼emy przenieÅ›Ä‡ na jÄ™zyk JavaScript w nastÄ™pujÄ…cy sposÃ³b:

```javascript
// tablica konwersji, gdzie zaczynamy od najwiÄ™kszego symbolu
// i idziemy po kolei, do najmniejszego;
// dla uproszczenia algorytmu zapisujemy w niej
// takÅ¼e wartoÅ›ci pomniejszone,
// takie jak IX (10 pomniejszone o 1 = 9) czy IV (5 pomniejszone o 1 = 4)
const CONVERSION_TABLE = [
  ['M', 1000],
  ['CM', 900],
  ['D', 500],
  ['CD', 400],
  ['C', 100],
  ['XC', 90],
  ['L', 50],
  ['XL', 40],
  ['X', 10],
  ['IX', 9],
  ['V', 5],
  ['IV', 4],
  ['I', 1],
]

function intToRoman(number) {
  // zmienna, ktÃ³ra przechowa, ile liczby jeszcze zostaÅ‚o nam
  // do konwersji
  let leftToConvert = number;
  // zmienna przechowujÄ…ca wynik
  let result = '';

  // iterujemy po kolei po tablicy konwersji
  // do dwÃ³ch zmiennych: symbol i value
  // zapis [symbol, value] to destrukturyzacja tablicy
  for (const [symbol, value] of CONVERSION_TABLE) {
    // sprawdzamy, ile razy symbol musi zostaÄ‡ powtÃ³rzony
    const times = Math.trunc(leftToConvert / value)
    // wyliczamy liczbÄ™, ktÃ³ra bÄ™dzie przeksztaÅ‚cana
    // w nastÄ™pnej iteracji
    leftToConvert %= value;
    // dodajemy do wyniku symbole powtÃ³rzone odpowiedniÄ… liczbÄ™ razy
    result += symbol.repeat(times);
  }

  return result;
}
```

ImplementacjÄ™ moÅ¼esz przetestowaÄ‡ [na stronie repl.it](https://replit.com/@tswistak/int-to-roman#index.js).

## Sprawdzenie poprawnoÅ›ci liczby rzymskiej

Ostatnia kwestia pozostajÄ…ca do wykonania, zwiÄ…zana z liczbami rzymskimi, to sprawdzenie, czy sÄ… one poprawne wedÅ‚ug najpowszechniejszych reguÅ‚. ReguÅ‚y zapisu przedstawiÅ‚em na samym poczÄ…tku, ale zapiszmy je w bardziej zwiÄ™zÅ‚y i konkretny sposÃ³b. ZaczynajÄ…c od poczÄ…tku ciÄ…gu znakÃ³w:

- Litera M moÅ¼e pojawiÄ‡ siÄ™ 0, 1, 2 lub 3 razy.
- NastÄ™pnie moÅ¼emy mieÄ‡ CM, CD albo (opcjonalnie) D i C powtÃ³rzone 0, 1, 2 lub 3 razy.
- Analogicznie jest z symbolem X. MoÅ¼emy mieÄ‡ XC, XL albo (opcjonalnie) L i X powtÃ³rzone 0, 1, 2 lub 3 razy.
- Tak samo z I. MoÅ¼emy mieÄ‡ IX, IV albo (opcjonalnie) V i I powtÃ³rzone 0, 1, 2 lub 3 razy.
- W tym momencie ciÄ…g powinien siÄ™ skoÅ„czyÄ‡.

JeÅ›li zadany ciÄ…g liter speÅ‚nia te warunki, mamy do czynienia z liczbÄ… zapisanÄ… w systemie rzymskim.

### WyraÅ¼enie regularne

W takim przypadku jak ten, gdzie musimy sprawdziÄ‡, czy ciÄ…g znakÃ³w pasuje do pewnego zadanego wzorca, nie ma co siÄ™ zmuszaÄ‡ do napisania algorytmu. Zdecydowanie lepiej zapisaÄ‡ tÄ™ reguÅ‚Ä™ w jeden z najbardziej znienawidzony przez programistÃ³w sposÃ³b â€” jako wyraÅ¼enie regularne.

Wbrew powszechnemu przekonaniu pisanie wyraÅ¼eÅ„ regularnych w wiÄ™kszoÅ›ci przypadkÃ³w nie jest trudne. MoÅ¼na siÄ™ przy tym posiÅ‚kowaÄ‡ takimi stronami, jak np. [RegExr](https://regexr.com/), gdzie mamy jednoczeÅ›nie edytor wyraÅ¼eÅ„, pole do ich testowania oraz Å›ciÄ…gÄ™ jak je pisaÄ‡.

WyraÅ¼enie regularne, ktÃ³re sprawdzi powyÅ¼ej opisane reguÅ‚y, wyglÄ…da nastÄ™pujÄ…co:

```regex
^M{0,3}(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$
```

Jego skÅ‚adowe oznaczajÄ…:

- `^` â€” poczÄ…tek ciÄ…gu. W ten sposÃ³b zaznaczamy, Å¼e nasze wyraÅ¼enie regularne ma sprawdzaÄ‡ ciÄ…g znakÃ³w od poczÄ…tku.
- `M{0,3}` â€” `M` moÅ¼e byÄ‡ powtÃ³rzone od 0 do 3 razy.
- `C[MD]` â€” `CM` lub `CD`. W nawiasie kwadratowym zapisuje siÄ™, spoÅ›rÃ³d ktÃ³rych znakÃ³w moÅ¼emy wybieraÄ‡ na wskazanej pozycji.
- `C[MD]|D` â€” pojawi siÄ™ wyraÅ¼enie speÅ‚niajÄ…ce albo reguÅ‚Ä™ `C[MD]`, albo `D` (czyli wystÄ…pienie litery D).
- `D?` â€” `D` jest opcjonalne. Jest to skrÃ³cona forma zapisu `D{0,1}`.
- Nawiasy oznaczajÄ… grupÄ™, ktÃ³rÄ… tutaj moÅ¼emy rozumieÄ‡ jako zamkniÄ™ty zestaw reguÅ‚. DziÄ™ki temu znak `|` nie oddziaÅ‚uje poza nawias.
- Dwie pozostaÅ‚e grupy sÄ… zbudowane analogicznie, stÄ…d nie bÄ™dÄ™ juÅ¼ ich opisywaÄ‡.
- Ostatni znak, ktÃ³ry nam pozostaÅ‚, to `$` oznaczajÄ…cy koniec ciÄ…gu znakÃ³w. Tym samym, majÄ…c zarÃ³wno `^`, jak i `$`, mÃ³wimy, Å¼e nasze wyraÅ¼enie regularne musi byÄ‡ speÅ‚nione przez caÅ‚y ciÄ…g, a nie tylko jego fragment.

### Implementacja

Tak naprawdÄ™ implementacja w tym przypadku to jedynie przekopiowanie wyraÅ¼enia regularnego do jÄ™zyka programowania i uÅ¼ycie funkcji, ktÃ³ra sprawdzi, czy ciÄ…g â€przechodziâ€ przez nie. W JavaScript wyglÄ…da to nastÄ™pujÄ…co:

```javascript
function isValidRomanNumeral(numeral) {
  const regex = /^M{0,3}(C[MD]|D?C{0,3})(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$/;
  return regex.test(numeral);
}
```

ImplementacjÄ™ moÅ¼esz przetestowaÄ‡ [na stronie repl.it](https://replit.com/@tswistak/is-valid-roman#index.js).

## Podsumowanie

W artykule przedstawiÅ‚em: czym jest system rzymski, jak dziaÅ‚a oraz z jakimi zadaniami algorytmicznymi z nim zwiÄ…zanymi moÅ¼emy siÄ™ mierzyÄ‡. Nie sÄ… to jedyne sÅ‚uszne algorytmy, a jedynie przykÅ‚adowe, ktÃ³re wymyÅ›liÅ‚em na podstawie definicji systemu rzymskiego. MoÅ¼liwe, Å¼e w innych miejscach w Internecie znajdziesz inne rozwiÄ…zania albo nawet analogiczne, i jest to caÅ‚kowicie normalne. Zagadnienie to jest bardzo proste i nie ma co siÄ™ wysilaÄ‡ na jakieÅ› wyszukane rozwiÄ…zania. LiczÄ™, Å¼e pomogÅ‚o Ci to zrozumieÄ‡ tok myÅ›lenia â€” od problemu, przez opisanie jego rozwiÄ…zania, po opracowanie algorytmu go rozwiÄ…zujÄ…cego.

<small>ZdjÄ™cie na okÅ‚adce wygenerowane przez DALL-E.</small>
