import Link from 'next/link';
import {Image} from '@swistak-codes/components';
import cover from './syzyf.jpg';
import petla from './petla.png';
import bpmn from './bpmn.png';
import doWhile from './do-while.png';

export const meta = {
  title: 'Iteracja â€” co to jest?',
  abstract:
    'Iteracja to jedna z najbardziej podstawowych technik sterowania wykonaniem programu. KaÅ¼dy programista jÄ… zna, ale mimo to wejdÅºmy w temat gÅ‚Ä™biej.',
  firstParagraph: (
    <>
      Iteracja to wedÅ‚ug sÅ‚ownika PWN-u metoda polegajÄ…ca na wielokrotnym stosowaniu tej samej procedury. Nawet nieskoÅ„czenie, niczym Syzyf wtaczajÄ…cy gÅ‚az na szczyt gÃ³ry (jak na okÅ‚adce). W zasadzie na tym mÃ³gÅ‚bym zamknÄ…Ä‡ ten artykuÅ‚, bo wÅ‚aÅ›nie odpowiedziaÅ‚em na pytanie z tytuÅ‚u. Jednak mimo to wejdÅºmy w temat gÅ‚Ä™biej: jakie mamy rodzaje iteracji, do czego siÄ™ ostatecznie sprowadzajÄ…, co majÄ… wspÃ³lnego z <Link href="/post/rekurencja-co-to-jest">rekurencjÄ…</Link>, a takÅ¼e czym sÄ… iteratory.
    </>
  ),
  keyword: 'iteracja',
  categories: ['Programowanie'],
  tags: [
    'iteracja',
    'rekurencja',
    'c',
    'c++',
    'c#',
    'java',
    'javascript',
    'pascal',
    'python',
    'struktury danych',
    'LINQ',
    'SQL',
    'jÄ™zyk zapytaÅ„',
    'for',
    'for each',
    'while',
    'do while',
    'skok',
    'rozgaÅ‚Ä™zienie',
    'schemat blokowy',
    'bpmn',
    'goto',
    'iterator',
    'generator',
    'break',
    'continue'
  ],
  slug: 'iteracja-co-to-jest',
  updateTime: '2022-12-21T07:00:00+00:00',
  publishTime: '2022-12-21T07:00:00+00:00',
  cover,
  comment: 'Dzisiaj przychodzÄ™ do Was z artykuÅ‚em poÅ›wiÄ™conym iteracji. Zagadnienie bardzo podstawowe, wrÄ™cz leÅ¼Ä…ce u podstaw nauki kaÅ¼dego jÄ™zyka programowania, jednak jak sam siÄ™ przekonaÅ‚em, piszÄ…c ten artykuÅ‚, moÅ¼na o nim powiedzieÄ‡ bardzo wiele. ZdajÄ™ sobie sprawÄ™, Å¼e tekst jest dÅ‚ugi i niektÃ³rzy wydajÄ… krÃ³tsze ksiÄ…Å¼ki, ale wielu rzeczy po prostu nie mogÅ‚em pominÄ…Ä‡. GorÄ…co zachÄ™cam do lektury zarÃ³wno poczÄ…tkujÄ…cych, jak i bardziej zaawansowanych programistÃ³w â€” myÅ›lÄ™, Å¼e kaÅ¼dy znajdzie tutaj coÅ› dla siebie.'
};

## O co chodzi?

Mimo Å¼e we wstÄ™pie podaÅ‚em sÅ‚ownikowÄ… definicjÄ™ iteracji, sprÃ³bujmy rozÅ‚oÅ¼yÄ‡ to na prostsze czynniki. Aby uproÅ›ciÄ‡ formÄ™, wypunktujmy:

- Iteracja polega na powtarzaniu pewnej czynnoÅ›ci.
- Kolejne powtÃ³rzenia nazywamy pierwszÄ… iteracjÄ…, drugÄ… iteracjÄ… itd.
- Liczba powtÃ³rzeÅ„ moÅ¼e byÄ‡ okreÅ›lona bÄ…dÅº nie. NieskoÅ„czonoÅ›Ä‡ to takÅ¼e poprawna liczba powtÃ³rzeÅ„.
    - OczywiÅ›cie nieskoÅ„czona pÄ™tla spowoduje, Å¼e program siÄ™ nigdy nie zakoÅ„czy. Jest to wiec bÅ‚Ä…d, aczkolwiek zwykle nic nie powstrzyma nas przed nim.
- Liczba powtÃ³rzeÅ„ jest ustalana warunkiem. Innymi sÅ‚owy, czy wskazanÄ… procedurÄ™ powtarzamy po raz kolejny, decydujemy przez sprawdzenie jakiejÅ› wartoÅ›ci. MoÅ¼e byÄ‡ to odgÃ³rnie okreÅ›lona liczba powtÃ³rzeÅ„, osiÄ…gniÄ™cie jakiegoÅ› stanu systemu czy sygnaÅ‚ z zewnÄ…trz.
    - Warto dodaÄ‡, Å¼e zwykle warunek jest Å›ciÅ›le czÄ™Å›ciÄ… definicji pÄ™tli. MoÅ¼emy jednak napisaÄ‡ pÄ™tlÄ™ nieskoÅ„czonÄ… i z wnÄ™trza procedury wymusiÄ‡ jej przerwanie. Jest to dozwolone, jÄ™zyki programowania na to pozwalajÄ…, aczkolwiek w kwestii, czy powinniÅ›my tak robiÄ‡, napiszÄ™ wiÄ™cej w dalszej czÄ™Å›ci artykuÅ‚u.
    - Ponadto warunek pÄ™tli moÅ¼e byÄ‡ ukryty. Nieraz iterujÄ…c, przechodzimy np. przez wszystkie elementy jakiejÅ› struktury danych. Wtedy mÃ³wiÄ…c o takiej pÄ™tli, nie podajemy wprost warunku, a same jÄ™zyki programowania ukrywajÄ… go przed nami, o czym teÅ¼ wspomnÄ™ dalej.
- Warunek, czy pÄ™tlÄ™ kontynuujemy, czy koÅ„czymy, moÅ¼emy sprawdziÄ‡ zarÃ³wno po pierwszej iteracji (czyli przejÅ›ciu procedury), jak i przed jej rozpoczÄ™ciem.

### PÄ™tle w zapisie algorytmÃ³w w postaci listy krokÃ³w

Gdy zapoznajemy siÄ™ z algorytmami zapisanymi w tekÅ›cie, nie w Å¼adnym jÄ™zyku programowania, to moÅ¼emy zwykle spotkaÄ‡ siÄ™ z jednym z trzech sposobÃ³w zapisu:

- pseudokod
- lista krokÃ³w
- schemat blokowy

Czasami programiÅ›ci majÄ… do czynienia z zapisem procesÃ³w biznesowych w jÄ™zyku BPMN. Ten jednak jest bardzo zbliÅ¼ony do tradycyjnych schematÃ³w blokowych.

Pseudokod wyglÄ…da jak jÄ™zyk programowania, dlatego go pomiÅ„my. Zobaczmy wiÄ™c, w jaki sposÃ³b iteracje zapisujemy w liÅ›cie krokÃ³w. Jest to najczÄ™Å›ciej spotykana forma zapisu w tekstach naukowych i teÅ¼ ja jÄ… stosujÄ™ na blogu, wiÄ™c od niej zacznijmy. OczywiÅ›cie to tylko pewien schemat, uÅ¼yte w praktyce sÅ‚owa mogÄ… byÄ‡ inne.

1. PowtÃ³rz [liczba] razy:
    1. Procedura...
2. Tak dÅ‚ugo, jak [warunek]:
    1. Procedura...
3. Dla kaÅ¼dego elementu [struktura danych]:
    1. Procedura...

WyglÄ…da to tak, Å¼e pokazane punkty 1, 2 i 3 sÄ… definicjami pÄ™tli, natomiast podpunkty w nich to procedura, ktÃ³rÄ… powtarzamy. W praktyce przechodzenie przez takÄ… listÄ™ krokÃ³w wyglÄ…daÅ‚oby nastÄ™pujÄ…co:

1. Wchodzimy w punkt 1. W tym momencie powtÃ³rzyliÅ›my procedurÄ™ 0 razy, wiÄ™c wchodzimy wgÅ‚Ä…b.
2. Wykonujemy wszystkie podpunkty, w naszym przypadku tylko punkt 1.1.
3. Wracamy do punktu 1 i sprawdzamy, czy powtÃ³rzyliÅ›my juÅ¼ wskazanÄ… liczbÄ™ razy. JeÅ›li tak, znowu wykonujemy wszystkie podpunkty. JeÅ›li nie, przechodzimy do punktu 2.

### PÄ™tle w schematach blokowych algorytmÃ³w

Innym sposobem zapisu algorytmÃ³w sÄ… schematy blokowe, ktÃ³re czÄ™Å›ciej znajdziemy w szkolnych podrÄ™cznikach do informatyki. PÄ™tle wyglÄ…dajÄ… w nich zwykle jak na diagramie poniÅ¼ej:

<Image
  image={petla}
  alignCenter
  fullSize
  alt="Schemat blokowy zawierajÄ…cy blok o ksztaÅ‚cie rombu z napisem warunek. Wychodzi z niego strzaÅ‚ka w dÃ³Å‚ z podpisem TAK i strzaÅ‚ka w prawo z podpisem NIE. Pod strzaÅ‚kÄ… opisanÄ… TAK znajduje siÄ™ blok o ksztaÅ‚cie prostokÄ…ta z napisem Procedura. Wychodzi z niego strzaÅ‚ka prowadzÄ…ca nad romb do lewej strony."
  caption={<>
  </>}
/>

CzÄ™sto moÅ¼na teÅ¼ siÄ™ spotkaÄ‡ z odwrÃ³ceniem kolejnoÅ›ci, czyli warunek sprawdzamy po wykonaniu procedur i potem przeskakujemy do jakiegoÅ› miejsca wczeÅ›niej w algorytmie. Na ogÃ³Å‚ strzaÅ‚ka zataczajÄ…ca pÄ™tlÄ™ oznacza zawsze iteracjÄ™. TeÅ¼ czasem jest rÃ³Å¼nica w zapisie, Å¼e strzaÅ‚ka nie trafia w innÄ… strzaÅ‚kÄ™, tylko od razu do bloku â€” nie ma tutaj konkretnej reguÅ‚y.

WspomniaÅ‚em wczeÅ›niej o jÄ™zyku BPMN. Raczej w zapisie procesÃ³w biznesowych nie stosuje siÄ™ warunkÃ³w tworzÄ…cych pÄ™tle jak w schematach blokowych algorytmÃ³w, ale zapÄ™tlenia teÅ¼ sÄ…. Zwykle zapisywane sÄ… tak jak na obrazku poniÅ¼ej. Z lewej znajduje siÄ™ iteracja po elementach kolekcji, po prawej iteracja oparta na warunku.

<Image
  image={bpmn}
  alignCenter
  fullSize
  alt="Po lewej stronie rysunku znajduje siÄ™ prostokÄ…t z napisem `SprawdÅº cenÄ™`, gdzie pod tekstem znajduje siÄ™ ikona z trzema pionowymi kreskami. Od prostokÄ…ta odchodzi w dÃ³Å‚ przerywana linia do notatki o treÅ›ci `Dla kaÅ¼dego produktu w koszyku`. Po prawej stronie znajduje siÄ™ prostokÄ…t z napisem `Pobierz wpÅ‚atÄ™`, gdzie pod tekstem znajduje siÄ™ ikonka ze strzaÅ‚kÄ… zakrÄ™conÄ… w pÄ™tlÄ™. Od prostokÄ…ta odchodzi w dÃ³Å‚ przerywana linia do notatki o treÅ›ci `Powtarzaj, aÅ¼ siÄ™ uda, maks. 3 razy`."
  caption={<>
  </>}
/>

## Skoki (rozgaÅ‚Ä™zienia)

Zacznijmy od tego, co jest podstawÄ… wszelkich iteracji i do czego tak naprawdÄ™ kaÅ¼da z nich siÄ™ sprowadza. Kod, ktÃ³ry piszemy (niewaÅ¼ne, czy piszesz w C i TwÃ³j kod jest kompilowany do pliku wykonywalnego, czy teÅ¼ piszesz interpretowane skrypty np. w Pythonie), prÄ™dzej czy pÃ³Åºniej zostaje sprowadzony do postaci rozkazÃ³w procesora. MoÅ¼esz je kojarzyÄ‡ pod nazwÄ… *jÄ™zyk asemblera*. Tak, ten najmniej rozbudowany, ale zarazem teoretycznie najtrudniejszy z jÄ™zykÃ³w programowania (w zasadzie jÄ™zyki, bo jest ich tyle, ile rodzajÃ³w procesorÃ³w) to nic innego jak rozkazy, ktÃ³re procesor odczytuje z pamiÄ™ci i wykonuje po kolei.

### Co to jest?

JeÅ›li masz jakieÅ› doÅ›wiadczenie z programowaniem, to na pewno kojarzysz takie instrukcje, jak `while`, `for` czy w niektÃ³rych jÄ™zykach `repeat`. MoÅ¼esz teÅ¼ znaÄ‡ pojÄ™cie rekurencji. Tych rzeczy w asemblerach nie ma. Kompilatory wszystkie te konstrukcje sprowadzajÄ… do skokÃ³w nazywanych takÅ¼e rozgaÅ‚Ä™zieniami. Czym one sÄ…?

W zasadzie moÅ¼na powiedzieÄ‡, Å¼e nazwa mÃ³wi wszystko. Najprostsza instrukcja skoku (np. w architekturze x86 `JMP`) wskazuje na miejsce, gdzie znajduje siÄ™ rozkaz, do ktÃ³rego chcemy przeskoczyÄ‡. OprÃ³cz tego sÄ… teÅ¼ bardziej rozbudowane skoki warunkowe, gdzie najpierw porÃ³wnujemy wartoÅ›ci, a potem w wybranym przypadku wykonujemy przejÅ›cie do innego rozkazu. Nie bÄ™dÄ™ przywoÅ‚ywaÄ‡ konkretnych instrukcji, ale sÄ… to rzeczy typu: â€przeskocz, jeÅ›li rÃ³wne zeroâ€, â€przeskocz, jeÅ›li rÃ³Å¼ne od zeraâ€, â€przeskocz, jeÅ›li wiÄ™kszeâ€ itd.

PoniÅ¼ej moÅ¼esz zobaczyÄ‡ prosty kod napisany w jÄ™zyku asemblera procesorÃ³w x86 (NASM) pod Linuksa. To, co robi, to wypisanie 10 razy tekstu `CzeÅ›Ä‡`.

```nasm
; kod aplikacji
section	.text
  global _start   ; okreÅ›lenie etykiety, od ktÃ³rej zaczynamy
_start:
  ; inicjalizacja aplikacji
  mov ecx, 0      ; ustawiamy licznik iteracji na 0
loop_start:       ; etykieta okreÅ›lajÄ…ca poczÄ…tek pÄ™tli
  ; sprawdzenie warunku pÄ™tli
  cmp ecx, 10     ; sprawdzamy, czy licznik osiÄ…gnÄ…Å‚ wartoÅ›Ä‡ 10
  je loop_end     ; jeÅ›li tak, przeskakujemy do loop_end
  push ecx        ; wrzucamy z powrotem na stos wartoÅ›Ä‡ licznika
  ; wypisanie tekstu
  mov edx, len    ; ustawiamy w EDX dÅ‚ugoÅ›Ä‡ tekstu
  mov ecx, msg    ; w ECX tekst
  mov ebx, 1      ; w EBX ustawiamy, Å¼e interesuje nas wyjÅ›cie standardowe (1)
  mov eax, 4      ; w EAX ustawiamy komendÄ™ SYS_WRITE
  int 0x80        ; przerwanie woÅ‚Ä…jÄ…ce jÄ…dro systemu, aby wykonaÅ‚o polecenie
  ; dalsza obsÅ‚uga pÄ™tli
  pop ecx         ; ponownie Å›ciÄ…gamy licznik ze stosu
  add ecx, 1      ; zwiÄ™kszamy wartoÅ›Ä‡ licznika o 1
  jmp loop_start  ; przeskakujemy do poczÄ…tku pÄ™tli
loop_end:
  ; zakoÅ„czenie aplikacji
  mov eax, 1      ; w EAX ustawiamy komendÄ™ SYS_EXIT
  int 0x80        ; ponownie woÅ‚amy jÄ…dro systemu za pomocÄ… przerwania

; dane zapisane w pamiÄ™ci
section	.data
  msg	db	'CzeÅ›Ä‡',0xa  ; tekst do wypisania
  len	equ	$ - msg      ; dÅ‚ugoÅ›Ä‡ tekstu
```

Kod moÅ¼esz przetestowaÄ‡ na platformie [repl.it](https://replit.com/@tswistak/goto-asm#main.s). JeÅ›li tam nie dziaÅ‚a, moÅ¼esz rÃ³wnieÅ¼ sprawdziÄ‡ dziaÅ‚anie na [Compiler Explorer](https://godbolt.org/z/84j3T38vx).

Przeskoki wykonujÄ… tutaj dwie instrukcje:

- `je [nazwa etykiety]` â€” jeÅ›li poprzednia instrukcja porÃ³wnania zwrÃ³ciÅ‚a, Å¼e liczby sÄ… rÃ³wne, przeskakujemy do wskazanej etykiety.
- `jmp [nazwa etykiety]` â€” przeskok bez Å¼adnego warunku.

Etykiety definiowane jako nazwa zakoÅ„czona dwukropkiem sÄ… wygodnym uproszczeniem, dziÄ™ki ktÃ³remu Å‚atwiej jest nawigowaÄ‡ po kodzie przy definiowaniu przeskokÃ³w. Po skompilowaniu (tak, programy napisane w asemblerze rÃ³wnieÅ¼ kompilujemy) etykiety znikajÄ…, a przy instrukcjach skoku zostajÄ… zastÄ…pione adresami w pamiÄ™ci.

### Skoki poza asemblerami

Skoki to gÅ‚Ã³wny sposÃ³b tworzenia iteracji w asemblerach, ale spotkamy je rÃ³wnieÅ¼ w jÄ™zykach wyÅ¼szego poziomu. Znajdziemy je najczÄ™Å›ciej (w jÄ™zykach, ktÃ³re znam) pod instrukcjÄ… `goto` i tak siÄ™ je potocznie nazywa.

Wbrew pozorom instrukcjÄ™ `goto` znajdziemy nie tylko w jÄ™zykach kompilowanych do kodu maszynowego jak C, ale rÃ³wnieÅ¼ w interpretowanych (np. w skryptach BAT). Dla przykÅ‚adu ten sam program, ktÃ³ry napisaÅ‚em wyÅ¼ej w asemblerze, w C bÄ™dzie wyglÄ…daÄ‡ nastÄ™pujÄ…co:

```c
#include <stdio.h>

int main(void) {
  // ustawiamy licznik iteracji na 0
  int counter = 0;
loop_start:
  // sprawdzenie warunku pÄ™tli
  if (counter == 10) {
    // jeÅ›li licznik osiÄ…gnÄ…Å‚ 10, przeskakujemy do loop_end
    goto loop_end;
  }
  // wypisujemy tekst na wyjÅ›ciu standardowym
  printf("CzeÅ›Ä‡\n");
  // zwiÄ™kszamy wartoÅ›Ä‡ licznika o 1
  counter++;
  // przeskakujemy do poczÄ…tku pÄ™tli
  goto loop_start;
loop_end:
  // zakoÅ„czenie aplikacji
  return 0;
}
```

Kod moÅ¼esz przetestowaÄ‡ na [repl.it](https://replit.com/@tswistak/goto-c#main.c).

Warto jednak zauwaÅ¼yÄ‡, Å¼e jeÅ›li jÄ™zyk programowania pozwala na inne sposoby sterowania przepÅ‚ywem programu (w tym iteracje), instrukcji skoku **nie powinniÅ›my** uÅ¼ywaÄ‡. Najbardziej znanym z pierwszych przeciwnikÃ³w stosowania `goto` byÅ‚ Edsger W. Dijsktra (znany przede wszystkim z <Link href="/post/szukanie-najkrotszych-sciezek-w-grafie">algorytmu Dijkstry</Link>). NapisaÅ‚ bardzo popularny w Å›rodowisku informatycznym list *Go To Statement Considered Harmful* (instrukcja goto uznawana za szkodliwÄ…) i jego treÅ›Ä‡ moÅ¼ecie znaleÅºÄ‡ w [doi:10.1145/362929.362947](https://doi.org/10.1145/362929.362947). OpisujÄ…c w skrÃ³cie, jego argumenty przeciwko to:

- `goto` sprawia, Å¼e Å›ledzenie postÄ™pu iteracji jest utrudnione.
- Jest zbyt prymitywne.

Mimo to `goto` w niektÃ³rych jÄ™zykach programowania znalazÅ‚o inne zastosowania i o jednym z nich napiszÄ™ w dalszej czÄ™Å›ci artykuÅ‚u.

## while

PrzejdÅºmy teraz do najbardziej podstawowego sposobu iteracji â€” pÄ™tli `while`. Jest to dokÅ‚adnie to, co opisaÅ‚em wczeÅ›niej we wstÄ™pie teoretycznym, czyli jest to pÄ™tla, ktÃ³ra wykonuje siÄ™ tak dÅ‚ugo, jak speÅ‚niony jest warunek, i teÅ¼ zaczyna siÄ™ od warunku. UÅ¼ywam tutaj okreÅ›lenia *pÄ™tla while*, bo w wiÄ™kszoÅ›ci jÄ™zykÃ³w programowania spotkamy siÄ™ z zapisem w stylu:

```javascript
while (warunek) {
  akcja();
}
```

W pseudokodzie po polsku moglibyÅ›my zapisaÄ‡ to dosÅ‚ownie jako:

```
tak dÅ‚ugo, jak (warunek jest prawdziwy), wykonuj {
  akcja();
}
```

MoÅ¼emy teÅ¼ siÄ™ spotkaÄ‡ z zapisami typu `do while [warunek]` (np. Visual Basic), `while [warunek] do` (np. Pascal). OczywiÅ›cie nie kaÅ¼dy jÄ™zyk musi takÄ… pÄ™tlÄ™ posiadaÄ‡, czego Å›wietnymi przykÅ‚adami sÄ… tak powszechnie znane jÄ™zyki, jak Haskell czy Go. ZresztÄ… mÃ³wiÄ…c o Haskellu, warto wspomnieÄ‡, Å¼e jÄ™zyki programowania takie jak on, czyli wykorzystujÄ…ce paradygmat funkcyjny, z definicji nie powinny mieÄ‡ iteracji innych niÅ¼ rekurencja.

PowrÃ³Ä‡my jednak do pÄ™tli `while`. Å»eby juÅ¼ trzymaÄ‡ siÄ™ naszego przykÅ‚adu z wypisywaniem tekstu, zobaczmy, jak bÄ™dzie wyglÄ…daÄ‡ w jÄ™zyku C z tym rodzajem iteracji:

```c
#include <stdio.h>

int main(void) {
  // ustawiamy licznik iteracji na 0
  int counter = 0;
  // ustawiamy, Å¼e pÄ™tla wykonuje siÄ™, dopÃ³ki licznik nie dobiÅ‚ do 10
  while (counter < 10) {
    // wypisujemy tekst na wyjÅ›ciu standardowym
    printf("CzeÅ›Ä‡\n");
    // zwiÄ™kszamy wartoÅ›Ä‡ licznika o 1
    counter++;
  }
  // zakoÅ„czenie aplikacji
  return 0;
}
```

Kod moÅ¼esz edytowaÄ‡ i uruchomiÄ‡ na [repl.it](https://replit.com/@tswistak/while-c#main.c).

Jak widaÄ‡, nasza prosta aplikacja, dziÄ™ki zastosowaniu pÄ™tli `while`, skrÃ³ciÅ‚a siÄ™ i jednoczeÅ›nie pozbycie siÄ™ etykiet sprawiÅ‚o, Å¼e jest nieco czytelniejsza.

### Sytuacja po kompilacji

JeÅ›li jesteÅ› dociekliwy(-a), pewnie moÅ¼e CiÄ™ zaciekawiÄ‡, czy czasem uÅ¼ycie `goto` nie jest wydajniejsze od uÅ¼ycia `while`. Ja jednak nie bÄ™dÄ™ specjalnie pisaÄ‡ benchmarkÃ³w, a zamiast tego po prostu pokaÅ¼Ä™, jaki kod asemblera powstaÅ‚ po skompilowaniu obu aplikacji z uÅ¼yciem kompilatora gcc.

Najpierw kod, ktÃ³ry powstaÅ‚ po zastosowaniu `goto` w C:

```nasm
.LC0:
        .string "Cze\305\233\304\207"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], 0
.L2:
        cmp     DWORD PTR [rbp-4], 10
        je      .L7
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        add     DWORD PTR [rbp-4], 1
        jmp     .L2
.L7:
        nop
        mov     eax, 0
        leave
        ret
```

Oraz kod, ktÃ³ry otrzymaliÅ›my dziÄ™ki pÄ™tli `while`:

```nasm
.LC0:
        .string "Cze\305\233\304\207"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], 0
        jmp     .L2
.L3:
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        add     DWORD PTR [rbp-4], 1
.L2:
        cmp     DWORD PTR [rbp-4], 9
        jle     .L3
        mov     eax, 0
        leave
        ret
```

Jak moÅ¼esz zauwaÅ¼yÄ‡, wersja skompilowana z `while` jest nawet krÃ³tsza o jednÄ… liniÄ™ kodu (aczkolwiek nieistotnÄ…, bo instrukcja `nop` nic nie robi). W praktyce jednak dzieje siÄ™ podobnie, tylko jest nieco odwrÃ³cona kolejnoÅ›Ä‡ wykonywania rozkazÃ³w. W pierwszym przypadku w asemblerze otrzymaliÅ›my dokÅ‚adnie to samo, co napisaliÅ›my w C. W drugim przypadku w kodzie najpierw mamy zapisane ciaÅ‚o pÄ™tli, ale zanim w nie wejdziemy, przeskakujemy do warunku, ktÃ³ry jest dosyÄ‡ zmodyfikowany (zamiast `counter < 10` sprawdzamy `counter <= 9` â€” w zasadzie to samo), i z niego wracamy do ciaÅ‚a pÄ™tli. Rozkazy sÄ… niemal te same, jest tylko inna instrukcja skoku warunkowego, ale to wynika z inaczej zdefiniowanego warunku. Innymi sÅ‚owy, rÃ³Å¼nicy w dziaÅ‚aniu nie bÄ™dzie, a jeÅ›li juÅ¼, to niezauwaÅ¼alna.

JeÅ›li chcesz to zobaczyÄ‡ na wÅ‚asnÄ… rÄ™kÄ™, moÅ¼esz to sprawdziÄ‡ np. przy uÅ¼yciu online'owego narzÄ™dzia Compiler Explorer [pod tym linkiem](https://godbolt.org/z/Y5bqdc464).

## do while

PÄ™tla `while` to podstawowy sposÃ³b iteracji w wielu jÄ™zykach programowania. Jednak czasami chcemy wykonaÄ‡ przynajmniej jednÄ… iteracjÄ™, a dopiero potem sprawdziÄ‡ warunek. TakÄ… sytuacjÄ™ moglibyÅ›my zapisaÄ‡ poniÅ¼szym schematem blokowym:

<Image
  image={doWhile}
  alignCenter
  fullSize
  alt="Schemat blokowy zawierajÄ…cy blok o ksztaÅ‚cie prostokÄ…ta z napisem Procedura. Wychodzi z niego strzaÅ‚ka w dÃ³Å‚. Pod strzaÅ‚kÄ… znajduje siÄ™ blok o ksztaÅ‚cie rombu z napisem warunek. Wychodzi z niego strzaÅ‚ka w lewo z podpisem TAK prowadzÄ…ca nad prostokÄ…t do lewej strony. OprÃ³cz tego z rombu wychodzi teÅ¼ strzaÅ‚ka w prawo z podpisem NIE."
  caption={<>
  </>}
/>

OczywiÅ›cie bylibyÅ›my w stanie zaprogramowaÄ‡ taki przypadek pÄ™tlÄ… `while`, ale mamy do tego w wielu jÄ™zykach odpowiedniÄ… konstrukcjÄ™ â€” `do ... while`. Zwykle wyglÄ…da ona tak:

```javascript
do {
  akcja();
} while (warunek)
```

W pseudokodzie po polsku bÄ™dzie to brzmieÄ‡ nastÄ™pujÄ…co:

```
powtarzaj {
  akcja();
} kiedy (warunek jest prawdziwy);
```

MoÅ¼emy teÅ¼ spotkaÄ‡ jÄ… pod nazwami `repeat ... while` (np. Swift) czy `do ... loop while` (np. Visual Basic). WczeÅ›niej pokazywany przeze mnie przypadek jako pÄ™tla tego typu, zapisany w C, bÄ™dzie wyglÄ…daÄ‡ nastÄ™pujÄ…co:

```c
#include <stdio.h>

int main(void) {
  // ustawiamy licznik iteracji na 0
  int counter = 0;
  do {
    // wypisujemy tekst na wyjÅ›ciu standardowym
    printf("CzeÅ›Ä‡\n");
    // zwiÄ™kszamy wartoÅ›Ä‡ licznika o 1
    counter++;
    // ustawiamy, Å¼e pÄ™tla wykonuje siÄ™, dopÃ³ki licznik nie dobiÅ‚ do 10
  } while (counter < 10);
  // zakoÅ„czenie aplikacji
  return 0;
}
```

Kod moÅ¼esz sprawdziÄ‡ na [repl.it](https://replit.com/@tswistak/do-while-c#main.c). Dodatkowo na tym [kodzie w repl.it](https://replit.com/@tswistak/while-do-while-c#main.c) pokazaÅ‚em teÅ¼ porÃ³wnanie dziaÅ‚ania pÄ™tli `do ... while` oraz `while` pod kÄ…tem kolejnoÅ›ci wykonywania.

### OdwrÃ³cenie warunku

Warto w tym miejscu nadmieniÄ‡, Å¼e w niektÃ³rych jÄ™zykach programowania, np. w Ada i Pascalu, warunek w pÄ™tli jest odwrÃ³cony â€” mÃ³wi, kiedy koÅ„czymy pÄ™tlÄ™, a nie jak dÅ‚ugo ma trwaÄ‡. Innymi sÅ‚owy, pÄ™tla w pseudokodzie zapisana byÅ‚aby nastÄ™pujÄ…co:

```
powtarzaj {
  akcja();
} dopÃ³ki (warunek jest prawdziwy);
```

Pokazywany dotychczas przykÅ‚ad, ale tym razem w jÄ™zyku Pascal (zamiast `do ... while` jest `repeat ... until`), zapiszemy nastÄ™pujÄ…co:

```pascal
program DoWhilePascal;
// w Pascalu zmienne deklarujemy przed wÅ‚aÅ›ciwym kodem aplikacji
var
  counter: Integer;
begin
  // ustawiamy licznik iteracji na 0
  counter := 0;
  repeat
    // wypisujemy tekst na wyjÅ›ciu standardowym
    writeln('CzeÅ›Ä‡');
    // zwiÄ™kszaym wartoÅ›Ä‡ licznika o 1
    inc(counter);
    // ustawiamy, Å¼e pÄ™tla przestanie siÄ™ wykonywaÄ‡,
    // gdy licznik osiÄ…gnie wartoÅ›Ä‡ 10
  until counter = 10;
  // zakoÅ„czenie aplikacji
end.
```

Ten kod rÃ³wnieÅ¼ moÅ¼esz przetestowaÄ‡ na [repl.it](https://replit.com/@tswistak/do-while-pascal#main.p).

Jak widaÄ‡ na tym przykÅ‚adzie, jeÅ›li zmieniamy jÄ™zyki programowania, warto sprawdziÄ‡, czy podstawowe konstrukcje, takie jak wÅ‚aÅ›nie pÄ™tle, nie majÄ… rÃ³Å¼nic w stosowaniu. ChociaÅ¼ rÃ³Å¼nic miÄ™dzy jÄ™zykami z popularnÄ… C-podobnÄ… skÅ‚adniÄ… a Pascalem widaÄ‡ tu znacznie wiÄ™cej, np. przypisanie wartoÅ›ci z uÅ¼yciem `:=`, deklaracja zmiennych przed wÅ‚aÅ›ciwym kodem, sprawdzenie rÃ³wnoÅ›ci pojedynczym znakiem rÃ³wnoÅ›ci itd.

### Po kompilacji

OczywiÅ›cie konstrukcji `do while` nie mamy w asemblerach, ale analogicznie jak to zrobiliÅ›my z `while`, tutaj teÅ¼ moÅ¼emy zobaczyÄ‡, w jaki sposÃ³b kompilator jÄ™zyka C zapisuje tÄ™ pÄ™tlÄ™. A nasz dotychczasowy przykÅ‚ad wyglÄ…da nastÄ™pujÄ…co:

```nasm
.LC0:
        .string "Cze\305\233\304\207"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], 0
.L2:
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        add     DWORD PTR [rbp-4], 1
        cmp     DWORD PTR [rbp-4], 9
        jle     .L2
        mov     eax, 0
        leave
        ret
```

W tym przypadku kod jest jeszcze prostszy, bo mamy jedynie jeden przeskok warunkowy na koÅ„cu pÄ™tli. Jednak rÃ³Å¼nica jednego skoku (bo dosÅ‚ownie tym siÄ™ rÃ³Å¼ni ten kod) nie jest powodem, abyÅ›my stosowali wszÄ™dzie `do while` zamiast `while`. Obie wersje moÅ¼esz porÃ³wnaÄ‡ w serwisie [Compiler Explorer](https://godbolt.org/z/e7h6TG39M).

## for

KolejnÄ… z podstawowych konstrukcji oferujÄ…cych iteracjÄ™ sÄ… pÄ™tle `for`. NajczÄ™Å›ciej stosuje siÄ™ je w przypadkach, gdy znamy odgÃ³rnie liczbÄ™ powtÃ³rzeÅ„, jak w powyÅ¼ej pokazywanych przykÅ‚adach, gdzie odliczaliÅ›my liczbÄ™ iteracji. Jednak w tym przypadku muszÄ™ pokusiÄ‡ siÄ™ o nieco szersze rozpisanie niÅ¼ wczeÅ›niej, bo `for` ma kilka rÃ³Å¼nych twarzy. Od razu powiem, Å¼e teraz opiszÄ™ tylko jednÄ… czÄ™Å›Ä‡, a o dalszej wspomnÄ™ dalej w artykule.

### for jako pÄ™tla z licznikiem

GÅ‚Ã³wna twarz pÄ™tli `for`, ktÃ³rÄ… zna kaÅ¼dy programista, to pÄ™tla z licznikiem. Znamy odgÃ³rnie, ile razy wykona siÄ™ iteracja, i po prostu tyle razy wykonujemy. SÄ… to przypadki typu:

- PowtÃ³rz \[liczba\] razy.
- Dla liczb od \[liczba\] do \[liczba\].
- Dla kaÅ¼dego elementu z \[nazwa kolekcji\] â€” moÅ¼na to rozumieÄ‡ na kilka sposobÃ³w, o czym powiemy sobie w pÃ³Åºniejszej czÄ™Å›ci artykuÅ‚u.

W zaleÅ¼noÅ›ci od jÄ™zyka programowania skÅ‚adnia bÄ™dzie wyglÄ…daÄ‡ inaczej. Jedne jÄ™zyki oferujÄ… po prostu odliczanie liczby iteracji, co jest klasycznym podejÅ›ciem do tego typu pÄ™tli. TakÄ… skÅ‚adniÄ™ znajdziemy np. w Pascalu:

```pascal
program ForPascal;
var
  // deklarujemy licznik iteracji
  // przyjÄ™Å‚o siÄ™ nazywaÄ‡ go "i"
  i: Integer;
begin
    // definiujemy, Å¼e iterujemy od 1 do 10 wÅ‚Ä…cznie (!)
    for i := 1 to 10 do begin
      // wypisujemy tekst wraz z wartoÅ›ciÄ… licznika
      writeln('CzeÅ›Ä‡. Iteracja nr ', i);
    end;
    // teraz iterujemy od tyÅ‚u
    for i := 10 downto 1 do begin
      // wypisujemy tekst wraz z wartoÅ›ciÄ… licznika
      writeln('Jeszcze raz. Iteracja nr ', i);
    end;
end.
```

Kod do samodzielnego przetestowania znajdziesz na [repl.it](https://replit.com/@tswistak/for-pascal#main.p).

SkÅ‚adnia pÄ™tli `for` jest bardzo prosta i skÅ‚ada siÄ™ z trzech elementÃ³w:

- PoczÄ…tkowej wartoÅ›ci licznika. ZwykÅ‚o siÄ™ nazywaÄ‡ go literÄ… `i`, a przy kolejnych zagnieÅ¼dÅ¼eniach pÄ™tli: `j`, `k` itd.
    - Drobna uwaga na boku: w wiÄ™kszoÅ›ci jÄ™zykÃ³w zwykle iteruje siÄ™ od zera, aczkolwiek Pascal jest jednym z niewielu jÄ™zykÃ³w programowania, gdzie przyjÄ™Å‚o siÄ™ numerowanie wszystkiego od 1.
- Kierunku iteracji. Albo inkrementujemy o 1 (`to`), albo dekrementujemy o 1 (`downto`).
- KoÅ„cowej wartoÅ›ci. Warto zwrÃ³ciÄ‡ uwagÄ™, jak jÄ™zyk programowania okreÅ›la warunek koÅ„cowy. W przypadku Pascala iterujemy do podanej wartoÅ›ci wÅ‚Ä…cznie.

Natomiast w jÄ™zykach bazujÄ…cych na skÅ‚adni C (czyli wiÄ™kszoÅ›Ä‡ obecnie popularnych) znajdziemy zupeÅ‚nie innÄ… konstrukcjÄ™, ktÃ³ra wyglÄ…da nastÄ™pujÄ…co (przykÅ‚ad w C):

```c
#include <stdio.h>

int main(void) {
  // definiujemy kolejno:
  // - licznik iteracji jako zmiennÄ… typu int o wartoÅ›ci 0
  // - iterujemy tak dÅ‚ugo, jak i jest mniejsze od 10
  // - na koÅ„cu kaÅ¼dej iteracji zwiÄ™kszamy wartoÅ›Ä‡ i o 1
  for (int i = 0; i < 10; i++) {
    // wypisujemy tekst wraz z wartoÅ›ciÄ… licznika
    printf("CzeÅ›Ä‡. Iteracja nr %d\n", i);
  }
  // teraz iterujemy od tyÅ‚u
  for (int i = 10; i > 0; i--) {
    // wypisujemy tekst wraz z wartoÅ›ciÄ… licznika
    printf("Jeszcze raz. Iteracja nr %d\n", i);
  }
  return 0;
}
```

Ponownie, kod znajdziesz teÅ¼ na [repl.it](https://replit.com/@tswistak/for-c#main.c).

SkÄ…d jednak taka rÃ³Å¼nica?

### for jako pÄ™tla while

PÄ™tla `for` w C i jÄ™zykach C-podobnych nie jest typowÄ… pÄ™tlÄ… z licznikiem. Tak naprawdÄ™ jest to pÄ™tla while, tylko z moÅ¼liwoÅ›ciÄ… zdefiniowania, co zrobiÄ‡ przed iteracjami i co robiÄ‡ po kaÅ¼dym przebiegu pÄ™tli. DokÅ‚adniej wyglÄ…da to tak:

```javascript
for (przedPetla(); warunek(); poKazdymPrzebiegu()) {
    akcja()
}
```

Tak samo\* bÄ™dzie dziaÅ‚aÄ‡ poniÅ¼szy `while`:

```javascript
przedPetla();
while (warunek()) {
    akcja();
    poKazdymPrzebiegu();
}
```

\* Jest drobna rÃ³Å¼nica, przez ktÃ³rÄ… nie jest dokÅ‚adnie tak samo, ale o tym pÃ³Åºniej.

Co wiÄ™cej, kaÅ¼dy z tych trzech elementÃ³w jest opcjonalny i moÅ¼e zawieraÄ‡ dowolny kod, np. tak wyglÄ…da pÄ™tla nieskoÅ„czona:

```javascript
for (;;) { }
// odpowiednik jako while
while (true) { }
```

Innymi sÅ‚owy, caÅ‚kowicie dozwolone jest zrobienie takich rzeczy:

```c
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <stdlib.h>

int main(void) {
  // --- 1 ---
  // ustawiamy dwa liczniki z rÃ³Å¼nymi wartoÅ›ciami: 0 i 1
  // pÄ™tlÄ™ wykonujemy tak dÅ‚ugo, jak iloraz obu licznikÃ³w jest podzielny przez 3
  // i zwiÄ™kszamy o 3, j o wartoÅ›Ä‡ i
  for (int i = 0, j = 1; i * j % 3 == 0; i += 3, j += i) {
    // wypisujemy obie wartoÅ›ci
    printf("%d, %d\n", i, j);
  }
  // --- 2 ---
  // tym razem zmienne zadeklarujemy na zewnÄ…trz
  int i;
  char* j;
  // pÄ™tlÄ™ wykonujemy tak dÅ‚ugo, jak rozmiar stringa j jest mniejszy od 20
  for (i = 0, j = ""; strlen(j) < 20; i++) {
    // wykonujemy kod tylko wtedy, gdy licznik jest podzielny przez 4
    if (i % 4 == 0) {
      // deklarujemy tymczasowÄ… zmiennÄ… na przechowanie nowego ciÄ…gu
      char tmp[100];
      // tworzymy nowy ciÄ…g
      sprintf(tmp, "%d%s", i, j);
      // przepisujemy go do zmiennej j
      j = tmp;
      // wypisujemy zawartoÅ›Ä‡ j na ekranie
      printf("%s\n", j);
    }
  }
  // --- 3 ---
  // zmienna bÄ™dzie deklarowana ponownie na zewnÄ…trz
  int isEven = 1;
  // inicjujemy generator liczb pseudolosowych
  srand(time(NULL));
  // pÄ™tla zawiera jedynie warunek, Å¼e ma siÄ™ wykonywaÄ‡, gdy isEven jest prawdziwe
  for (; isEven;) {
    // losujemy liczbÄ™
    int number = rand();
    // wypisujemy jÄ…
    printf("%d\n", number);
    // zapisujemy w isEven, czy liczba jest parzysta
    isEven = number % 2 == 0;
  }
  return 0;
}
```

Kod moÅ¼esz przetestowaÄ‡ na [repl.it](https://replit.com/@tswistak/for-different-c#main.c). ChciaÅ‚bym jednak dodaÄ‡, Å¼e o ile pierwszy przypadek jest jeszcze w miarÄ™ *normalny*, drugi kwestionowalny, o tyle w trzeciej pÄ™tli moÅ¼na byÅ‚oby uÅ¼yÄ‡ zwykÅ‚ego `while`.

Co ciekawe, w przypadku jÄ™zyka Go nie ma pÄ™tli `while` i jest ona zastÄ…piona wÅ‚aÅ›nie przez `for` z podaniem samego warunku, co moÅ¼na zobaczyÄ‡ [np. tutaj, w oficjalnym kursie jÄ™zyka](https://go.dev/tour/flowcontrol/3).

### for w asemblerach

#### Kompilacja kodu jÄ™zyka C

Ponownie sprawdÅºmy, jak pÄ™tla `for` kompiluje siÄ™ do asemblera. OczywiÅ›cie wrÃ³cimy do najprostszego uÅ¼ycia, czyli wypisywania tekstu â€CzeÅ›Ä‡â€ 10 razy, jak to robiliÅ›my dotychczas. WyglÄ…da to nastÄ™pujÄ…co:

```c
#include <stdio.h>

int main(void) {
  for (int i = 0; i < 10; i++) {
    printf("CzeÅ›Ä‡\n");
  }
  return 0;
}
```

Po skompilowaniu kod asemblera wyglÄ…da tak:

```nasm
.LC0:
        .string "Cze\305\233\304\207"
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     DWORD PTR [rbp-4], 0
        jmp     .L2
.L3:
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        add     DWORD PTR [rbp-4], 1
.L2:
        cmp     DWORD PTR [rbp-4], 9
        jle     .L3
        mov     eax, 0
        leave
        ret
```

Na stronie [Compiler Explorer](https://godbolt.org/z/enG74fsdE) moÅ¼esz porÃ³wnaÄ‡ ten kod do kodu analogicznej pÄ™tli `while`, ktÃ³rÄ… zaprogramowaliÅ›my na poczÄ…tku artykuÅ‚u. Jednak jeÅ›li nie chce Ci siÄ™ tam wchodziÄ‡, to juÅ¼ zdradzam tajemnicÄ™, co tam zobaczysz â€” kod asemblera jest identyczny w obu przypadkach.

#### PÄ™tle z licznikiem w asemblerach

PamiÄ™tasz jeszcze pierwszy kod z tego artykuÅ‚u, gdzie pokazaÅ‚em, jak robiÄ‡ pÄ™tle w asemblerze z wykorzystaniem przeskokÃ³w? SprawdzaliÅ›my tam wartoÅ›Ä‡ zapisanÄ… w rejestrze `ECX` i jeÅ›li byÅ‚a rÃ³wna 10, to przeskakiwaliÅ›my na koniec pÄ™tli. Nie bez powodu uÅ¼yÅ‚em wÅ‚aÅ›nie tego rejestru procesora, bo to wÅ‚aÅ›nie jego przyjÄ™Å‚o siÄ™ wykorzystywaÄ‡ do przechowywania licznikÃ³w iteracji. A dlaczego?

W asemblerze procesorÃ³w x86 znajduje siÄ™ rozkaz `LOOP`. Jego skÅ‚adnia to: `loop [etykieta z poczÄ…tkiem pÄ™tli]`. To, co ten rozkaz robi, znacznie upraszcza to, co robiliÅ›my do tej pory. Mianowicie pobiera wartoÅ›Ä‡ z rejestru `ECX`. JeÅ›li wynosi zero, rozkaz nic nie robi. W przeciwnym wypadku dekrementuje jÄ… o 1 i przeskakuje do wskazanej etykiety. MoÅ¼emy w takim przypadku uproÅ›ciÄ‡ kod do nastÄ™pujÄ…cego:

```nasm
; kod aplikacji
section	.text
  global _start   ; okreÅ›lenie etykiety, od ktÃ³rej zaczynamy
_start:
  ; inicjalizacja aplikacji
  mov ecx, 10     ; ustawiamy licznik iteracji na 0
loop_start:       ; etykieta okreÅ›lajÄ…ca poczÄ…tek pÄ™tli
  push ecx        ; wrzucamy z powrotem wartoÅ›Ä‡ licznika na stos
  ; wypisanie tekstu
  mov edx, len    ; ustawiamy w EDX dÅ‚ugoÅ›Ä‡ tekstu
  mov ecx, msg    ; w ECX tekst
  mov ebx, 1      ; w EBX ustawiamy, Å¼e interesuje nas wyjÅ›cie standardowe (1)
  mov eax, 4      ; w EAX ustawiamy komendÄ™ SYS_WRITE
  int 0x80        ; przerwanie woÅ‚Ä…jÄ…ce jÄ…dro systemu, aby wykonaÅ‚o polecenie
  ; dalsza obsÅ‚uga pÄ™tli
  pop ecx         ; ponownie Å›ciÄ…gamy licznik ze stosu
  loop loop_start ; przeskakujemy do poczÄ…tku pÄ™tli
  ; zakoÅ„czenie aplikacji
  mov eax, 1      ; w EAX ustawiamy komendÄ™ SYS_EXIT
  int 0x80        ; ponownie woÅ‚amy jÄ…dro systemu za pomocÄ… przerwania

; dane zapisane w pamiÄ™ci
section	.data
  msg	db	'CzeÅ›Ä‡',0xa  ; tekst do wypisania
  len	equ	$ - msg      ; dÅ‚ugoÅ›Ä‡ tekstu
```

OczywiÅ›cie nie jest to, dokÅ‚adnie rzecz ujmujÄ…c, pÄ™tla `for`, ale konstrukcja jest dosyÄ‡ podobna. MoÅ¼esz jÄ… przetestowaÄ‡ na [repl.it](https://replit.com/@tswistak/for-asm#main.s). JeÅ›li tam nie dziaÅ‚a, moÅ¼esz rÃ³wnieÅ¼ sprawdziÄ‡ dziaÅ‚anie na [Compiler Explorer](https://godbolt.org/z/zWe6qPrT6).

Warto dodaÄ‡, Å¼e nie kaÅ¼dy asembler udostÄ™pnia takie rzeczy. W przypadku x86 jest to architektura typu CISC (Complex Instruction Set Computing, z ang. obliczanie rozbudowanego zestawu instrukcji), co oznacza, Å¼e procesory wspierajÄ… bardzo duÅ¼Ä… liczbÄ™ rozkazÃ³w, w tym wykonujÄ…cych wiele czynnoÅ›ci jak opisany tutaj `loop`. Po drugiej stronie barykady mamy architektury typu RISC (Reduced Instruction Set Computing, z ang. obliczanie zredukowanego zestawu instrukcji), ktÃ³re charakteryzujÄ… siÄ™ nieduÅ¼ym zestawem instrukcji wykonujÄ…cych pojedyncze operacje. SÄ… coraz popularniejsze, np. zaliczajÄ… siÄ™ do nich mobilne procesory typu ARM. Przyznam, Å¼e szukaÅ‚em, czy asembler ARM-a posiada odpowiednik `loop` (nie powinien, poniewaÅ¼ Å‚amie to reguÅ‚y RISC), bo nigdy w nim nie pisaÅ‚em kodu, ale nic nie znalazÅ‚em. W kaÅ¼dym przykÅ‚adzie, na ktÃ³ry trafiÅ‚em, pÄ™tle z licznikiem sÄ… robione przez porÃ³wnywanie i przeskoki.

## Sterowanie przebiegiem pÄ™tli

Do tej pory przedstawiÅ‚em wszystkie podstawowe konstrukcje umoÅ¼liwiajÄ…ce tworzenie iteracji w rÃ³Å¼nych jÄ™zykach programowania. To jednak oczywiÅ›cie nie wszystko. Zanim przejdziemy do kolejnych rodzajÃ³w iteracji, poÅ›wiÄ™Ä‡my chwilÄ™ na instrukcje sterujÄ…ce przebiegiem pÄ™tli.

MÃ³wimy tutaj przede wszystkim o dwÃ³ch instrukcjach:

- `continue` â€” zatrzymanie wykonania aktualnej iteracji i przejÅ›cie do kolejnej,
- `break` â€” przerwanie pÄ™tli.

### continue

W przypadku `continue` sprawa wydaje siÄ™ doÅ›Ä‡ oczywista. Kod, ktÃ³ry znajduje siÄ™ za nim, nie wykona siÄ™ i przechodzimy do kolejnego wykonania pÄ™tli. PrzykÅ‚ad uÅ¼ycia moÅ¼esz zobaczyÄ‡ poniÅ¼ej:

```c
#include <stdio.h>

int main(void) {
  // ustawiamy poczÄ…tek licznika na 0
  int number = 0;
  // wykonujemy pÄ™tlÄ™, aÅ¼ osiÄ…gniemy liczbÄ™ 10
  while (number < 10) {
    // inkrementujemy liczbÄ™ na samym poczÄ…tku
    // gdybyÅ›my robili to na koÅ„cu, wpadlibyÅ›my w nieskoÅ„czonÄ… pÄ™tlÄ™
    number++;
    // sprawdzamy, czy liczba jest parzysta
    if (number % 2 == 0) {
      // wypisujemy tekst
      printf("Liczba %d jest parzysta!\n", number);
      // przerywamy aktualny przebieg pÄ™tli
      continue;
    }
    // wypisujemy tekst dla liczby nieparzystej
    printf("Liczba %d jest nieparzysta!\n", number);
  }
  return 0;
}
```

DziaÅ‚anie moÅ¼esz sprawdziÄ‡ na platformie [repl.it](https://replit.com/@tswistak/continue-c#main.c).

OczywiÅ›cie pisanie kodu w taki sposÃ³b nie ma wiÄ™kszego sensu (lepiej byÅ‚oby zrobiÄ‡ `if else`), ale pokazuje dziaÅ‚anie `continue` w praktyce. ZresztÄ… `continue` moÅ¼e byÄ‡ zwykle zastÄ…pione wÅ‚aÅ›nie przez `if else` i tak teÅ¼ czÄ™sto siÄ™ robi. Jak juÅ¼ stosuje siÄ™ `continue`, to po to, Å¼eby zmniejszyÄ‡ liczbÄ™ zagnieÅ¼dÅ¼eÅ„ lub uczyniÄ‡ kod czytelniejszym.

#### continue a pÄ™tla for

JeÅ›li chodzi o `continue`, ciekawa rzecz dzieje siÄ™ w przypadku pÄ™tli `for`, szczegÃ³lnie biorÄ…c pod uwagÄ™ jÄ™zyki takie jak C, gdzie jest to rozbudowana wersja konstrukcji `while`. Dlaczego? Zobaczmy poniÅ¼szy przykÅ‚ad:

```c
#include <stdio.h>

int main(void) {
  // poniÅ¼sza pÄ™tla siÄ™ wykona
  for (int i = 1; i <= 10; i++) {
    if (i % 2 == 0) {
      printf("Liczba %d jest parzysta!\n", i);
      continue;
    }
    printf("Liczba %d jest nieparzysta!\n", i);
  }
  // poniÅ¼sza pÄ™tla bÄ™dzie wykonywaÄ‡ siÄ™ nieskoÅ„czenie dla i == 2
  int i = 1;
  while (i <= 10) {
    if (i % 2 == 0) {
      printf("Liczba %d jest parzysta!\n", i);
      continue;
    }
    printf("Liczba %d jest nieparzysta!\n", i);
    i++;
  }
  return 0;
}
```

Kod moÅ¼na przetestowaÄ‡ na [repl.it](https://replit.com/@tswistak/continue-for-c#main.c). PÄ™tla `while` jest tam zakomentowana, aby mÃ³c bez problemu zobaczyÄ‡ dziaÅ‚anie `for`.

Teoretycznie pÄ™tla `for` u gÃ³ry i `while` na dole powinny wykonywaÄ‡ siÄ™ tak samo. Jednak pÄ™tla `while` bÄ™dzie nieskoÅ„czona, a `for` wykona siÄ™ w caÅ‚oÅ›ci. Dlaczego tak jest? OtÃ³Å¼ kompilator nie zamienia bezpoÅ›rednio pÄ™tli `for` na `while` tak, jak pokazaÅ‚em to wczeÅ›niej w artykule. Nawet jeÅ›li zrobimy `continue`, â€trzeci czÅ‚onâ€ pÄ™tli wykona siÄ™, aby nie zaburzyÄ‡ odliczania. To jest wÅ‚aÅ›nie ta drobna rÃ³Å¼nica, o ktÃ³rej wspomniaÅ‚em.

### break

`break` w przeciwieÅ„stwie do `continue` nie przenosi nas do kolejnego przebiegu pÄ™tli, tylko caÅ‚kowicie przerywa iteracjÄ™. Po przerobieniu przykÅ‚adu z poprzedniego akapitu, zmieniajÄ…c instrukcjÄ™, kod wykona siÄ™ tylko dwa razy:

```c
#include <stdio.h>

int main(void) {
  // ustawiamy poczÄ…tek licznika na 0
  int number = 0;
  // wykonujemy pÄ™tlÄ™, aÅ¼ osiÄ…gniemy liczbÄ™ 10
  while (number < 10) {
    // inkrementujemy liczbÄ™ na samym poczÄ…tku
    // gdybyÅ›my robili to na koÅ„cu, wpadlibyÅ›my w nieskoÅ„czonÄ… pÄ™tlÄ™
    number++;
    // sprawdzamy, czy liczba jest parzysta
    if (number % 2 == 0) {
      // wypisujemy tekst
      printf("Liczba %d jest parzysta!\n", number);
      // przerywamy pÄ™tlÄ™
      break;
    }
    // wypisujemy tekst dla liczby nieparzystej
    printf("Liczba %d jest nieparzysta!\n", number);
  }
  /*
    Rezultat po uruchomieniu:
      Liczba 1 jest nieparzysta!
      Liczba 2 jest parzysta!
  */
  return 0;
}
```

Jak zawsze moÅ¼esz to sprawdziÄ‡ na platformie [repl.it](https://replit.com/@tswistak/break-c#main.c).

JeÅ›li nie wykonujemy dalej po pÄ™tli Å¼adnego kodu, np. jesteÅ›my w funkcji i chcemy zwrÃ³ciÄ‡ rezultat, zamiast `break` moÅ¼emy uÅ¼yÄ‡ instrukcji zwrÃ³cenia wartoÅ›ci `return`. PÄ™tla rÃ³wnieÅ¼ zostanie przerwana jak w poniÅ¼szym przykÅ‚adzie.

```c
#include <stdio.h>

// funkcja zwrÃ³ci pierwszÄ… liczbÄ™ parzystÄ…
// kod ten nie ma totalnie Å¼adnego sensu, ale pokaÅ¼e dziaÅ‚anie przerywania pÄ™tli
int getFirstEvenNumber() {
  // licznik zaczynamy od zera, bez warunku przerwania, i inkrementujemy o 1
  for (int i = 1;; i++) {
    // sprawdzamy, czy liczba jest parzysta
    if (i % 2 == 0) {
      // zwracamy licznik, jeÅ›li jest parzysty
      return i;
    }
  }
}

int main(void) {
  // wypisujemy na ekranie wynik funkcji
  printf("Pierwsza liczba parzysta to: %d\n", getFirstEvenNumber());
  return 0;
}
```

Ten kod rÃ³wnieÅ¼ znajdziesz na [repl.it](https://replit.com/@tswistak/break-return-c#main.c).

#### goto jako break

OpisujÄ…c podstawowe pÄ™tle z uÅ¼yciem `goto`, wspomniaÅ‚em, Å¼e znalazÅ‚o ono w jÄ™zykach programowania inne zastosowanie niÅ¼ tworzenie pÄ™tli. Jednym z nich jest uÅ¼ycie skoku w celu zrobienia wielopoziomowego `break`. O co w tym chodzi?

Zacznijmy od tego, Å¼e pÄ™tle moÅ¼emy zagnieÅ¼dÅ¼aÄ‡. Jest to podstawowy sposÃ³b iteracji po tablicach wielowymiarowych, ale teÅ¼ dziaÅ‚a tak sporo algorytmÃ³w (np. <Link href="/post/sortowanie-cz-2-sortowanie-babelkowe">sortowanie bÄ…belkowe</Link>). Jednak zarÃ³wno `break`, jak i `continue` dziaÅ‚ajÄ… tylko na jeden poziom pÄ™tli. Nie wpÅ‚yniemy nimi na caÅ‚e wyraÅ¼enie, aczkolwiek aby ominÄ…Ä‡ to ograniczenie, moÅ¼emy z powodzeniem uÅ¼yÄ‡ etykiety i `goto`. Jak to wyglÄ…da oraz porÃ³wnanie dziaÅ‚ania moÅ¼esz zobaczyÄ‡, testujÄ…c poniÅ¼szy kod:

```c
#include <stdio.h>

int main(void) {
  // w pierwszej pÄ™tli odliczamy od 1 do 10
  for (int i = 1; i < 10; i++) {
    // w drugiej rÃ³wnieÅ¼
    for (int j = 1; j < 10; j++) {
      // wypisujemy obie liczby
      printf("Break: %d %d\n", i, j);
      // jeÅ›li ich iloraz jest parzysty, przerywamy
      if (i * j % 2 == 0) {
        break;
      }
    }
  }
  // powyÅ¼szy kod wykona siÄ™ 14 razy (przerywamy tylko wewnÄ™trznÄ… pÄ™tlÄ™),
  // a poniÅ¼szy tylko 2 razy (przerywamy caÅ‚oÅ›Ä‡)
  for (int i = 1; i < 10; i++) {
    for (int j = 1; j < 10; j++) {
      printf("Goto: %d %d\n", i, j);
      if (i * j % 2 == 0) {
        goto outside;
      }
    }
  }
  outside:
  return 0;
}
```

MoÅ¼esz sprawdziÄ‡ dziaÅ‚anie na wÅ‚asnÄ… rÄ™kÄ™ na [repl.it](https://replit.com/@tswistak/break-goto-c#main.c).

Dodam od razu, Å¼e przerwanie wykonania pÄ™tli z uÅ¼yciem `return` zadziaÅ‚a dokÅ‚adnie tak samo jak `goto`, czyli przerwie wszystkie poziomy zagnieÅ¼dÅ¼enia.

Niestety (albo stety), wspÃ³Å‚czesne jÄ™zyki nie zawsze posiadajÄ… `goto`. Jak wtedy moÅ¼emy zrobiÄ‡ takie wielopoziomowe wyjÅ›cie z pÄ™tli? OdpowiedÅº brzmi: to zaleÅ¼y od jÄ™zyka. Warto to sprawdziÄ‡ w dokumentacji skÅ‚adni. Dla przykÅ‚adu, w Javie moÅ¼emy etykietami nazwaÄ‡ pÄ™tle i zarÃ³wno przy `break`, jak i przy `continue` podaÄ‡ nazwÄ™ pÄ™tli, ktÃ³rÄ… chcemy przerwaÄ‡ lub kontynuowaÄ‡. WyglÄ…da to tak jak w poniÅ¼szym przykÅ‚adzie (dla lepszego zobrazowania rÃ³Å¼nic liczby bÄ™dziemy wypisywaÄ‡ dopiero po warunku):

```java
class Main {
  public static void main(String[] args) {
    firstLoop: for (int i = 1; i < 10; i++) {
      for (int j = 1; j < 10; j++) {
        if (i * j % 2 == 0) {
          // przerywamy obie pÄ™tle
          break firstLoop;
        }
        System.out.println("Break " + i + " " + j);
      }
    }
    // wypisane zostanie tylko 1 1

    secondLoop: for (int i = 1; i < 10; i++) {
      for (int j = 1; j < 10; j++) {
        if (i * j % 2 == 0) {
          // wywoÅ‚ujemy continue na pÄ™tli poziom wyÅ¼ej
          continue secondLoop;
        }
        System.out.println("Continue " + i + " " + j);
      }
    }
    // wypisane zostanÄ… 1 1, 3 1, 5 1, 7 1 i 9 1
  }
}
```

Ponownie, kod moÅ¼na przetestowaÄ‡ samodzielnie na [repl.it](https://replit.com/@tswistak/break-goto-java#Main.java).

### Czy powinniÅ›my je uÅ¼ywaÄ‡?

Bardzo popularnym pytaniem jest, czy uÅ¼ywanie `break` i `continue` jest dobrÄ… praktykÄ…. MoÅ¼emy znaleÅºÄ‡ w Internecie bardzo wiele wpisÃ³w na ten temat, a ja sam teÅ¼ pamiÄ™tam ze swojej nauki, Å¼e mÃ³wiono mi, aby ich nie uÅ¼ywaÄ‡. Jednak praktyka jest nieco bardziej zÅ‚oÅ¼ona.

Moje zdanie jest takie, Å¼e w czasie nauki powinniÅ›my nauczyÄ‡ siÄ™ tworzyÄ‡ pÄ™tle tak, aby stosowaÄ‡ poprawnie inne konstrukcje oferowane przez jÄ™zyk programowania. WÅ‚aÅ›nie szczegÃ³lnie na poczÄ…tku nauki jesteÅ›my zbyt podatni na â€uÅ‚atwieniaâ€ typu zrobienie nieskoÅ„czonej pÄ™tli i przerywanie jej z `break` gdzieÅ› w Å›rodku kodu. OczywiÅ›cie w praktyce czasem zdarza siÄ™ taka potrzeba, ale sÄ… to rzadkie przypadki.

Natomiast jak juÅ¼ siÄ™ nauczymy pisaÄ‡ Å‚adne warunki, to nastÄ™pnie w praktyce programistycznej powinniÅ›my zwracaÄ‡ uwagÄ™ na czystoÅ›Ä‡ kodu. Wtedy, w pewnych przypadkach, moÅ¼e siÄ™ okazaÄ‡, Å¼e uÅ¼ywanie `break` i `continue` bÄ™dzie w porzÄ…dku. Dla przykÅ‚adu, w poniÅ¼szym kodzie duÅ¼o bardziej wolaÅ‚bym pÄ™tlÄ™ uÅ¼ywajÄ…cÄ… `continue` niÅ¼ zagnieÅ¼dÅ¼one warunki. ChociaÅ¼ gdyby to byÅ‚ prawdziwy kod, moÅ¼na by siÄ™ pewnie zastanawiaÄ‡, czy nie daÅ‚oby siÄ™ go jakkolwiek uproÅ›ciÄ‡.

```javascript
while (warunek1()) {
    if (warunek2()) {
        wykonajAkcje1();
        if (warunek3()) {
            wykonajAkcje2();
            if (warunek4()) {
                wykonajAkcje3();
            }
        }
    }
}
// poniÅ¼szy kod zadziaÅ‚a identycznie:
while (warunek1()) {
    if (!warunek2()) continue;
    wykonajAkcje1();
    if (!warunek3()) continue;
    wykonajAkcje2();
    if (!warunek4()) continue;
    wykonajAkcje3();
}
```

## Rekurencja

MÃ³wiÄ…c o iteracjach, nie sposÃ³b nie wspomnieÄ‡ o rekurencjach. WÅ‚aÅ›nie to ta technika jest najbardziej podstawowym sposobem tworzenia pÄ™tli w matematyce czy funkcyjnych jÄ™zykach programowania (takich jak wspomniany wczeÅ›niej Haskell). W przytoczonym wczeÅ›niej liÅ›cie E. Dijkstry oprÃ³cz sprzeciwiania siÄ™ `goto` pisaÅ‚ teÅ¼, Å¼e `while` jest zbÄ™dne, gdy mamy rekurencjÄ™.

Jednak tematu rekurencji nie zamierzam poruszaÄ‡ w tym artykule, poniewaÅ¼ napisaÅ‚em juÅ¼ o niej dwa teksty:

- *<Link href="/post/rekurencja-co-to-jest">Rekurencja â€” co to jest?</Link>* â€” wprowadza w temat, tÅ‚umaczÄ…c, na czym polega rekurencja, i pokazujÄ…c jÄ… na prostych, rzeczywistych przykÅ‚adach. Do tego teÅ¼ omawia temat rekurencji ogonowej.
- *<Link href="/post/derekursywacja">Derekursywacja</Link>* â€” artykuÅ‚ omawiajÄ…cy, jak moÅ¼emy pozbywaÄ‡ siÄ™ rekurencji. OprÃ³cz konkretnych technik wspomina takÅ¼e, dlaczego warto tak robiÄ‡, pokazujÄ…c rÃ³Å¼nice w wydajnoÅ›ci miÄ™dzy tymi samymi algorytmami w wersjach rekurencyjnych i nierekurencyjnych.

Zapraszam do ich lektury w pÃ³Åºniejszym czasie ğŸ™‚.

## Iteratory

KolejnÄ… rzeczÄ…, ktÃ³rÄ… warto poruszyÄ‡, mÃ³wiÄ…c o iteracjach, sÄ… konstrukcje zwane iteratorami (czasami teÅ¼ enumeratorami). Do tej pory wszystkie robione przez nas iteracje wykonywaÅ‚y siÄ™ okreÅ›lonÄ… liczbÄ™ razy (`for`) albo tak dÅ‚ugo, jak pewien warunek jest speÅ‚niony (`while`). Jednak w wiÄ™kszoÅ›ci przypadkÃ³w iterujemy po elementach jakichÅ› struktur danych (kolekcji).

OczywiÅ›cie moÅ¼emy korzystaÄ‡ z powyÅ¼ej pokazanych pÄ™tli do iteracji po strukturach danych. W przypadku najprostszych, jak tablice czy wektory, kaÅ¼dy element ma okreÅ›lonÄ… pozycjÄ™ od 0 wzwyÅ¼, stÄ…d tablice czÄ™sto przechodzi siÄ™ w nastÄ™pujÄ…cy sposÃ³b (kod tym razem w JavaScript):

```javascript
// definiujemy tablicÄ™ z elementami
const array = ['element 0', 'abc', '1', 'test'];
// tworzymy pÄ™tlÄ™ iterujÄ…cÄ… od 0 do dÅ‚ugoÅ›ci tablicy
// pierwszy element ma indeks 0, stÄ…d taki zapis
for (let i = 0; i < array.length; i++) {
  // wypisujemy w konsoli i-ty elment tablicy
  console.log(`${i}: ${array[i]}`);
}
```

Kod jak zawsze moÅ¼esz sprawdziÄ‡ na [repl.it](https://replit.com/@tswistak/for-array-js#index.js).

Jest to jak najbardziej poprawny sposÃ³b iteracji i caÅ‚kiem prawdopodobne, Å¼e uczÄ…c siÄ™ programowania od podstaw, niezaleÅ¼nie od jÄ™zyka (moÅ¼e z wyjÄ…tkiem Pythona lub funkcyjnych), wÅ‚aÅ›nie z nim jesteÅ› zapoznany(-a). Tylko jak mamy iterowaÄ‡ po innych strukturach: sÅ‚ownikach, grafach, listach wiÄ…zanych? OczywiÅ›cie w tym celu bylibyÅ›my w stanie napisaÄ‡ odpowiednie pÄ™tle, jednak wÃ³wczas musimy mieÄ‡ wiedzÄ™, z jakim dokÅ‚adnie typem danych mamy do czynienia. Niestety, to nie zawsze jest takie oczywiste. Dlatego teÅ¼ powstaÅ‚ uniwersalny sposÃ³b iteracji po dowolnych strukturach danych, niezaleÅ¼ny od ich implementacji â€” iteratory.

### Konstrukcja iteratora

Iteratory w zaleÅ¼noÅ›ci od jÄ™zyka programowania sÄ… rÃ³Å¼nie implementowane, ale podstawowe idee sÄ… takie same. NajczÄ™Å›ciej sÄ… to obiekty bÄ™dÄ…ce czÄ™Å›ciÄ… struktury danych i majÄ…ce moÅ¼liwoÅ›Ä‡:

- PrzejÅ›cia do nastÄ™pnego elementu (przesuniÄ™cie wskaÅºnika) bÄ…dÅº sprawdzenie, czy taki istnieje.
- Pobrania elementu z kolekcji.

Mimo Å¼e w trakcie nauki programowania moÅ¼esz mieÄ‡ pokazywane implementowanie takich konstrukcji od zera (np. tak uczy ksiÄ…Å¼ka *Od Podstaw Algorytmy* S. Harrisa i J. Rossa), to w praktyce nigdy tego nie robimy. KaÅ¼dy jÄ™zyk programowania posiada wÅ‚asny standardowy sposÃ³b pisania iteratorÃ³w i jako przykÅ‚adowe moÅ¼na by wymieniÄ‡:

- W JavaScript iterator to obiekt, ktÃ³ry zawiera jedynie funkcjÄ™ `next()`. Zwraca ona obiekt z dwoma polami: `done` (czy dotarliÅ›my do koÅ„ca sekwencji) i `value` (aktualna wartoÅ›Ä‡). Jest zapisany w obiekcie reprezentujÄ…cym strukturÄ™ danych pod polem `[Symbol.iterator]`.
- W C# iteratory muszÄ… implementowaÄ‡ interfejs `IEnumerator<T>`. PosiadajÄ… wÃ³wczas: `MoveNext()` (przesuwa wskaÅºnik na nastÄ™pny element), `Reset()` (cofa iterator na poczÄ…tek), `Current` (aktualna wartoÅ›Ä‡). Natomiast sama struktura danych musi implementowaÄ‡ interfejs `IEnumerable<T>`, ktÃ³ry wymusza istnienie metody `GetEnumerator()` zwracajÄ…cej iterator.
- W Java iteratory implementujÄ… interfejs `Iterator<E>`. Wymusza to posiadanie dwÃ³ch metod: `hasNext()` (sprawdza, czy istnieje kolejny element) i `next()` (pobiera nastÄ™pny element i przesuwa wskaÅºnik iteracji na niego). Tutaj struktury danych muszÄ… implementowaÄ‡ interfejs `Iterable<T>`, ktÃ³ry wymaga napisania metody `iterator()` zwracajÄ…cej iterator.

WymieniÅ‚em te trzy przykÅ‚ady, bo iteratory sÄ… zwykle implementowane analogicznie:
- Mamy jednÄ… funkcjÄ™ obsÅ‚ugujÄ…cÄ… caÅ‚oÅ›Ä‡, np. JavaScript, Python,
- Mamy przesuwanie wskaÅºnika i pobieranie aktualnej wartoÅ›ci, np. C#, C++ (biblioteka standardowa),
- Albo sprawdzenie, czy nastÄ™pny element istnieje, i pobieranie wartoÅ›ci nastÄ™pnego elementu wraz z przesuniÄ™ciem wskaÅºnika, np. Java, Go.

### Korzystanie z iteratorÃ³w

W zasadzie z powyÅ¼szych opisÃ³w moÅ¼na wywnioskowaÄ‡, jak iteratorÃ³w siÄ™ uÅ¼ywa. Mimo to zobaczmy w kodzie, w jaki sposÃ³b iteruje siÄ™ za ich pomocÄ… w trzech opisanych wyÅ¼ej jÄ™zykach.

JavaScript (kod na [repl.it](https://replit.com/@tswistak/iterator-js#index.js)):

```javascript
// deklarujemy listÄ™ tablicowÄ… z trzema elementami
const list = ['1', '2-gi element', '3-ci'];
// wyciÄ…gamy iterator
const it = list[Symbol.iterator]();
// zmienna przechowujÄ…ca aktualnÄ… wartoÅ›Ä‡
let current = it.next();
// iterujemy tak dÅ‚ugo, dopÃ³ki nie doszliÅ›my do koÅ„ca
while (!current.done) {
  // wypisujemy wartoÅ›Ä‡
  console.log(current.value);
  // pobieramy kolejnÄ… wartoÅ›Ä‡
  current = it.next();
}
```

C# (peÅ‚en kod na [repl.it](https://replit.com/@tswistak/iterator-csharp#main.cs)):

```csharp
// deklarujemy listÄ™ tablicowÄ… z trzema elementami
var list = new List<string>() { "1", "2-gi element", "3-ci" };
// wyciÄ…gamy iterator
var it = list.GetEnumerator();
// iterujemy tak dÅ‚ugo, jak moÅ¼emy przesunÄ…Ä‡ nastÄ™pny element
while (it.MoveNext())
{
    // wypisujemy aktualnÄ… wartoÅ›Ä‡
    Console.WriteLine(it.Current);
}
```

Java (peÅ‚en kod na [repl.it](https://replit.com/@tswistak/iterator-java#Main.java)):

```java
// deklarujemy listÄ™ tablicowÄ… z trzema elementami
var list = new ArrayList<String>(List.of("1", "2-gi element", "3-ci"));
// wyciÄ…gamy iterator
var it = list.iterator();
// iterujemy tak dÅ‚ugo, jak istnieje nastÄ™pny element
while (it.hasNext()) {
  // wypisujemy wartoÅ›Ä‡ nastÄ™pnego elementu
  System.out.println(it.next());
}
```

Dodatkowo zobacz, jak wyglÄ…da korzystanie z iteratorÃ³w, ktÃ³re znajdziemy w bibliotece standardowej C++. Zasada dziaÅ‚ania jest analogiczna do tego, co znajdziemy w C#, ale samo uÅ¼ycie jest zupeÅ‚nie inne (peÅ‚en kod na [repl.it](https://replit.com/@tswistak/iterator-cpp#main.cpp)):

```cpp
// deklarujemy listÄ™ tablicowÄ… z trzema elementami
auto list = vector<string>{"1", "2-gi element", "3-ci"};
// iterujemy od poczÄ…tku do koÅ„ca, przeskakujÄ…c co jeden element
// begin() pobiera iterator
// end() zawiera koÅ„cowÄ… pozycjÄ™
// it++ przesuwa na nastÄ™pny element
for (auto it = list.begin(); it < list.end(); it++) {
  // wypisujemy aktualnÄ… wartoÅ›Ä‡
  cout << *it << "\n";
}
```

### for each

JeÅ›li kiedykolwiek pisaÅ‚eÅ›(-aÅ›) w tych jÄ™zykach, to moÅ¼esz siÄ™ zastanawiaÄ‡, od kiedy w ten sposÃ³b korzysta siÄ™ z iteratorÃ³w? To znaczy, tak, moÅ¼na w ten sposÃ³b, tylko w praktyce robi siÄ™ to rzadko. DuÅ¼o popularniejsze sÄ… pÄ™tle `for each` wykorzystujÄ…ce pod spodem iteratory. W zaleÅ¼noÅ›ci od jÄ™zyka nazwane sÄ… inaczej. Dla przykÅ‚adu: `for...of` (np. JavaScript, Ada), `foreach` (np. C#, PHP), `for` z dwukropkiem (np. Java, C++), `for...in` (np. Python, Pascal). Skoro wymieniÅ‚em cztery rodzaje skÅ‚adni, to zobaczmy dla czterech rÃ³Å¼nych jÄ™zykÃ³w, jak iterowalibyÅ›my w kaÅ¼dym z nich po <Link href="/post/tablice-i-listy-tablicowe">liÅ›cie tablicowej</Link>.

JavaScript (kod na [repl.it](https://replit.com/@tswistak/foreach-js#index.js)):

```javascript
// deklarujemy listÄ™ tablicowÄ… z trzema elementami
const list = ['1', '2-gi element', '3-ci'];
// iterujemy po elementach listy
for (const element of list) {
  // wypisujemy aktualny element
  console.log(element);
}
```

C# (peÅ‚en kod na [repl.it](https://replit.com/@tswistak/foreach-csharp#main.cs)):

```csharp
// deklarujemy listÄ™ tablicowÄ… z trzema elementami
var list = new List<string>() { "1", "2-gi element", "3-ci" };
// iterujemy po elementach listy
foreach (var element in list)
{
    // wypisujemy aktualny element
    Console.WriteLine(element);
}
```

Java (peÅ‚en kod na [repl.it](https://replit.com/@tswistak/foreach-java#Main.java)):

```java
// deklarujemy listÄ™ tablicowÄ… z trzema elementami
var list = new ArrayList<String>(List.of("1", "2-gi element", "3-ci"));
// iterujemy po elementach listy
for (var element : list) {
  // wypisujemy aktualny element
  System.out.println(element);
}
```

Python (kod na [repl.it](https://replit.com/@tswistak/foreach-python#main.py)):

```python
# deklarujemy listÄ™ tablicowÄ… z trzema elementami
list = ["1", "2-gi element", "3-ci"]
# iterujemy po elementach listy
for element in list:
  # wypisujemy aktualny element
  print(element)
```

W przypadku Pythona warto dodaÄ‡, Å¼e nie ma w nim tradycyjnej pÄ™tli `for`, a jedynie `for each`.

Jak widaÄ‡ na powyÅ¼szych przykÅ‚adach, sprowadzajÄ… siÄ™ one do bardzo prostego stwierdzenia w pseudokodzie:

```
dla [element] z [kolekcja] {
  wykonajAkcjÄ™();
}
```

Jest bardzo prawdopodobne, Å¼e wÅ‚aÅ›nie z tym sposobem spotkasz siÄ™ w projektach czÄ™Å›ciej niÅ¼ z `while` czy zwykÅ‚ym `for`. NajczÄ™Å›ciej iterujemy wÅ‚aÅ›nie po kolekcjach, a stosowanie `for each` jest zwykle najwygodniejsze. Chyba Å¼e stosujemy jeszcze inne sposoby iteracji, ale o nich pÃ³Åºniej...

### Generatory

Najpierw warto jeszcze wspomnieÄ‡ o tym, jak w przypadku wÅ‚asnych kolekcji tworzymy iteratory. OczywiÅ›cie moÅ¼emy po prostu zaimplementowaÄ‡ odpowiednie interfejsy i tyle, jednak czÄ™sto w tym celu korzysta siÄ™ z generatorÃ³w.

Generatory to funkcje tworzÄ…ce ciÄ…g wartoÅ›ci i zwracajÄ…ce iterator iterujÄ…cy po nich. CiÄ…g moÅ¼e byÄ‡ skoÅ„czony, nieskoÅ„czony, bazowaÄ‡ na jakiejÅ› strukturze danych lub generowaÄ‡ wartoÅ›ci na bieÅ¼Ä…co. Nie ma tu Å¼adnych ograniczeÅ„.

W kodzie generatory najÅ‚atwiej rozpoznaÄ‡ po bardzo charakterystycznym sÅ‚owie kluczowym `yield` (z ang. przynosiÄ‡), ktÃ³re w wiÄ™kszoÅ›ci jÄ™zykÃ³w oferujÄ…cych generatory sÅ‚uÅ¼y do zwrÃ³cenia wartoÅ›ci (zamiast tradycyjnego `return`). DziaÅ‚anie zwykle wyglÄ…da tak, Å¼e funkcja generator dziaÅ‚a jak zwykÅ‚a funkcja zwracacajÄ…ca iterator. Gdy wywoÅ‚amy przeniesienie na nastÄ™pny element, funkcja wykonuje siÄ™ aÅ¼ do napotkania `yield`, ktÃ³re daje wartoÅ›Ä‡ zwracanÄ… przez iterator. W tym teÅ¼ momencie dalsze wykonanie funkcji jest wstrzymane. Gdy znowu wywoÅ‚amy w iteratorze pobranie nastÄ™pnego elementu, funkcja jest dalej wykonywana, aÅ¼ do napotkania `yield` i tak dalej, dopÃ³ki funkcja siÄ™ nie skoÅ„czy.

Aby nie rozbudowywaÄ‡ niepotrzebnie artykuÅ‚u, nie bÄ™dÄ™ pokazywaÄ‡, jak generatory wyglÄ…dajÄ… w rÃ³Å¼nych jÄ™zykach, bo wyglÄ…dajÄ… zwykle tak samo. Dlatego zaprezentujÄ™ je jedynie w JavaScript. Zacznijmy od generatora, ktÃ³ry zwraca dokÅ‚adnie te same trzy ciÄ…gi tekstowe, co wczeÅ›niej pokazane listy tablicowe:

```javascript
// tworzymy generator zwracajÄ…cy trzy ciÄ…gi znakÃ³w
function* generator() {
  yield '1';
  yield '2-gi element';
  yield '3-ci';
}

// iterujemy po elementach zwracanych przez generator
for (const element of generator()) {
  // wypisujemy aktualny element
  console.log(element);
}
```

Kod, jak zawsze, jest dostÄ™pny na [repl.it](https://replit.com/@tswistak/generator-simple-js#index.js). Dla porÃ³wnania [tutaj znajdziesz ten sam generator, ale napisany w C#](https://replit.com/@tswistak/generator-simple-csharp#main.cs).

Å»eby pokazaÄ‡, Å¼e za ich pomocÄ… moÅ¼emy teÅ¼ robiÄ‡ nieskoÅ„czone iteracje, zamieszczam iterator zwracajÄ…cy kolejne elementy ciÄ…gu Fibonacciego:

```javascript
function* fibonacci() {
  // "n" oznacza BigInt, czyli liczby caÅ‚kowite bez ograniczenia zakresu
  let a = 0n;
  yield a;
  let b = 1n;
  yield b;
  // iterujemy nieskoÅ„czenie, ale dziÄ™ki "yield" nie zawiesimy programu
  while (true) {
    let tmp = a;
    a = b;
    b = tmp + b;
    yield b;
  }
}
```

Kod wraz z wyciÄ…gniÄ™ciem z generatora stu pierwszych wartoÅ›ci znajdziesz na [repl.it](https://replit.com/@tswistak/generator-fibo-js#index.js). Dla ciekawych wrzucam teÅ¼ [pod tym linkiem wersjÄ™ w C#](https://replit.com/@tswistak/generator-fibo-csharp#main.cs).

SwojÄ… drogÄ…, na blogu czÄ™sto wykorzystywaÅ‚em generatory do stworzenia wizualizacji algorytmÃ³w â€” dziÄ™ki ich mechanizmowi wstrzymywania egzekucji funkcji mogÅ‚em tworzyÄ‡ wizualizacje, ktÃ³re mogliÅ›my wykonywaÄ‡ krok po kroku, animowaÄ‡ lub od razu obejrzeÄ‡ koÅ„cowy rezultat. OpisaÅ‚em to kiedyÅ› we wpisie na [OhMyDev dostÄ™pnym pod tym linkiem](https://github.com/tswistak/tech-articles-copy/blob/main/wizualizacja-algorytmow/article.md).

## Inne sposoby iteracji

PoznaliÅ›my juÅ¼ sporo konstrukcji skÅ‚adniowych jÄ™zykÃ³w programowania, dziÄ™ki ktÃ³rym moÅ¼emy iterowaÄ‡. Jednak to oczywiÅ›cie nie wyczerpuje tematu. SÄ… jeszcze inne sposoby na wykonywanie iteracji i teraz opiszÄ™ krÃ³tko dwa, ktÃ³re sÄ… czÄ™sto spotykane i Å›ciÅ›le powiÄ…zane z przechodzeniem po strukturach danych.

### Funkcje iterujÄ…ce

Pierwszym sposobem jest iteracja po kolekcjach za pomocÄ… wyspecjalizowanych do tego funkcji zwracajÄ…cych wynik przejÅ›cia po kolekcji. CzÄ™sto sÄ… to funkcje wyÅ¼szego rzÄ™du (funkcjonaÅ‚y) w jÄ™zykach funkcyjnych, ale znajdziemy je takÅ¼e poza nimi. Zwykle sÄ… czÄ™Å›ciÄ… struktur danych i znajdziemy poÅ›rÃ³d nich takie operacje, jak:

- Aplikacja zbiorowa â€” jest to transformacja danych zawartych w strukturze z wykorzystaniem zadanej funkcji. W C# znajdziemy jÄ… pod funkcjÄ… `Select()`, a w JavaScript pod `map()`. Wynikiem jest kolekcja zawierajÄ…ca tyle samo elementÃ³w, ale wszystkie sÄ… przeksztaÅ‚cone.
- Filtrowanie â€” zwraca jedynie te dane z kolekcji, ktÃ³re speÅ‚niajÄ… zadany predykat. W C# znajdziemy je pod funkcjÄ… `Where()`, a w JavaScript pod `filter()`. Wynikiem jest kolekcja z elementami speÅ‚niajÄ…cymi warunek (bez przeksztaÅ‚cenia).
- Sprawdzenie, czy elementy kolekcji speÅ‚niajÄ… warunek:
    - Czy wszystkie speÅ‚niajÄ… predykat (odpowiednik matematycznego $$\forall$$). W C# znajdziemy je pod funkcjÄ… `All()`, a w JavaScript pod `every()`. Wynikiem jest wartoÅ›Ä‡ logiczna.
    - Czy przynajmniej jeden speÅ‚nia predykat (odpowiednik matematycznego $$\exists$$). W C# znajdziemy je pod funkcjÄ… `Any()`, a w JavaScript pod `some()`. Wynikiem rÃ³wnieÅ¼ jest wartoÅ›Ä‡ logiczna
- Fold (redukcja, agregacja) â€” tutaj takÅ¼e aplikujemy funkcje na dane, przy czym zwrÃ³cona zostaje pojedyncza wartoÅ›Ä‡. Funkcja zawsze otrzymuje aktualnie obliczonÄ… wartoÅ›Ä‡ (akumulator) oraz element kolekcji. W C# znajdziemy go pod funkcjÄ… `Aggregate()`, a w JavaScript pod `reduce()`.
- MoÅ¼na teÅ¼ spotkaÄ‡ operacjÄ™ iteracji, ktÃ³ra nic nie zwraca, bÄ™dÄ…ca funkcyjnym odpowiednikiem `for each`. W C# znajdziemy jÄ… pod funkcjÄ… `ForEach()`, a w JavaScript pod `forEach()`. W przypadku C# warto zaznaczyÄ‡, Å¼e o ile wszystkie wczeÅ›niej wymienione byÅ‚y czÄ™Å›ciÄ… interfejsu Enumerable rozszerzonego przez `System.Linq`, o tyle `ForEach` jest metodÄ… listy tablicowej.

Prosty kod w JavaScript, ktÃ³ry wykorzystuje do iteracji powyÅ¼ej pokazane funkcje, wyglÄ…da nastÄ™pujÄ…co:

```javascript
const list = [1, 2, 3, 4, 5];

// aplikacja zbiorowa podnoszÄ…ca liczby do kwadratu
const squares = list.map(value => value * value);
console.log(squares); // [1, 4, 9, 16, 25]

// filtrowanie - zostawiamy tylko liczby parzyste
// zwrÃ³Ä‡ uwagÄ™, Å¼e list nie zostaÅ‚o zmienione!
const even = list.filter(value => value % 2 === 0);
console.log(even); // [ 2, 4 ]

// sprawdzenie, czy wszystkie speÅ‚niajÄ… predykat
// ponownie sprawdzimy parzystoÅ›Ä‡
const allEven = list.every(value => value % 2 === 0);
console.log(allEven); // false

// sprawdzenie, czy cokolwiek speÅ‚nia predykat
const anyEven = list.some(value => value % 2 === 0);
console.log(anyEven); // true

// fold zwracajÄ…cy iloczyn elementÃ³w listy
// poczÄ…tkowÄ… wartoÅ›Ä‡ akumulatora ustawiamy na 1
const product = list.reduce((accumulator, value) => accumulator * value, 1);
console.log(product); // 120

// iteracja, w ramach ktÃ³rej wypiszemy wszystkie elementy
const all = list.forEach(value => console.log(value));
// sprawdzamy, czy faktycznie nic nie zostaÅ‚o zwrÃ³cone
console.log(all); // undefined
```

Znajdziesz go takÅ¼e na [repl.it](https://replit.com/@tswistak/functional-js#index.js). Odpowiednik w C# rÃ³wnieÅ¼ znajdziesz na [repl.it](https://replit.com/@tswistak/functional-csharp#main.cs).

JeÅ›li powyÅ¼szy przykÅ‚ad nie pokazaÅ‚ najlepiej, jakie sÄ… definicje funkcji iterujÄ…cych i co one wykonujÄ…, zobacz, jak moglibyÅ›my je zdefiniowaÄ‡, wykorzystujÄ…c pÄ™tle typu `for each`. Tym razem jedynie zaprezentujÄ™ pseudokod i implementacjÄ™ w JavaScript.

#### Aplikacja zbiorowa

Aplikacja zbiorowa odpowiada poniÅ¼szej operacji zaprezentowanej w pseudokodzie:

```
wynik = Â« pusta lista tablicowa Â»
dla kaÅ¼dego elementu z kolekcji:
  wynik.dodaj(akcja(element))
zwrÃ³Ä‡ wynik
```

W JavaScript wyglÄ…da to nastÄ™pujÄ…co:

```javascript
function map(list, action) {
  // tworzymy pustÄ… listÄ™ tablicowÄ…
  const result = [];
  // iterujemy po kolejnych elementach listy
  for (const element of list) {
    // dodajemy do wyniku rezultat akcji
    result.push(action(element));
  }
  // zwracamy przetworzone elementy
  return result;
}
```

Kod wraz z porÃ³wnaniem do oryginalnej funkcji znajdziesz na [repl.it](https://replit.com/@tswistak/map-js#index.js).

#### Filtrowanie

Filtrowanie moglibyÅ›my opisaÄ‡ w pseudokodzie nastÄ™pujÄ…co:

```
wynik = Â« pusta lista tablicowa Â»
dla kaÅ¼dego elementu z kolekcji:
  jeÅ›li predykat(element) jest prawdÄ…:
    wynik.dodaj(element)
zwrÃ³Ä‡ wynik
```

W JavaScript zapisalibyÅ›my to tak:

```javascript
function filter(list, predicate) {
  // tworzymy pustÄ… listÄ™ tablicowÄ…
  const result = [];
  // iterujemy po kolejnych elementach listy
  for (const element of list) {
    // sprawdzamy, czy predykat zwraca prawdÄ™
    if (predicate(element)) {
      // jeÅ›li tak, dodajemy element do wyniku
      result.push(element)
    }
  }
  // zwracamy elementy speÅ‚niajÄ…ce predykat
  return result;
}
```

Kod wraz z porÃ³wnaniem do oryginalnej funkcji znajdziesz na [repl.it](https://replit.com/@tswistak/filter-js#index.js).

#### Sprawdzenie, czy elementy speÅ‚niajÄ… warunek

W tym przypadku implementacja bardzo przypomina filtrowanie, tylko zamiast zwracaÄ‡ listÄ™, zwracamy prawdÄ™ lub faÅ‚sz. Oba warianty funkcji rÃ³Å¼niÄ… siÄ™ tak naprawdÄ™ jedynie tym, kiedy zwracamy prawdÄ™, a kiedy faÅ‚sz.

Pseudokod dla wszystkich speÅ‚niajÄ…cych warunek:

```
dla kaÅ¼dego elementu z kolekcji:
  jeÅ›li predykat(element) jest faÅ‚szem:
    zwrÃ³Ä‡ faÅ‚sz
zwrÃ³Ä‡ prawda
```

A dla ktÃ³regokolwiek speÅ‚niajÄ…cego warunek:

```
dla kaÅ¼dego elementu z kolekcji:
  jeÅ›li predykat(element) jest prawdÄ…:
    zwrÃ³Ä‡ prawda
zwrÃ³Ä‡ faÅ‚sz
```

Obie funkcje w JavaScript moÅ¼na by zaimplementowaÄ‡ nastÄ™pujÄ…co:

```javascript
function every(list, predicate) {
  // iterujemy po kolejnych elementach listy
  for (const element of list) {
    // sprawdzamy, czy predykat zwraca faÅ‚sz
    if (!predicate(element)) {
      // jeÅ›li tak, zwracamy faÅ‚sz
      return false;
    }
  }
  // wszystkie elementy speÅ‚niajÄ… predykat
  return true;
}

function some(list, predicate) {
  // iterujemy po kolejnych elementach listy
  for (const element of list) {
    // sprawdzamy, czy predykat zwraca prawdÄ™
    if (predicate(element)) {
      // jeÅ›li tak, zwracamy prawdÄ™
      return true;
    }
  }
  // Å¼aden element nie speÅ‚nia predykatu
  return false;
}
```

Kod wraz z porÃ³wnaniem obu do oryginalnych wersji znajdziesz na [repl.it](https://replit.com/@tswistak/every-some-js#index.js).

#### Fold

Na koniec zobaczmy, jak w pseudokodzie zdefiniowalibyÅ›my operacjÄ™ fold. Dla utrzymania konwencji nazewnictwa, zamiast zmiennej `wynik` uÅ¼ywam `akumulator`, aczkolwiek znaczenie jest dokÅ‚adnie takie samo.

```
akumulator = Â« poczÄ…tkowa wartoÅ›Ä‡ akumulatora Â»
dla kaÅ¼dego elementu z kolekcji:
  akumulator = akcja(akumulator, element)
zwrÃ³Ä‡ akumulator
```

W JavaScript zapisalibyÅ›my to nastÄ™pujÄ…co:

```javascript
function reduce(list, initialValue, action) {
  // inicjujemy akumulator odgÃ³rnie zadanÄ… wartoÅ›ciÄ…
  let acc = initialValue;
  // iterujemy po kolejnych elementach listy
  for (const element of list) {
    // akumulatorowi przypisujemy wartoÅ›Ä‡ zwrÃ³conÄ… przez akcjÄ™
    acc = action(acc, element)
  }
  // zwracamy wartoÅ›Ä‡ akumulatora
  return acc;
}
```

Kod wraz z porÃ³wnaniem do oryginalnej implementacji `reduce` znajdziesz na [repl.it](https://replit.com/@tswistak/reduce-js#index.js).

### JÄ™zyki zapytaÅ„

OmÃ³wiliÅ›my wiele funkcji iterujÄ…cych, ale iterowanie po kolekcjach moÅ¼emy wykonaÄ‡ na jeszcze zupeÅ‚nie inny sposÃ³b, ktÃ³ry nawet nie kaÅ¼dy moÅ¼e kojarzyÄ‡ z iteracjÄ… â€” za pomocÄ… jÄ™zykÃ³w zapytaÅ„.

Za pomocÄ… jÄ™zykÃ³w zapytaÅ„ jesteÅ›my w stanie okreÅ›liÄ‡, ktÃ³re elementy ze struktury danych chcemy wyciÄ…gnÄ…Ä‡ (filtrowanie), w jakiej formie majÄ… zostaÄ‡ one zwrÃ³cone (aplikacja zbiorowa, chociaÅ¼ tutaj raczej mÃ³wimy o projekcji) i ewentualnie jak majÄ… zostaÄ‡ zagregowane. NajczÄ™Å›ciej sÄ… kojarzone z bazami danych, stÄ…d moÅ¼esz siÄ™ zastanawiaÄ‡, o czym ja w ogÃ³le piszÄ™. Po pierwsze, bazÄ™ danych moÅ¼emy traktowaÄ‡ jako rozbudowanÄ… kolekcjÄ™ przechowujÄ…cÄ… dane (najczÄ™Å›ciej) na dysku. Po drugie, jÄ™zyki zapytaÅ„ sÄ… spotykane nie tylko w bazach danych.

JÄ™zykÃ³w zapytaÅ„ mamy bardzo wiele, kaÅ¼dy do innych zastosowaÅ„. WymieniajÄ…c przykÅ‚adowe, z ktÃ³rymi sam miaÅ‚em kiedykolwiek do czynienia w swojej karierze programistycznej:

- SQL â€” dla wielu jest toÅ¼samy z pojÄ™ciem *jÄ™zyk zapytaÅ„*. Stanowi standardowy sposÃ³b obsÅ‚ugi relacyjnych baz danych.
- Cypher, Gremlin â€” odpowiedniki SQL dla grafowych baz danych. SÄ… teÅ¼ inne, aczkolwiek z tymi spotkaÅ‚em siÄ™ najczÄ™Å›ciej.
- GraphQL â€” jÄ™zyk o strukturze zbliÅ¼onej do JSON-a umoÅ¼liwiajÄ…cy pobieranie danych z serwisÃ³w webowych wspierajÄ…cych go. Mocno promowany przez Facebooka (przez nich zresztÄ… zostaÅ‚ stworzony) i od kilku lat jest czymÅ›, co *kaÅ¼dy chce mieÄ‡* w kontekÅ›cie wytwarzania aplikacji Webowych.
- XPath, XQuery â€” umoÅ¼liwiajÄ… nawigacjÄ™ po dokumentach zapisanych w XML. Pierwszy z nich opisaÅ‚em krÃ³tko w artykule *<Link href="/post/tekstowy-zapis-danych-cyfrowych">Tekstowy zapis danych cyfrowych</Link>*.
- LINQ â€” jÄ™zyk zapytaÅ„ wbudowany w platformÄ™ .NET umoÅ¼liwiajÄ…cy wykonywanie zapytaÅ„ na wbudowanych kolekcjach. Bardzo przypomina SQL.

Warto dodaÄ‡, Å¼e tekst wpisywany do wyszukiwarek internetowych teÅ¼ jest jÄ™zykiem zapytaÅ„ i nawet [posiada specjalne operatory](https://support.google.com/websearch/answer/2466433?hl=pl&ref_topic=3081620). Ostatecznie tu rÃ³wnieÅ¼ dochodzi do iteracji â€” na podstawie tego, co piszemy, sÄ… wyciÄ…gane elementy z gigantycznej kolekcji i prezentowane jako wyniki wyszukiwania. W zasadzie to pokazuje, na czym polega jÄ™zyk zapytaÅ„:

- Opisujemy, co chcemy otrzymaÄ‡ z kolekcji, w bardziej lub mniej ustrukturyzowany sposÃ³b (zaleÅ¼nie od jÄ™zyka).
- Serwer, jÄ™zyk programowania czy cokolwiek innego przetwarza zapytanie do ustrukturyzowanej postaci, np. do postaci drzewa AST (abstract syntax tree, z ang. abstrakcyjne drzewo skÅ‚adniowe).
- Na tej podstawie jest opracowywany plan, jakie operacje naleÅ¼y wykonaÄ‡ podczas iteracji i w jakiej kolejnoÅ›ci.
- Zaplanowane operacje sÄ… wykonywane i uÅ¼ytkownikowi jest zwracany rezultat.

#### LINQ

Å»eby nie zostawiÄ‡ CiÄ™ bez przykÅ‚adu, jak takie jÄ™zyki wyglÄ…dajÄ…, poniÅ¼ej moÅ¼esz zobaczyÄ‡ przykÅ‚adowe uÅ¼ycie LINQ (w C#) wraz z odpowiednikiem w postaci funkcji iterujÄ…cych:

```csharp
var evenSquared = from value in list // wyciÄ…gamy wartoÅ›ci z listy
                  where value % 2 == 0 // interesujÄ… nas tylko parzyste
                  select value * value; // zwracamy podniesione do kwadratu

// ta sama operacja, ale zapisana funkcjami iterujÄ…cymi
var evenSquared2 = list
  .Where(value => value % 2 == 0)
  .Select(value => value * value);
```

CaÅ‚oÅ›Ä‡ kodu znajdziesz na [repl.it](https://replit.com/@tswistak/linq#main.cs).

Warto nadmieniÄ‡, Å¼e w przypadku przedstawionego wyÅ¼ej LINQ w C# kompilator przeksztaÅ‚ca powyÅ¼szÄ… formÄ™ na funkcje (pokazane niÅ¼ej). Wynika to z tego, Å¼e C# nie jest kompilowany do kodu maszynowego, tylko poÅ›redniego jÄ™zyka CIL (Common Intermediate Language, z ang. wspÃ³lny jÄ™zyk poÅ›redni). Jest to .NET-owy odpowiednik asemblera interpretowany nastÄ™pnie przez CLR (Common Language Runtime) bÄ™dÄ…cego czÄ™Å›ciÄ… .NET Framework.

PoniÅ¼ej moÅ¼esz zobaczyÄ‡ wynik dekompilacji (przywrÃ³cenia oryginalnego kodu ze skompilowanego) powyÅ¼ej pokazanego kodu:

```csharp
IEnumerable<int> values = Enumerable.Select(Enumerable.Where(source, <>c.<>9__0_0 ?? (<>c.<>9__0_0 = new Func<int, bool>(<>c.<>9.<Main>b__0_0))), <>c.<>9__0_1 ?? (<>c.<>9__0_1 = new Func<int, int>(<>c.<>9.<Main>b__0_1)));

IEnumerable<int> values2 = Enumerable.Select(Enumerable.Where(source, <>c.<>9__0_2 ?? (<>c.<>9__0_2 = new Func<int, bool>(<>c.<>9.<Main>b__0_2))), <>c.<>9__0_3 ?? (<>c.<>9__0_3 = new Func<int, int>(<>c.<>9.<Main>b__0_3)));
```

Jak widaÄ‡, przewijajÄ…c kod w prawo (zachowaÅ‚em oryginalne formatowanie), jest on identyczny. CaÅ‚oÅ›Ä‡ zdekompilowanego kodu w C# oraz w CIL znajdziesz [tutaj](https://gist.github.com/tswistak/10b013803ea4b0a86f185d766b12c090).

#### SQL

Jeszcze pokaÅ¼Ä™ przykÅ‚ad w jÄ™zyku SQL. Å»eby nie robiÄ‡ szybkiej lekcji o tym, jak siÄ™ tworzy i projektuje bazy danych, zakÅ‚adam, Å¼e mamy tam tabelÄ™ Liczby zawierajÄ…cÄ… jednÄ… kolumnÄ™ Liczba. Wiersze sÄ… kolejnymi liczbami od 1 do 10. To, co zrobimy w jÄ™zyku SQL, to dokÅ‚adnie ta sama operacja, ktÃ³rÄ… pokazaÅ‚em wyÅ¼ej w C# w LINQ.

UÅ¼ywany przeze mnie na potrzeby przykÅ‚adu system bazodanowy to SQLite. PoniÅ¼ej moÅ¼esz zobaczyÄ‡ zapytanie SQL, ktÃ³re wyciÄ…gnie z kolumny jedynie parzyste wartoÅ›ci i zwrÃ³ci je podniesione do kwadratu:

```sql
SELECT Liczba*Liczba -- zwracamy liczbÄ™ podniesionÄ… do kwadratu
FROM Liczby -- pobieramy z tabeli Liczby
WHERE (Liczba % 2) = 0; -- wybieramy jedynie parzyste
```

Zapytanie na bazie danych moÅ¼esz sprawdziÄ‡ na [repl.it](https://replit.com/@tswistak/SQL#main.sql), gdzie zamieÅ›ciÅ‚em teÅ¼ polecenia SQL tworzÄ…ce potrzebnÄ… tabelÄ™ i wypeÅ‚niajÄ…cÄ… jÄ… danymi.

PisaÅ‚em wczeÅ›niej, Å¼e LINQ bardzo przypomina SQL. Po tym przykÅ‚adzie moÅ¼na stwierdziÄ‡, Å¼e jest to prawda â€” w zasadzie jedyna rÃ³Å¼nica, jaka tu jest, to zmieniona kolejnoÅ›Ä‡ wybranych elementÃ³w skÅ‚adni (w SQL zaczynamy od `select`, w LINQ od `from`).

W serwerach bazodanowych rÃ³wnieÅ¼ mamy moÅ¼liwoÅ›Ä‡ podejrzenia, jak â€kompiluje siÄ™â€ nasze zapytanie, do jakiej iteracji po tabeli. W SQLite moÅ¼emy to sprawdziÄ‡ za pomocÄ… polecenia `EXPLAIN [zapytanie]`. Dla powyÅ¼ej pokazanego zapytania wyglÄ…da to nastÄ™pujÄ…co:

```
addr  opcode         p1    p2    p3    p4             p5  comment
----  -------------  ----  ----  ----  -------------  --  -------------
0     Init           0     13    0                    0   Start at 13
1     OpenRead       0     2     0     1              0   root=2 iDb=0; Liczby
2     Explain        2     0     0     SCAN TABLE Liczby  0
3     Rewind         0     12    0                    0
4       Column         0     0     2                    0   r[2]=Liczby.Liczba
5       Remainder      3     2     1                    0   r[1]=r[2]%r[3]
6       Ne             4     11    1                    80  if r[1]!=r[4] goto 11
7       Column         0     0     1                    0   r[1]=Liczby.Liczba
8       Column         0     0     2                    0   r[2]=Liczby.Liczba
9       Multiply       2     1     5                    0   r[5]=r[2]*r[1]
10      ResultRow      5     1     0                    0   output=r[5]
11    Next           0     4     0                    1
12    Halt           0     0     0                    0
13    Transaction    0     0     1     0              1   usesStmtJournal=0
14    Integer        2     3     0                    0   r[3]=2
15    Integer        0     4     0                    0   r[4]=0
16    Goto           0     1     0                    0
```

To, co nas interesuje pod kÄ…tem dziaÅ‚ania iteracji:

- `Explain` zawiera informacjÄ™, ktÃ³ry typ iteracji jest wykonywany. `SCAN TABLE Liczby` oznacza przejÅ›cie po caÅ‚ej tabeli Liczby.
- To, co wykonuje siÄ™ w jednym przebiegu iteracji, znajduje siÄ™ w liniach od 4 do 10.
- Warto wyrÃ³Å¼niÄ‡ liniÄ™ 6., gdzie wykonywany jest warunek z klauzuli `WHERE`. MoÅ¼emy zobaczyÄ‡ analogiÄ™ do asemblera, Å¼e jeÅ›li warunek nie jest speÅ‚niony, to przeskakujemy poza ciaÅ‚o pÄ™tli, do linii 11. W niej znajduje siÄ™ pobranie nastÄ™pnego wiersza tabeli, ktÃ³ry jeÅ›li istnieje, wywoÅ‚uje przeskok do linii 4 (wartoÅ›Ä‡ `p2`).

Innymi sÅ‚owy, nawet w przypadku baz danych wydajÄ…cych siÄ™ byÄ‡ takÄ… czarnÄ… skrzynkÄ…, gdzie dzieje siÄ™ jakaÅ› magia, nasze zapytania SQL-owe sprowadzajÄ… siÄ™ do instrukcji skoku, od ktÃ³rych zaczÄ™liÅ›my artykuÅ‚.

JeÅ›li chciaÅ‚byÅ›/chciaÅ‚abyÅ› wejÅ›Ä‡ gÅ‚Ä™biej w temat, wyjaÅ›nienie, co wykonujÄ… rozkazy zapisane w kolumnie `opcode`, znajdziesz w [dokumentacji SQLite](https://www.sqlite.org/opcode.html). PamiÄ™taj, Å¼e w innych silnikach bazodanowych bÄ™dzie to wyglÄ…daÄ‡ inaczej, jednak koniec koÅ„cÃ³w sprowadzi siÄ™ do tego samego.

## Podsumowanie

MyÅ›lÄ™, Å¼e w artykule przedstawiÅ‚em temat iteracji doÅ›Ä‡ obszernie. Mimo Å¼e byÅ‚o tego tak duÅ¼o, nie byÅ‚em w stanie poruszyÄ‡ caÅ‚oÅ›ci tematu. JeÅ›li chciaÅ‚byÅ›/chciaÅ‚abyÅ› jeszcze gÅ‚Ä™biej sprawdziÄ‡, tak wydawaÅ‚oby siÄ™, podstawowy temat, to pominÄ…Å‚em tutaj:

- Iteracje w logice matematycznej, a dokÅ‚adniej, jak wykonuje siÄ™ je w rachunku lambda (podpowiedÅº: rekurencja), co caÅ‚kowicie wykracza poza obszar, na ktÃ³rym chciaÅ‚em siÄ™ tutaj skupiÄ‡.
- Iteracje w logice Hoeare'a. Jest to formalizm matematyczny stosowany w dowodzeniu poprawnoÅ›ci algorytmÃ³w, wiÄ™c nie mogÅ‚o w nim zabraknÄ…Ä‡ sposobu na zapis pÄ™tli. MyÅ›lÄ™, Å¼e jednak opowiedzenie jeszcze o tym niepotrzebnie skomplikowaÅ‚oby i tak juÅ¼ mocno rozbudowany artykuÅ‚. WolaÅ‚em siÄ™ skupiÄ‡ na czÄ™Å›ci obliczeniowej (czyli na tym, co mamy w jÄ™zykach programowania i jak to jest przetwarzane) niÅ¼ na dowodach matematycznych.
- MÃ³wiÄ…c o teorii, matematyce i dowodach, pominÄ…Å‚em rÃ³wnieÅ¼ takie pojÄ™cia, jak *zmiennik* i *niezmiennik* pÄ™tli. SÄ… one juÅ¼ bardziej zwiÄ…zane z czÄ™Å›ciÄ… obliczeniowÄ…, aczkolwiek nie chciaÅ‚em dokÅ‚adaÄ‡ jeszcze dodatkowej teorii.
- Optymalizacja iteracji. Temat jest bardzo szeroki i moÅ¼na do niego podejÅ›Ä‡ od wielu stron, wiÄ™c zdecydowanie zasÅ‚uguje na oddzielny tekst.

DobÃ³r jÄ™zykÃ³w programowania w przykÅ‚adach wynika tylko i wyÅ‚Ä…cznie z tego, w czym sam programowaÅ‚em przez lata nauki i pracy. MyÅ›lÄ™ jednak, Å¼e przykÅ‚ady w asemblerze x86 (NASM), C, C++, C#, Javie, JavaScripcie, Pascalu, Pythonie i SQL-u byÅ‚y wystarczajÄ…ce, Å¼eby pokazaÄ‡ rÃ³Å¼norodnoÅ›Ä‡ skÅ‚adniowÄ… w Å›wiecie programowania. PamiÄ™taj, Å¼e jÄ™zyk programowania to tylko narzÄ™dzie, ktÃ³re wielokrotnie bÄ™dziesz zmieniaÄ‡, a wiedza jak programowaÄ‡ i co dzieje siÄ™ pod spodem jest uniwersalna.

Skoro dotarÅ‚eÅ›(-aÅ›) do tego miejsca, to bardzo dziÄ™kujÄ™ za poÅ›wiÄ™cony czas na przeczytanie. Napisanie tego tekstu zajÄ™Å‚o niemal miesiÄ…c (zaczÄ…Å‚em go pisaÄ‡ 24 listopada 2022) i bÄ™dÄ™ bardzo wdziÄ™czny, jeÅ›li podzielisz siÄ™ nim ze znajomymi. PoniÅ¼ej pod sekcjÄ… literatury znajdziesz przyciski umoÅ¼liwiajÄ…ce udostÄ™pnienie linka na rÃ³Å¼nych mediach spoÅ‚ecznoÅ›ciowych. Blog nie posiada Å¼adnych reklam i nie otrzymujÄ™ z niego Å¼adnych innych przychodÃ³w, stÄ…d bÄ™dÄ™ bardzo wdziÄ™czny za kaÅ¼de udostÄ™pnienie. Z&nbsp;gÃ³ry dziÄ™kujÄ™ ğŸ˜Š.

## Literatura

PiszÄ…c artykuÅ‚, korzystaÅ‚em z bardzo wielu ÅºrÃ³deÅ‚, dlatego wyjÄ…tkowo podzieliÅ‚em je na kategorie. Od razu nadmieniÄ™, Å¼e oczywiÅ›cie dokumentacje teÅ¼ sÄ… ÅºrÃ³dÅ‚ami internetowymi, jednak ze wzglÄ™du na zdecydowanÄ… rÃ³Å¼nicÄ™ w ich specyfice wzglÄ™dem np. Wikipedii, postanowiÅ‚em je oddzieliÄ‡.

- Pozycje ksiÄ…Å¼kowe i prace naukowe
    - Edsger W. Dijkstra. 1968. Letters to the editor: go to statement considered harmful. Commun. ACM 11, 3 (March 1968), 147â€“148. [doi:10.1145/362929.362947](https://doi.org/10.1145/362929.362947)
    - Nystrom R., â€Jumping Back and Forthâ€ w *Crafting Interpreters*. Genever Benning, 2021, s. 413-431
    - Eckel B., â€Sterowanie wykonaniem programuâ€ w *Thinking in C++*. Gliwice: Helion, 2002, s. 99-107
    - Eckel B., â€Sterowanie przebiegiem wykonaniaâ€ w *Thinking in Java*. Gliwice: Helion, 2006, s. 127-142
    - Harris S., Ross J., â€Iteracja i rekurencjaâ€ w *Od podstaw Algorytmy*. Gliwice: Helion, 2006, s. 41â€“70
    - Griffiths I., Adams M., Liberty J., â€Instrukcje iteracjiâ€ w *C# Programowanie*. Gliwice: Helion, 2012, s. 64-71
    - Griffiths I., Adams M., Liberty J., â€LINQâ€ w *C# Programowanie*. Gliwice: Helion, 2012, s. 275-306
    - van Roy P., Haridi S., â€Loop abstractionsâ€ w Concepts, Techniques and Models of Computer Programming. The MIT Press, 2004, s. 186-190
    - Garcia-Molina H., Ullman J.D., Widom J., â€Wykonywanie zapytaÅ„â€ w *Systemy baz danych. Kompletny podrÄ™cznik*. Gliwice: Helion, 2011, s. 627-675
- Pozycje internetowe
    - iteracja, *SÅ‚ownik jÄ™zyka polskiego PWN*, https://sjp.pwn.pl/sjp/iteracja;2562037.html (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Silver B., Repeating Activities in BPMN` (2 marca 2021), *Method & Style* https://methodandstyle.com/repeating-activities-in-bpmn/ (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Kapela T., Programowanie niskopoziomowe, https://ww2.ii.uj.edu.pl/~kapela/pn/print-lecture.php (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Jacky J., Loops Invariants, Correctness, and Program Derivation, https://archives.evergreen.edu/webpages/curricular/2001-2002/dsa01/loops.html (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Iteration, https://en.wikipedia.org/w/index.php?title=Iteration&oldid=1124950003 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Goto, https://en.wikipedia.org/w/index.php?title=Goto&oldid=1116451794 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - While loop, https://en.wikipedia.org/w/index.php?title=While_loop&oldid=1123191830 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Do while loop, https://en.wikipedia.org/w/index.php?title=Do_while_loop&oldid=1116361029 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - For loop, https://en.wikipedia.org/w/index.php?title=For_loop&oldid=1116356713 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Complex instruction set computer, https://en.wikipedia.org/w/index.php?title=Complex_instruction_set_computer&oldid=1111865839 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Reduced instruction set computer, https://en.wikipedia.org/w/index.php?title=Reduced_instruction_set_computer&oldid=1125522408 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Generator (computer programming), https://en.wikipedia.org/w/index.php?title=Generator_(computer_programming)&oldid=1123250001 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Query language, https://en.wikipedia.org/w/index.php?title=Query_language&oldid=1127333236 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Funkcja wyÅ¼szego rzÄ™du, https://pl.wikipedia.org/w/index.php?title=Funkcja_wy%C5%BCszego_rz%C4%99du&oldid=64513837 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Fold, https://pl.wikipedia.org/w/index.php?title=Fold&oldid=68135087 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
- Dokumentacje
    - Iteration protocols, *JavaScript | MDN*, https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols
    - IEnumerator\<T\> Interface (System.Collections.Generic), *Microsoft Learn*, https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerator-1?view=net-7.0 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - IEnumerable\<T\> Interface (System.Collections.Generic), *Microsoft Learn*, https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1?view=net-7.0 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Enumerable Class (System.Linq), *Microsoft Learn*, https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable?view=net-7.0 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - List\<T\>.ForEach(Action\<T\>) Method (System.Collections.Generic), *Microsoft Learn*, https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.list-1.foreach?view=net-7.0 (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Iterator, *Java SE 19 & JDK 19*, https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/Iterator.html (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - Iterable, *Java SE 19 & JDK 19*, https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Iterable.html (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - std::iterator, *cppreference.com*, https://en.cppreference.com/w/cpp/iterator/iterator (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - EXPLAIN QUERY PLAN, *SQLite*, https://www.sqlite.org/eqp.html (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)
    - The SQLite Bytecode Engine, https://www.sqlite.org/opcode.html (ostatnio&nbsp;odwiedzone&nbsp;17.12.2022)

<small>ZdjÄ™cie na okÅ‚adce wygenerowane przez DALL-E. OryginaÅ‚ znajduje siÄ™ [tutaj](https://labs.openai.com/s/RaydqbUW53QdlczNSf6fkp5e).</small>
