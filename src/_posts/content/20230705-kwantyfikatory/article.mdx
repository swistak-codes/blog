import Link from 'next/link';
import {Image} from '@swistak-codes/components';
import cover from './swistak_blackwhite.jpg';

export const meta = {
  title: 'Logika dla informatykÃ³w â€” kwantyfikatory',
  abstract:
    'W artykule pokazujÄ™ zagadnienia rachunku kwantyfikatorÃ³w napisane pod kÄ…tem ich zastosowaÅ„ w informatyce.',
  firstParagraph: (
    <>
      PrzedstawiajÄ…c ostatnio podstawy logiki dla informatykÃ³w, ograniczyÅ‚em siÄ™ tylko do rachunku zdaÅ„, bo to on jest najczÄ™Å›ciej spotykany. Jednak logika matematyczna jest duÅ¼o bardziej rozbudowana i inne jej elementy teÅ¼ znajdujÄ… zastosowanie praktyczne. Kolejnym zagadnieniem, ktÃ³re chcÄ™ przedstawiÄ‡, jest rachunek kwantyfikatorÃ³w. Z naszego punktu widzenia bÄ™dzie to krÃ³tkie i proste, ale warte opowiedzenia.
    </>
  ),
  keyword: 'logika',
  categories: ['Logika'],
  tags: [
    'logika',
    'matematyka',
    'kwantyfikator',
    'kwantyfikator ogÃ³lny',
    'kwantyfikator szczegÃ³Å‚owy',
    'kwantyfikator duÅ¼y',
    'kwantyfikator maÅ‚y',
    'kwantyfikator egzystencjalny',
    'kwantyfikator uniwersalny',
    'prawa de Morgana',
    'javascript',
    'c#'
  ],
  slug: 'kwantyfikatory',
  updateTime: '2023-07-05T07:00:00+00:00',
  publishTime: '2023-07-05T07:00:00+00:00',
  cover,
};

## Uwaga wstÄ™pna

ArtykuÅ‚ jest kontynuacjÄ… artykuÅ‚u *<Link href="/post/podstawy-logiki">Logika dla informatykÃ³w â€” podstawy</Link>*. Dlatego teÅ¼ zakÅ‚adam, Å¼e pojÄ™cia, ktÃ³re tam przedstawiÅ‚em, nie sÄ… Ci obce. JeÅ›li jednak znasz pojÄ™cia zwiÄ…zane z rachunkiem zdaÅ„ i takie terminy jak aksjomat czy tautologia, moÅ¼esz spokojnie czytaÄ‡ dalej. ChociaÅ¼ szybkie powtÃ³rzenie tematu jest zawsze wskazane ğŸ˜‰.

## Czym sÄ… kwantyfikatory

Kwantyfikator to matematyczna nazwa na zwroty typu *istnieje* czy *dla kaÅ¼dego* (a takÅ¼e im pokrewne) oraz odpowiadajÄ…ce im symbole. Natomiast rachunek kwantyfikatorÃ³w to operacje, ktÃ³re wykonujemy na nich. PrawdÄ™ mÃ³wiÄ…c, z punktu widzenia absolutnych podstaw nie ma co rozszerzaÄ‡ tej definicji. Warto jednak od razu powiedzieÄ‡ sobie o ich zastosowaniu w matematyce: odgrywajÄ… waÅ¼nÄ… rolÄ™ w definiowaniu twierdzeÅ„ i definicji. A jak moÅ¼esz siÄ™ domyÅ›laÄ‡, skoro opowiadam o nich na tym blogu, to znaczy, Å¼e teÅ¼ stosujemy je w informatyce, co pokaÅ¼Ä™ dalej.

## Rodzaje kwantyfikatorÃ³w

W poprzednim akapicie wspomniaÅ‚em, Å¼e kwantyfikatory to takie zwroty jak *istnieje* i *dla kaÅ¼dego*. SÄ… to dwa najwaÅ¼niejsze rodzaje kwantyfikatorÃ³w: ogÃ³lny i szczegÃ³Å‚owy. OmÃ³wmy je.

### Kwantyfikator ogÃ³lny

Kwantyfikator ogÃ³lny (inaczej: duÅ¼y, uniwersalny) odpowiada okreÅ›leniu *dla kaÅ¼dego*. MoÅ¼emy go  zapisaÄ‡ na dwa sposoby:

- $$\forall$$ â€” odwrÃ³cona litera A, od angielskiego *for **all***
- $$\bigwedge$$ â€” moÅ¼na skojarzyÄ‡ z rozszerzaniem siÄ™ na caÅ‚oÅ›Ä‡ jakiegoÅ› zakresu

$$\forall x: \phi(x)$$ odczytamy jako *dla kaÅ¼dego $$x$$ zachodzi $$\phi(x)$$*, czyli wszystkie $$x$$ muszÄ… speÅ‚niaÄ‡ warunek opisany funkcjÄ… $$\phi(x)$$.

MyÅ›lÄ™, Å¼e sam ten opis, jak i â€dla kaÅ¼degoâ€ pokazujÄ…, jakie zastosowania ma ten kwantyfikator w matematyce. Jednak skupmy siÄ™ teraz na programowaniu. Miejscem, gdzie najczÄ™Å›ciej trafiamy na kwantyfikatory, sÄ… operacje na kolekcjach sprawdzajÄ…ce jej elementy. DosÅ‚ownÄ… implementacjÄ… kwantyfikatora ogÃ³lnego sÄ… funkcje sprawdzajÄ…ce, czy wszystkie elementy kolekcji speÅ‚niajÄ… wskazany predykat (funkcja okreÅ›lajÄ…ca warunek, ktÃ³ry musi speÅ‚niÄ‡ element).

PrzykÅ‚adowe implementacje kwantyfikatora ogÃ³lnego w jÄ™zykach programowania znajdziemy pod nazwami takimi jak:

- `every()`, np. w [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every)
- `All()`, np. w [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.all?view=net-7.0); ewentualnie warianty tej nazwy jak `allMatch()` w [Javie](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#allMatch-java.util.function.Predicate-)

PrzykÅ‚adowe uÅ¼ycie w JavaScript wyglÄ…da tak:

```javascript
// tablica z liczbami podzielnymi przez 15
const numbers = [0, 15, 30, 45, 60];

// sprawdzamy, czy wszystkie sÄ… parzyste
const areEven = numbers.every(x => x % 2 === 0);
// wypisujemy wynik
console.log(areEven); // false

// sprawdzamy, czy wszystkie sÄ… l. caÅ‚kowitymi
const areInteger = numbers.every(Number.isInteger);
// wypisujemy wynik
console.log(areInteger); // true
```

Kod moÅ¼esz przetestowaÄ‡ na wÅ‚asnÄ… rÄ™kÄ™ na [Replit](https://replit.com/@tswistak/js-every#index.js).

JeÅ›li jesteÅ› ciekaw(a), jak mogÅ‚aby wyglÄ…daÄ‡ od zera implementacja kwantyfikatora ogÃ³lnego, zamieÅ›ciÅ‚em jÄ… w artykule *<Link href="/post/iteracja-co-to-jest/#sprawdzenie-czy-elementy-spe%C5%82niaj%C4%85-warunek">Iteracja â€” co to jest?</Link>*

### Kwantyfikator szczegÃ³Å‚owy

Kwantyfikator szczegÃ³Å‚owy (inaczej: maÅ‚y, egzystencjalny) odpowiada sÅ‚owu *istnieje*. RÃ³wnieÅ¼ mamy dwa sposoby zapisu:

- $$\exists$$ â€” odwrÃ³cona litera E, od angielskiego ***exists***
- $$\bigvee$$ â€” moÅ¼na skojarzyÄ‡ ze wskazaniem na konkretny element

$$\exists x: \phi(x)$$ odczytamy jako *istnieje takie $$x$$, dla ktÃ³rego zachodzi $$\phi(x)$$*. Oznacza to, Å¼e przynajmniej jeden $$x$$ speÅ‚nia warunek opisany funkcjÄ… $$\phi(x)$$.

Analogicznie jak w przypadku kwantyfikatora ogÃ³lnego, szczegÃ³Å‚owy rÃ³wnieÅ¼ znajdziemy w jÄ™zykach programowania jako operacjÄ™ sprawdzajÄ…cÄ… zawartoÅ›Ä‡ kolekcji. Zwykle skrywa siÄ™ pod nazwami:

- `some()`, np. w [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
- `Any()`, np. w [C#](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.any?view=net-7.0); tutaj teÅ¼ moÅ¼na spotkaÄ‡ warianty tej nazwy, jak `anyMatch()` w [Javie](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html#anyMatch-java.util.function.Predicate-)
  - BÄ™dÄ…c przy jÄ™zyku C#, warto takÅ¼e wspomnieÄ‡ o takiej metodzie, jak [`First()`](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.first?view=net-7.0#system-linq-enumerable-first-1(system-collections-generic-ienumerable((-0))-system-func((-0-system-boolean)))), ktÃ³ra dziaÅ‚a analogicznie do `Any()`, tylko zamiast zwrÃ³ciÄ‡ prawdÄ™, zwrÃ³ci pierwszy element speÅ‚niajÄ…cy predykat. JeÅ›li natomiast Å¼aden nie speÅ‚nia, rzuca wyjÄ…tek. MoÅ¼emy teÅ¼ uÅ¼yÄ‡ [`FirstOrDefault()`](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.firstordefault?view=net-7.0), ktÃ³ry zamiast wyjÄ…tku zwrÃ³ci domyÅ›lnÄ… wartoÅ›Ä‡

Dla formalnoÅ›ci zobaczmy przykÅ‚ad uÅ¼ycia w JavaScript:

```javascript
// tablica z liczbami podzielnymi przez 15
const numbers = [0, 15, 30, 45, 60];

// sprawdzamy, czy jest jakakolwiek parzysta
const isAnyEven = numbers.some(x => x % 2 === 0);
// wypisujemy wynik
console.log(isAnyEven); // true

// sprawdzamy, czy jakakolwiek nie jest l. caÅ‚kowitÄ…
const isAnyNonInteger = numbers.some(x => !Number.isInteger(x));
// wypisujemy wynik
console.log(isAnyNonInteger); // false
```

Kod moÅ¼esz przetestowaÄ‡ na wÅ‚asnÄ… rÄ™kÄ™ na [Replit](https://replit.com/@tswistak/js-some#index.js).

W artykule *<Link href="/post/iteracja-co-to-jest/#sprawdzenie-czy-elementy-spe%C5%82niaj%C4%85-warunek">Iteracja â€” co to jest?</Link>*, w tym samym miejscu co ostatnio, zamieÅ›ciÅ‚em rÃ³wnieÅ¼ implementacjÄ™ kwantyfikatora szczegÃ³Å‚owego, jeÅ›li jesteÅ› ciekaw(a), jak mogÅ‚oby to wyglÄ…daÄ‡.

### Kwantyfikator szczegÃ³Å‚owy z wykrzyknikiem

MoÅ¼emy spotkaÄ‡ siÄ™ takÅ¼e z zapisywaniem kwantyfikatora szczegÃ³Å‚owego z wykrzyknikiem, co wyglÄ…da nastÄ™pujÄ…co:

$$
\exists! x: \phi(x)
$$

W tym przypadku jest to zawÄ™Å¼enie kwantyfikatora szczegÃ³Å‚owego â€” nie interesuje nas jedynie informacja, Å¼e jakikolwiek element speÅ‚nia warunek $$\phi(x)$$. Interesuje nas, Å¼eby dokÅ‚adnie tylko jeden element speÅ‚niaÅ‚ taki warunek. Tym samym powyÅ¼sze zdanie odczytamy jako: â€istnieje dokÅ‚adnie jedno $$x$$, dla ktÃ³rego zachodzi $$\phi(x)$$â€.

Kwantyfikator ten nie jest zbyt powszechny, stÄ…d teÅ¼ rzadko spotykamy go w jÄ™zykach programowania. Jedynym, z ktÃ³rym sam siÄ™ spotkaÅ‚em, a miaÅ‚by coÅ› na ten wzÃ³r, jest C#, gdzie znajdziemy metodÄ™ [`Single()`](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.single?view=net-7.0). Nie zwraca ona jednak prawdy lub faÅ‚szu, a Ã³w jedyny element speÅ‚niajÄ…cy predykat. JeÅ›li nie ma elementu speÅ‚niajÄ…cego predykat lub speÅ‚nia go wiÄ™cej niÅ¼ jeden, rzucany jest wyjÄ…tek. Analogicznie do `First()`, znajdziemy takÅ¼e metodÄ™ [`SingleOrDefault()`](https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.singleordefault?view=net-7.0), ktÃ³ra zamiast wyjÄ…tku zwrÃ³ci domyÅ›lnÄ… wartoÅ›Ä‡.

PoniÅ¼ej moÅ¼esz zobaczyÄ‡ przykÅ‚ad dziaÅ‚ania:

```csharp
// tablica z liczbami podzielnymi przez 15
int[] numbers = { 15, 30, 45, 60 };
// sprawdzamy, czy tylko jedna jest podzielna przez 2
try
{
  Console.WriteLine(numbers.Single(x => x % 2 == 0));
}
catch (Exception e)
{
  Console.WriteLine(e.Message); // speÅ‚nia wiÄ™cej niÅ¼ jeden element
}
// sprawdzamy, czy jest tylko jedna mniejsza od 0
try
{
  Console.WriteLine(numbers.Single(x => x < 0));
}
catch (Exception e)
{
  Console.WriteLine(e.Message); // Å¼aden element nie speÅ‚nia
}
// sprawdzamy, czy jest tylko jedna podzielna przez 9
Console.WriteLine(numbers.Single(x => x % 9 == 0)); // 45
```

Kod moÅ¼esz przetestowaÄ‡ na [Replit](https://replit.com/@tswistak/csharp-single#main.cs).

Natomiast jak poradziÄ‡ sobie w jÄ™zykach programowania niemajÄ…cych odpowiednika `Single()`? MoÅ¼emy albo przeiterowaÄ‡ rÄ™cznie po kolekcji i sprawdziÄ‡, czy warunek jest speÅ‚niony wiÄ™cej niÅ¼ raz, albo zliczyÄ‡ liczbÄ™ elementÃ³w, ktÃ³re otrzymamy po przefiltrowaniu kolekcji. Oba te sposoby zaimplementowane w JavaScript moÅ¼esz zobaczyÄ‡ poniÅ¼ej:

```javascript
function single1(array, predicate) {
  // przefiltrowujemy kolekcjÄ™, aby uzyskaÄ‡ elementy speÅ‚niajÄ…ce predykat,
  // po czym sprawdzamy, czy dostaliÅ›my tylko jeden element
  return array.filter(predicate).length === 1;
}

function single2(array, predicate) {
  // zmienna, gdzie zapiszemy, czy jakikolwiek element speÅ‚niÅ‚ predykat
  let anyFulfilling = false;
  // iterujemy po wszystkich elementach tablicy
  for (const element of array) {
    // sprawdzamy, czy element speÅ‚nia predykat
    const fulfills = predicate(element);
    // jeÅ›li speÅ‚nia
    if (fulfills) {
      // ...i jednoczeÅ›nie inny element teÅ¼ speÅ‚niaÅ‚
      if (anyFulfilling) {
        // zwracamy faÅ‚sz
        return false;
      } else {
        // ...i Å¼aden do tej pory nie speÅ‚niÅ‚,
        // to ustawiamy, Å¼e juÅ¼ jakiÅ› speÅ‚niÅ‚
        anyFulfilling = true;
      }
    }
  }
  // zwracamy, czy jakikolwiek element speÅ‚niÅ‚ predykat
  return anyFulfilling;
}
```

UÅ¼ycie wyglÄ…daÅ‚oby nastÄ™pujÄ…co:

```javascript
// tablica z liczbami podzielnymi przez 15
const numbers = [15, 30, 45, 60];

// sprawdzamy, czy tylko jedna jest podzielna przez 2
console.log(
  single1(numbers, (x) => x % 2 === 0), // false
  single2(numbers, (x) => x % 2 === 0) // false
);

// sprawdzamy, czy jest tylko jedna mniejsza od 0
console.log(
  single1(numbers, (x) => x < 0), // false
  single2(numbers, (x) => x < 0) // false
);

// sprawdzamy, czy jest tylko jedna podzielna przez 9
console.log(
  single1(numbers, (x) => x % 9 === 0), // true
  single2(numbers, (x) => x % 9 === 0) // true
);
```

Ten kod rÃ³wnieÅ¼ moÅ¼esz przetestowaÄ‡ na [Replit](https://replit.com/@tswistak/js-single#index.js).

## Prawa rachunku kwantyfikatorÃ³w

Co ciekawe i przydatne w kontekÅ›cie programowania, w rachunku kwantyfikatorÃ³w rÃ³wnieÅ¼ mamy tautologie, czyli zdania zawsze prawdziwe â€” inaczej prawa rachunku kwantyfikatorÃ³w. Poznajmy najwaÅ¼niejsze, tym razem bez wyprowadzania i dowodzenia.

### Prawa de Morgana

Zdecydowanie najprzydatniejszymi tautologiami, ktÃ³re moÅ¼na poznaÄ‡ w rachunku kwantyfikatorÃ³w, sÄ… prawa de Morgana:

- I prawo: $$\neg \left( \forall x: \phi(x) \right) \iff \left( \exists x: \neg \phi(x) \right)$$ â€” moÅ¼emy rozumieÄ‡ to tak, Å¼e jeÅ›li nieprawdÄ… jest, Å¼e wszystkie elementy speÅ‚niajÄ… $$\phi(x)$$, to jest to rÃ³wnowaÅ¼ne temu, Å¼e istnieje jakiÅ› element, ktÃ³ry nie speÅ‚nia $$\phi(x)$$. PrzykÅ‚ad: nieprawdÄ… jest, Å¼e wszystkie liczby naturalne $$x$$ sÄ… podzielne przez 2. Oznacza to, Å¼e istnieje w zbiorze liczb naturalnych takie $$x$$, ktÃ³re nie jest podzielne przez 2.
- II prawo: $$\neg \left( \exists x: \phi(x) \right) \iff \left( \forall x: \neg \phi(x) \right)$$ â€” dosÅ‚owna odwrotnoÅ›Ä‡, czyli jeÅ›li nieprawdÄ… jest, Å¼e jakikolwiek element speÅ‚nia $$\phi(x)$$, to jest to rÃ³wnowaÅ¼ne temu, Å¼e wszystkie elementy nie speÅ‚niajÄ… $$\phi(x)$$. PrzykÅ‚ad: nieprawdÄ… jest, Å¼e jakakolwiek liczba naturalna $$x$$ jest mniejsza od 0. Oznacza to, Å¼e wszystkie $$x$$ ze zbioru liczb naturalnych nie sÄ… mniejsze od 0.

PoniÅ¼ej pokazujÄ™, jak w programowaniu moÅ¼na zastosowaÄ‡ prawa de Morgana na rachunku kwantyfikatorÃ³w (kod w JavaScript):

```javascript
// deklarujemy tablicÄ™ z 6 pierwszymi liczbami naturalnymi
const numbers = [0, 1, 2, 3, 4, 5];

// sprawdzamy, czy wszystkie liczby sÄ… podzielne przez 2
const allNotDivisible = !numbers.every(x => x % 2 === 0);
// teraz odwrÃ³Ä‡my warunek, stosujÄ…c I prawo de Morgana
// sprawdzamy, czy jakakolwiek liczba jest niepodzielna przez 2
const anyNotDivisible = numbers.some(x => x % 2 !== 0);

// wypiszmy wyniki
console.log(allNotDivisible, anyNotDivisible); // true, true

// sprawdzamy, czy nie istnieje liczba mniejsza od 0
const anyNotSmaller = !numbers.some(x => x < 0);
// odwracamy warunek, stosujÄ…c II prawo de Morgana
// sprawdÅºmy, czy wszystkie sÄ… wiÄ™ksze od 0
const allLarger = numbers.every(x => x >= 0);
// `x >= 0` jest tym samym co `!(x < 0)`, a bardziej naturalnym zapisem

// wypiszmy wyniki
console.log(anyNotSmaller, allLarger); // true, true
```

Kod moÅ¼esz przetestowaÄ‡ na [Replit](https://replit.com/@tswistak/quantifiers-demorgan#index.js).

Jak widzisz, zastosowanie praw de Morgana jest bardzo praktyczne w tym przypadku. PomijajÄ…c kwestiÄ™, Å¼e dziÄ™ki nim moÅ¼emy pisaÄ‡ czytelniejsze warunki, to moÅ¼emy teÅ¼ w ten sposÃ³b optymalizowaÄ‡ operacje na kolekcjach. Warto jednak wiedzieÄ‡, Å¼e optymalizacje mogÄ… byÄ‡ maÅ‚o intuicyjne, poniewaÅ¼ w drugim przykÅ‚adzie `anyNotSmaller` przyjmie prawdÄ™ juÅ¼ po sprawdzeniu pierwszego elementu, podczas gdy znacznie czytelniejszy `allLarger` wymaga sprawdzenia caÅ‚oÅ›ci kolekcji. Warto jednak pamiÄ™taÄ‡, Å¼e tak drobiazgowe optymalizacje nie zawsze majÄ… sens i warto przede wszystkim stawiaÄ‡ na czytelnoÅ›Ä‡ kodu.

### Definiowanie jednego kwantyfikatora przez drugi

Z rachunku zdaÅ„ wiemy, Å¼e podwÃ³jna negacja daje ten sam rezultat co brak negacji:

$$
\neg \neg p \iff p
$$

Prawo to stosuje siÄ™ teÅ¼ do kwantyfikatorÃ³w â€” w koÅ„cu z ich uÅ¼yciem rÃ³wnieÅ¼ otrzymujemy zdania logiczne. Oznacza to, Å¼e wykorzystujÄ…c prawa de Morgana, moÅ¼emy otrzymaÄ‡ definicje jednego kwantyfikatora, korzystajÄ…c z drugiego. Wystarczy to zrobiÄ‡ przez dodatkowÄ… negacjÄ™, tak jak to pokazaÅ‚em powyÅ¼ej.

Z negacji pierwszego prawa otrzymamy wzÃ³r na kwantyfikator ogÃ³lny:

$$
\begin{align*}
\neg \neg \left( \forall x: \phi(x) \right) &\iff \neg \left( \exists x: \neg \phi(x) \right) \\
\left( \forall x: \phi(x) \right) &\iff \neg \left( \exists x: \neg \phi(x) \right)
\end{align*}
$$

Analogicznie z drugiego prawa otrzymamy wzÃ³r na kwantyfikator szczegÃ³Å‚owy:

$$
\begin{align*}
\neg \neg \left( \exists x: \phi(x) \right) &\iff \neg \left( \forall x: \neg \phi(x) \right) \\
 \left( \exists x: \phi(x) \right) &\iff \neg \left( \forall x: \neg \phi(x) \right)
\end{align*}
$$

SprawdÅºmy w praktyce, jak w ten sposÃ³b moÅ¼emy upraszczaÄ‡ warunki na kolekcjach w jÄ™zykach programowania:

```javascript
// deklarujemy tablicÄ™ z 6 pierwszymi liczbami naturalnymi
const numbers = [0, 1, 2, 3, 4, 5];

// sprawdzamy, czy nie ma jakiejkolwiek niecaÅ‚kowitej
const notSomeNotInteger = !numbers.some(x => !Number.isInteger(x));
// odwrÃ³Ä‡my sytuacjÄ™: sprawdzamy, czy wszystkie sÄ… caÅ‚kowite
const allInteger = numbers.every(x => Number.isInteger(x));
// wypiszmy wyniki
console.log(notSomeNotInteger, allInteger); // true, true

// sprawdzamy, czy nie wszystkie sÄ… wiÄ™ksze bÄ…dÅº rÃ³wne od 0
const notAllLargerEqual = !numbers.every(x => x >= 0);
// odwrÃ³Ä‡my: sprawdzamy, czy jakakolwiek jest mniejsza od 0
const someSmaller = numbers.some(x => x < 0);
// wypiszmy wyniki
console.log(notAllLargerEqual, someSmaller); // false, false
```

Kod do przetestowania znajdziesz na [Replit](https://replit.com/@tswistak/quantifiers-demorgan2#index.js).

### RozdzielnoÅ›Ä‡

Kolejnym prawem, ktÃ³re warto znaÄ‡ i ktÃ³re moÅ¼e siÄ™ przydaÄ‡ w praktyce, jest prawo rozdzielnoÅ›ci. MoÅ¼emy wyrÃ³Å¼niÄ‡ dwa, po jednym dla kaÅ¼dego z kwantyfikatorÃ³w.

Dla kwantyfikatora ogÃ³lnego mamy peÅ‚ne prawo rozdzielnoÅ›ci wzglÄ™dem koniunkcji, co oznacza, Å¼e oba poniÅ¼sze zdania sÄ… sobie rÃ³wnowaÅ¼ne:

$$
\forall x: (\phi(x) \land \theta(x)) \iff \forall x: \phi(x) \land \forall x: \theta(x)
$$

Natomiast kwantyfikator szczegÃ³Å‚owy jest rozdzielny wzglÄ™dem alternatywy:

$$
\exists x: (\phi(x) \lor \theta(x)) \iff \exists x: \phi(x) \lor \exists x: \theta(x)
$$

W kodzie moglibyÅ›my prawo to wykorzystaÄ‡ do zÅ‚Ä…czenia dwÃ³ch odrÄ™bnych kwantyfikatorÃ³w w jeden, dla zmniejszenia liczby iteracji:

```javascript
// tablica z 7 pierwszymi liczbami naturalnymi
const numbers = [0, 1, 2, 3, 4, 5, 6];

// sprawdÅºmy, czy wszystkie liczby sÄ… wiÄ™ksze od 0 i caÅ‚kowite
const allLargerInteger1 = numbers.every(x => x > 0) && numbers.every(Number.isInteger);
const allLargerInteger2 = numbers.every(x => x > 0 && Number.isInteger(x));
// wypiszmy wynik
console.log(allLargerInteger1, allLargerInteger2); // false, false

// sprawdÅºmy, czy wszystkie liczby sÄ… nieujemne i mniejsze od 10
const allPositiveSmaller1 = numbers.every(x => Math.abs(x) === x) && numbers.every(x => x < 10);
const allPositiveSmaller2 = numbers.every(x => Math.abs(x) === x && x < 10);
// wypiszmy wynik
console.log(allPositiveSmaller1, allPositiveSmaller2); // true, true

// sprawdÅºmy, czy istnieje liczba podzielna przez 2 lub podzielna przez 3
const anyDivisible1 = numbers.some(x => x % 2 === 0) || numbers.some(x => x % 3 === 0);
const anyDivisible2 = numbers.some(x => x % 2 === 0 || x % 3 === 0);
// wypiszmy wynik
console.log(anyDivisible1, anyDivisible2); // true, true

// sprawdÅºmy, czy istnieje liczba ujemna lub caÅ‚kowita
const anyNegativeInteger1 = numbers.some(x => x < 0) || numbers.some(Number.isInteger);
const anyNegativeInteger2 = numbers.some(x => x < 0 || Number.isInteger(x));
// wypiszmy wynik
console.log(anyDivisible1, anyDivisible2); // true, true
```

Jak zawsze kod moÅ¼esz sprawdziÄ‡ na [Replit](https://replit.com/@tswistak/quantifiers-distributivity#index.js).

### NiepeÅ‚ne prawa rozdzielnoÅ›ci

CzytajÄ…c poprzedni akapit, moÅ¼esz mieÄ‡ niedosyt, Å¼e dlaczego moÅ¼emy rozdzielaÄ‡ kwantyfikator ogÃ³lny tylko wzglÄ™dem koniunkcji, a szczegÃ³Å‚owy tylko wzglÄ™dem alternatywy. Jednak, jak siÄ™ okazuje, moÅ¼emy teÅ¼ robiÄ‡ w drugÄ… stronÄ™, ale w tym przypadku nie mamy dwustronnej rÃ³wnowaÅ¼noÅ›ci, stÄ…d mÃ³wimy o niepeÅ‚nych prawach rozdzielnoÅ›ci. Warto je jednak poznaÄ‡, bo rÃ³wnieÅ¼ mogÄ… byÄ‡ przydatne w celu zwiÄ™kszenia czytelnoÅ›ci kodu i jego optymalizacji.

AlternatywÄ™ dwÃ³ch kwantyfikatorÃ³w ogÃ³lnych moÅ¼emy zÅ‚Ä…czyÄ‡ w jeden kwantyfikator. Nie moÅ¼emy jednak postÄ…piÄ‡ w drugÄ… stronÄ™, stÄ…d prawo zapiszemy nastÄ™pujÄ…co:

$$
\forall x: \phi(x) \lor \forall x: \theta(x) \implies \forall x: (\phi(x) \lor \theta(x))
$$

OdwrotnÄ… sytuacjÄ™ mamy dla kwantyfikatora szczegÃ³Å‚owego i koniunkcji. Tutaj moÅ¼emy rozdzieliÄ‡ jeden kwantyfikator na dwa oddzielne, ale nie moÅ¼emy juÅ¼ ich zÅ‚Ä…czyÄ‡:

$$
\exists x: (\phi(x) \land \theta(x)) \implies \exists x: \phi(x) \land \exists x: \theta(x)
$$

Zobacz na poniÅ¼szym przykÅ‚adzie w kodzie, Å¼e faktycznie dziaÅ‚a to jednostronnie:

```javascript
// tablica z 7 pierwszymi liczbami naturalnymi
const numbers = [0, 1, 2, 3, 4, 5, 6];

// sprawdÅºmy, czy wszystkie liczby sÄ… rÃ³wne 0 lub rÃ³Å¼ne od 0
// uÅ¼ywamy tutaj prawa w nieprawidÅ‚owy sposÃ³b
const equalDiff1 = numbers.every(x => x === 0 || x !== 0);
const equalDiff2 = numbers.every(x => x === 0) || numbers.every(x => x !== 0);
// wypiszmy wyniki
console.log(equalDiff1, equalDiff2); // true, false

// sprawdÅºmy, czy wszystkie liczby sÄ… caÅ‚kowite lub wszystkie sÄ… rÃ³Å¼ne od 0
// tym razem prawo jest uÅ¼yte w prawidÅ‚owy sposÃ³b
const integerDiff1 = numbers.every(Number.isInteger) || numbers.every(x => x !== 0);
const integerDiff2 = numbers.every(x => Number.isInteger(x) || x !== 0);
// wypiszmy wyniki
console.log(integerDiff1, integerDiff2); // true, true

// sprawdÅºmy, czy jest liczba rÃ³wna 0 i liczba rÃ³Å¼na od 0
// ponownie, prawo jest uÅ¼yte w nieprawidÅ‚owy sposÃ³b
const equalAndDiff1 = numbers.some(x => x === 0) && numbers.some(x => x !== 0);
const equalAndDiff2 = numbers.some(x => x === 0 && x !== 0);
// wypiszmy wyniki
console.log(equalAndDiff1, equalAndDiff2); // true, false

// sprawdÅºmy, czy jest liczba caÅ‚kowita i rÃ³Å¼na od 0
// uÅ¼ywamy prawa w prawidÅ‚owy sposÃ³b
const integerAndDiff1 = numbers.some(x => Number.isInteger(x) && x !== 0);
const integerAndDiff2 = numbers.some(x => Number.isInteger(x)) && numbers.some(x => x !== 0);
// wypiszmy wyniki
console.log(integerAndDiff1, integerAndDiff2); // true, true
```

Kod jak zawsze znajdziesz na [Replit](https://replit.com/@tswistak/quantifiers-distributivity2#index.js).

Najlepiej widaÄ‡ tego sens na przykÅ‚adach z rÃ³wnoÅ›ciÄ… i nierÃ³wnoÅ›ciÄ… wzglÄ™dem zera. W koÅ„cu moÅ¼emy powiedzieÄ‡, Å¼e wszystkie liczby naturalne sÄ… rÃ³wne zero lub od niego rÃ³Å¼ne. Jednak nie moÅ¼emy juÅ¼ powiedzieÄ‡, Å¼e wszystkie liczby naturalne sÄ… rÃ³wne zero ani Å¼e wszystkie liczby naturalne sÄ… rÃ³Å¼ne od zera. Analogicznie z kwantyfikatorem szczegÃ³Å‚owym: znajdziemy wÅ›rÃ³d liczb naturalnych zarÃ³wno liczbÄ™ rÃ³wnÄ… zero, jak i liczbÄ™ rÃ³Å¼nÄ… od zera. Nie znajdziemy jednak liczby, ktÃ³ra rÃ³wnoczeÅ›nie jest rÃ³wna zero i od niego rÃ³Å¼na.

### Inne prawa

PoniÅ¼ej przedstawiÄ™ kilka innych praw rachunku kwantyfikatorÃ³w. Nie opisujÄ™ ich bardziej szczegÃ³Å‚owo, bo moim zdaniem nie majÄ… aÅ¼ tak duÅ¼ej wartoÅ›ci z punktu widzenia programowania, ale warto je znaÄ‡, szczegÃ³lnie jeÅ›li studiujemy logikÄ™.

- $$\forall x: \phi(x) \implies \exists x: \phi(x)$$
- Prawa przestawiania:
  - $$\forall x: \forall y: \phi(x,y) \iff \forall y: \forall x: \phi(x,y)$$
  - $$\exists x: \exists y: \phi(x,y) \iff \exists y: \exists x: \phi(x,y)$$
- NiepeÅ‚ne prawo przestawiania: $$\exists x: \forall y: \phi(x, y) \implies \forall y: \exists x: \phi(x, y)$$.

SÄ… oczywiÅ›cie rÃ³wnieÅ¼ inne, jak prawo podstawiania, zamiany zmiennej zwiÄ…zanej, doÅ‚Ä…czania kwantyfikatorÃ³w do implikacji itd., ale nie chcÄ™ ich wszystkich tutaj wymieniaÄ‡. W pozycjach wypisanych w literaturze i w Internecie znajdziesz inne tautologie. Te, ktÃ³re wymieniÅ‚em w artykule, uwaÅ¼am za najwaÅ¼niejsze i najbardziej przydatne, szczegÃ³lnie w kontekÅ›cie programowania.

## Podsumowanie

To juÅ¼ drugi artykuÅ‚ z serii o logice i po raz kolejny widzimy zastosowanie praktyczne ktÃ³regoÅ› z jej zagadnieÅ„. Rachunek zdaÅ„ miaÅ‚ bezpoÅ›rednie przeÅ‚oÅ¼enie na wszechobecne warunki. Rachunek kwantyfikatorÃ³w ma juÅ¼ bardziej szczegÃ³Å‚owe zastosowanie, aczkolwiek wciÄ…Å¼ przydatne. W szczegÃ³lnoÅ›ci warto zapamiÄ™taÄ‡ pokazane przeze mnie tautologie, bo dziÄ™ki nim moÅ¼emy uproÅ›ciÄ‡, a takÅ¼e zoptymalizowaÄ‡ kod, ktÃ³ry piszemy.

## Literatura

- Buszkowski W. *Elementy logiki: Kwantyfikatory*, http://buszko.home.amu.edu.pl/elelokw.pdf (ostatni dostÄ™p cze. 30, 2023).
- Quantifier (logic), https://en.wikipedia.org/w/index.php?title=Quantifier_(logic)&oldid=1158055874 (ostatni dostÄ™p cze. 30, 2023).
- Kwantyfikator, https://pl.wikipedia.org/w/index.php?title=Kwantyfikator&oldid=70340473 (ostatni dostÄ™p cze. 30, 2023).
- Kwantyfikator ogÃ³lny, https://pl.wikipedia.org/w/index.php?title=Kwantyfikator_og%C3%B3lny&oldid=70512585 (ostatni dostÄ™p cze. 30, 2023).
- Kwantyfikator egzystencjalny, https://pl.wikipedia.org/w/index.php?title=Kwantyfikator_egzystencjalny&oldid=69263500 (ostatni dostÄ™p cze. 30, 2023).

<small>ZdjÄ™cie na okÅ‚adce wygenerowane przez DALL-E.</small>
