import Link from 'next/link';
import {Image} from '@swistak-codes/components';
import cover from './listonosz_swistak.jpg';
import pubsub from './pubsub.png';

export const meta = {
  title: 'Wzorzec obserwator w UI â€” podejÅ›cia scentralizowane',
  abstract:
    'W artykule pokazujÄ™ scentralizowane podejÅ›cia do implementacji wzorca obserwator.',
  firstParagraph: (
    <>
      W <Link href="/post/obserwator">poprzednim artykule</Link> pokazaÅ‚em, jak wyglÄ…da podstawowa implementacja wzorca obserwator, a takÅ¼e w jaki sposÃ³b z czasem modyfikowano podejÅ›cie do niego. Jednak trzymaliÅ›my siÄ™ schematu, Å¼e obserwowaliÅ›my zawsze jednÄ… konkretnÄ… wartoÅ›Ä‡. Popularne sÄ… takÅ¼e scentralizowane implementacje tego wzorca, gdzie mamy centralne miejsce zarzÄ…dzajÄ…ce powiadomieniami o zmianach wartoÅ›ci rÃ³Å¼nych zmiennych. Poznajmy przykÅ‚adowe i jak one dziaÅ‚ajÄ….
    </>
  ),
  keyword: 'wzorzec observer',
  categories: ['Programowanie'],
  tags: [
    "pub-sub",
    "publish-subscribe",
    "typescript",
    "javascript",
    "rxjs",
    "programowanie zdarzeniowe",
    "event loop",
    "event dispatcher"
  ],
  slug: 'scentralizowany-obserwator',
  updateTime: '2023-10-18T07:00:00+00:00',
  publishTime: '2023-10-18T07:00:00+00:00',
  cover,
};

## Uwaga wstÄ™pna

Tekst jest bezpoÅ›redniÄ… kontynuacjÄ… artykuÅ‚u *<Link href="/post/obserwator">Podstawy dziaÅ‚ania UI â€” wzorzec obserwator</Link>*. JeÅ›li go nie przeczytaÅ‚eÅ›(-aÅ›), polecam to nadrobiÄ‡, poniewaÅ¼ bÄ™dÄ™ zakÅ‚adaÄ‡, Å¼e tematy tam poruszone sÄ… Ci znane.

## Publish-Subscribe

OmawiajÄ…c poprzednio wzorzec obserwator, celowo pominÄ…Å‚em, Å¼e Banda Czterech jako synonim jego nazwy traktuje teÅ¼ *Publish-Subscribe* (po pol. *publikuj-subskrybuj*). Pod nazwÄ… *Publish-Subscribe* (lub w skrÃ³cie *Pub-Sub*; czasem stosuje siÄ™ w nazwach ukoÅ›nik zamiast myÅ›lnika) czÄ™Å›ciej kojarzy siÄ™ wzorzec architektoniczny, ktÃ³rego implementacjÄ… programowÄ… jest obserwator, aczkolwiek nieco inaczej zrobiony.

### Wzorzec architektoniczny

Zacznijmy od tego, czym jest wzorzec architektoniczny i czym siÄ™ rÃ³Å¼ni od projektowego. Idea jest podobna, tylko dotyczÄ… innego aspektu wytwarzania oprogramowania. O ile wzorce projektowe byÅ‚y zorientowane na kod i traktowaÅ‚y o klasach czy obiektach, tak wzorce architektoniczne sÄ… zorientowane na system informatyczny lub jego moduÅ‚y jako caÅ‚oÅ›Ä‡. OkreÅ›lajÄ… strukturÄ™, z jakich elementÃ³w siÄ™ skÅ‚ada, ich zakres funkcji, a takÅ¼e jak siÄ™ komunikujÄ… miÄ™dzy sobÄ….

RÃ³Å¼nice w uproszczeniu moÅ¼na by podsumowaÄ‡ nastÄ™pujÄ…co:

- Wzorce architektoniczne okreÅ›lajÄ… podziaÅ‚ i komunikacjÄ™. Nie dajÄ… konkretnych implementacji, tylko mÃ³wiÄ…, jak coÅ› ma dziaÅ‚aÄ‡.
- Wzorce projektowe pokazujÄ…, jak osiÄ…gnÄ…Ä‡ pewien cel. SÄ… konkretnymi implementacjami rozwiÄ…zujÄ…cymi pewien problem (niealgorytmiczny).

Warto podkreÅ›liÄ‡, Å¼e elementami okreÅ›lanymi przez wzorce architektoniczne mogÄ… byÄ‡ zarÃ³wno caÅ‚e serwery, aplikacje na nich, jak i moduÅ‚y w kodzie aplikacji. Dlatego teÅ¼, mimo Å¼e pokaÅ¼Ä™ tutaj wzorzec architektoniczny, jego ideÄ™ przeniesiemy na kod, ktÃ³ry bÄ™dzie bazowaÄ‡ na wzorcu projektowym. MoÅ¼e to brzmieÄ‡ nieco skomplikowanie, ale zobaczysz, Å¼e nie ma w tym nic strasznego.

### Architektura Pub-Sub

Skoro juÅ¼ wiemy, czym sÄ… wzorce architektoniczne, zobaczmy, czym jest architektura Pub-Sub.

Wzorzec Pub-Sub okreÅ›la, jak zrobiÄ‡ system, gdzie jednostki mogÄ… komunikowaÄ‡ siÄ™ miÄ™dzy sobÄ… w scentralizowany sposÃ³b. WyrÃ³Å¼niamy tutaj publikujÄ…cych i subskrybentÃ³w, miÄ™dzy ktÃ³rymi zachodzi komunikacja, i centralny element â€” broker wiadomoÅ›ci (lub kolejka komunikatÃ³w). Broker wiadomoÅ›ci posiada kanaÅ‚y (tematy), do ktÃ³rych publikujÄ…cy przesyÅ‚ajÄ… wiadomoÅ›ci, a subskrybenci je odbierajÄ…. Co istotne, ani publikujÄ…cy, ani subskrybenci nie muszÄ… wiedzieÄ‡ o sobie nawzajem â€” spektrum zainteresowania jest po prostu temat wiadomoÅ›ci.

ZauwaÅ¼, Å¼e mamy tutaj bardzo duÅ¼e podobieÅ„stwo do wzorca obserwator, gdzie jeden obiekt (temat) zmieniaÅ‚ swojÄ… wartoÅ›Ä‡ (wiÄ™c moÅ¼na zaÅ‚oÅ¼yÄ‡, Å¼e przesyÅ‚aÅ‚ wiadomoÅ›Ä‡), o czym informowaÅ‚ inny (obserwator). ZnaczÄ…ca rÃ³Å¼nica jest jednak taka, Å¼e w przypadku Pub-Sub publikujÄ…cy ani subskrybenci nie majÄ… bezpoÅ›redniej komunikacji miÄ™dzy sobÄ…. Jest natomiast centralna struktura, ktÃ³ra odbiera i przesyÅ‚a wiadomoÅ›ci. MoÅ¼na w zasadzie przyjÄ…Ä‡, Å¼e ta centralna struktura to taki temat *na sterydach*, bo zarzÄ…dza wieloma zmianami jednoczeÅ›nie.

<Image
  image={pubsub}
  alignCenter
  fullSize
  forceWhiteBackground={false}
  alt="Diagram z trzema swimlane'ami â€” publikujÄ…cy, broker i subskrybenci. Pokazane jest, Å¼e publikujÄ…cy komunikujÄ… siÄ™ z tematami skÅ‚adajÄ…cymi siÄ™ na brokera, a broker nastÄ™pnie przesyÅ‚a wiadomoÅ›ci do subskrybentÃ³w."
  caption={<>Diagram przedstawiajÄ…cy przykÅ‚adowÄ… architekturÄ™ Pub-Sub. ZwrÃ³Ä‡ uwagÄ™, Å¼e publikujÄ…cy mogÄ… publikowaÄ‡ w rÃ³Å¼nych kanaÅ‚ach, a subskrybenci mogÄ… siÄ™ subskrybowaÄ‡ do wielu.</>}
/>

Przy okazji warto jeszcze wspomnieÄ‡ o retencji wiadomoÅ›ci. O ile w klasycznym wzorcu obserwator mogliÅ›my pobraÄ‡ wartoÅ›Ä‡ w kaÅ¼dej chwili, tak tutaj nie jest to sprecyzowane. Oznacza to, Å¼e wiadomoÅ›Ä‡ znika z brokera zaraz po rozesÅ‚aniu do subskrybentÃ³w albo moÅ¼na w kaÅ¼dej chwili odczytaÄ‡ ostatniÄ… z nich bÄ…dÅº nawet kaÅ¼dÄ… opublikowanÄ…. Wszystko zaleÅ¼y od konkretnej implementacji, a kaÅ¼da z nich ma swoje wÅ‚asne zastosowania.

### Implementacje

Dlaczego jest to jednak wzorzec architektoniczny, a nie projektowy? Bo zaimplementowaÄ‡ to moÅ¼emy na wiele sposobÃ³w. Fakt, moÅ¼emy przerobiÄ‡ wzorzec obserwator do tego celu (co nawet zrobimy), ale implementowaÄ‡ go moÅ¼na takÅ¼e inaczej.

W kontekÅ›cie caÅ‚ego systemu informatycznego moÅ¼emy postawiÄ‡ serwer typu [RabbitMQ](https://www.rabbitmq.com/), ktÃ³ry bÄ™dzie kolejkÄ… wiadomoÅ›ci i jedne serwisy bÄ™dÄ… przesyÅ‚aÄ‡ do niej dane, inne odbieraÄ‡.

PatrzÄ…c szerzej niÅ¼ na zamkniÄ™ty system, implementacjÄ… Pub-Sub mogÄ… byÄ‡ newslettery. Mamy tu w koÅ„cu centralne miejsce, gdzie do interesujÄ…cego tematu rejestrujÄ… siÄ™ subskrybenci, a takÅ¼e mamy osobÄ™, ktÃ³ra publikuje wiadomoÅ›Ä‡. PublikujÄ…cy wiadomoÅ›Ä‡ nie wysyÅ‚a rÄ™cznie maila do kaÅ¼dej z osÃ³b, tylko przesyÅ‚a go do specjalnej usÅ‚ugi serwerowej (typu [Amazon SES](https://aws.amazon.com/ses/)), ktÃ³ra robi to za niego.

Jeszcze innÄ… implementacjÄ… wzorca Pub-Sub sÄ… serwisy spoÅ‚ecznoÅ›ciowe. Brokerem wiadomoÅ›ci jest wÃ³wczas sam serwis spoÅ‚ecznoÅ›ciowy, publikujÄ…cymi osoby, ktÃ³re na nim piszÄ…, tematami ich profile, a subskrybentami ich Å›ledzÄ…cy. Tutaj wspomnÄ™, Å¼e zawsze moÅ¼esz zostaÄ‡ subskrybentem mojego â€tematuâ€ na â€brokerachâ€ takich jak [Facebook](https://www.facebook.com/swistak.codes/), [Instagram](https://www.instagram.com/swistak.codes/) lub [LinkedIn](https://www.linkedin.com/in/tomasz-swistak/) ğŸ˜‰.

### Implementacja programowa

#### PomysÅ‚

Zaimplementujmy w takim razie programowÄ… wersjÄ™ Pub-Suba, korzystajÄ…c z uproszczonej implementacji wzorca obserwator, ktÃ³rÄ… pokazaÅ‚em <Link href="/post/obserwator/#implementacja-1">w poprzednim artykule</Link> ([link do oryginalnego Replit](https://replit.com/@tswistak/simplified-observer-ts#index.ts)). Zmienimy jÄ… w taki sposÃ³b, Å¼e `Subject` przerobimy na brokera wiadomoÅ›ci rozsyÅ‚ajÄ…cego komunikaty do subskrybentÃ³w tematu. Tym samym w funkcji subskrybujÄ…cej trzeba bÄ™dzie zdefiniowaÄ‡, jaki temat interesuje subskrybenta. W tej implementacji zrezygnujemy z przechowywania wiadomoÅ›ci, wiÄ™c nie bÄ™dzie funkcji `getState()`, natomiast zamiast `setState(newValue)` zrobimy `sendMessage(channel, message)`, ktÃ³ra rozeÅ›le komunikat do subskrybentÃ³w. Dla uproszczenia kodu kanaÅ‚y bÄ™dÄ… zwykÅ‚ymi ciÄ…gami znakÃ³w i nie bÄ™dziemy walidowaÄ‡ przy subskrypcji ani wysyÅ‚aniu wiadomoÅ›ci, czy wskazany kanaÅ‚ istnieje.

#### Implementacja w TypeScript

Zgodnie z powyÅ¼szym opisem poprzednio pokazany â€uproszczony obserwatorâ€ przerobiony na brokera wiadomoÅ›ci mÃ³gÅ‚by wyglÄ…daÄ‡ nastÄ™pujÄ…co:

```typescript
// typ funkcji subskrybenta
// otrzymuje od tematu wartoÅ›Ä‡ i nie musi nic zwrÃ³ciÄ‡
type Subscriber<T> = (value: T) => void;

// klasa brokera wiadomoÅ›ci, przerobiony Subject
class Broker<T> {
  // mapa tablic przechowujÄ…ca subskrybentÃ³w dla poszczegÃ³lnych kanaÅ‚Ã³w
  private subscribers = new Map<string, Subscriber<T>[]>();
  // metoda doÅ‚Ä…czajÄ…ca subskrybenta do kanaÅ‚u (odpowiednik attach)
  subscribe(channel: string, subscriber: Subscriber<T>) {
    // pobieramy istniejÄ…cÄ… listÄ™ subskrybentÃ³w dla kanaÅ‚u lub tworzymy nowÄ…
    const list = this.subscribers.get(channel) || [];
    // dodajemy subskrybenta do kanaÅ‚u
    list.push(subscriber);
    // aktualizujemy listÄ™ w mapie
    this.subscribers.set(channel, list);
  }
  // metoda usuwajÄ…ca subskrybenta (odpowiednik detach)
  unsubscribe(channel: string, subscriber: Subscriber<T>) {
    // pobieramy istniejÄ…cÄ… listÄ™ subskrybentÃ³w dla kanaÅ‚u lub tworzymy nowÄ…
    const list = this.subscribers.get(channel) || [];
    // odfiltrowujemy subskrybenta z tablicy
    this.subscribers.set(channel, list.filter(x => x !== subscriber));
  }
  // metoda wysyÅ‚ajÄ…ca wiadomoÅ›Ä‡ do subskrybentÃ³w (odpowiednik setState)
  sendMessage(channel: string, message: T) {
    // pobieramy istniejÄ…cÄ… listÄ™ subskrybentÃ³w dla kanaÅ‚u
    const list = this.subscribers.get(channel) || [];
    // wysyÅ‚amy wiadomoÅ›Ä‡ do kaÅ¼dego z listy
    list.forEach(send => send(message));
  }
}

// przykÅ‚ad uÅ¼ycia - zwiÄ™kszanie w pÄ™tli wartoÅ›ci licznika
// wiadomoÅ›ci bÄ™dziemy wysyÅ‚aÄ‡ na dwa rÃ³Å¼ne kanaÅ‚y
// tworzymy centralnego brokera rozsyÅ‚ajÄ…cego wiadomoÅ›ci typu number
const numberBroker = new Broker<number>();
// subskrybujemy siÄ™, aby wypisaÄ‡ liczby parzyste
numberBroker.subscribe('even', value => console.log('Parzysta', value));
// subskrybujemy siÄ™, aby wypisaÄ‡ liczby nieparzyste
numberBroker.subscribe('odd', value => console.log('Nieparzysta', value));
// wysyÅ‚amy liczby do brokera w pÄ™tli
for (let i = 0; i < 10; i++) {
  // sprawdzamy na podstawie parzystoÅ›ci, na ktÃ³ry kanaÅ‚ wysÅ‚aÄ‡ liczbÄ™
  const channel = i % 2 === 0 ? 'even' : 'odd'
  numberBroker.sendMessage(channel, i);
}
// po uruchomieniu w konsoli zostanÄ… wypisane kolejne liczby od 0 do 9
// wraz z informacjÄ… o parzystoÅ›ci
```

Kod moÅ¼esz przetestowaÄ‡ na [Replit](https://replit.com/@tswistak/centralized-observer-ts#index.ts). ZachÄ™cam do prÃ³by przerobienia kodu tak, aby broker przechowywaÅ‚ ostatniÄ… wiadomoÅ›Ä‡ w kanale w celu moÅ¼liwoÅ›ci niezaleÅ¼nego jej pobrania. W tym artykule teÅ¼ pominÄ™ implementacje w Kotlinie â€” rÃ³wnieÅ¼ zachÄ™cam do sprÃ³bowania przerobienia ich na wÅ‚asnÄ… rÄ™kÄ™.

#### PrzykÅ‚adowa implementacja w RxJS

W poprzednim artykule pokazaÅ‚em biblioteki od [ReactiveX](https://reactivex.io) jako popularne, gotowe implementacje wzorca obserwator. PrzeÅ‚Ã³Å¼my w takim razie powyÅ¼szÄ… implementacjÄ™ na [RxJS](https://github.com/ReactiveX/rxjs). Biblioteka ta nie wspiera kanaÅ‚Ã³w wiadomoÅ›ci, ale moÅ¼emy je zasymulowaÄ‡. Stworzymy obiekt wiadomoÅ›ci zawierajÄ…cy nazwÄ™ kanaÅ‚u i treÅ›Ä‡, a nastÄ™pnie przy subskrypcjach bÄ™dziemy je odpowiednio filtrowaÄ‡.

PrzykÅ‚adowa implementacja mogÅ‚aby wyglÄ…daÄ‡ nastÄ™pujÄ…co:

```typescript
import { Subject } from 'rxjs';
import { filter, map } from 'rxjs/operators';

// typ wiadomoÅ›ci przesyÅ‚anej do RxJS
type Message = {
  channel: string;
  message: number;
}
// tworzymy centralny temat
const centralSubject = new Subject<Message>();
// zrÃ³bmy funkcjÄ™ do wysyÅ‚ania wiadomoÅ›ci
function sendMessage(channel: string, message: number) {
  // przesyÅ‚amy wiadomoÅ›Ä‡ do tematu RxJS-owego
  centralSubject.next({ channel, message });
}
// przyda siÄ™ nam teÅ¼ funkcja zwracajÄ…ca przefiltrowanego obserwatora
function channel(name: string) {
  // zwracamy obserwatora, ktÃ³ry zawiera tylko wiadomoÅ›ci wskazanego typu
  // od razu teÅ¼ przemapowane, aby ukryÄ‡ wewnÄ™trznÄ… strukturÄ™
  return centralSubject.pipe(
    filter(msg => msg.channel === name),
    map(msg => msg.message)
  );
}
// przykÅ‚ad uÅ¼ycia - zwiÄ™kszanie w pÄ™tli wartoÅ›ci licznika
// wiadomoÅ›ci bÄ™dziemy wysyÅ‚aÄ‡ na dwa rÃ³Å¼ne kanaÅ‚y
// subskrybujemy siÄ™, aby wypisaÄ‡ liczby parzyste
channel('even').subscribe(value => console.log('Parzysta', value));
// subskrybujemy siÄ™, aby wypisaÄ‡ liczby nieparzyste
channel('odd').subscribe(value => console.log('Nieparzysta', value));
// wysyÅ‚amy liczby do brokera w pÄ™tli
for (let i = 0; i < 10; i++) {
  // sprawdzamy na podstawie parzystoÅ›ci, na ktÃ³ry kanaÅ‚ wysÅ‚aÄ‡ liczbÄ™
  const channel = i % 2 === 0 ? 'even' : 'odd'
  sendMessage(channel, i);
}
// po uruchomieniu w konsoli zostanÄ… wypisane kolejne liczby od 0 do 9
// wraz z informacjÄ… o parzystoÅ›ci
```

Kod moÅ¼esz przetestowaÄ‡ na [Replit](https://replit.com/@tswistak/centralized-observer-rxjs#index.ts).

## Zdarzenia

Na bazie wzorca Publish-Subscribe moÅ¼na oprzeÄ‡ styl architektury aplikacji znany jako architektura sterowana zdarzeniami (ang. event-driven architecture). Zdarzeniami nazywamy zajÅ›cie w systemie jakiejÅ› sytuacji, np. naciÅ›niÄ™cie przycisku myszy, restart serwera, nawiÄ…zanie nowego poÅ‚Ä…czenia.

W architekturze sterowanej zdarzeniami zamiast o przesyÅ‚aniu wiadomoÅ›ci mÃ³wimy o wywoÅ‚ywaniu zdarzeÅ„, publikujÄ…cy to producenci zdarzeÅ„, a subskrybenci to konsumenci. Tyle z opisu tego stylu, bo w zasadzie mÃ³gÅ‚bym powieliÄ‡ to, co pisaÅ‚em o pub-sub. W zasadzie w niektÃ³rych ÅºrÃ³dÅ‚ach wzorce te siÄ™ utoÅ¼samia ze sobÄ….

Nie chcÄ™ tu wchodziÄ‡ w kwestie architektury aplikacji, bo totalnie nie o tym jest ten wpis. Nas interesuje implementacja programowa, gdyÅ¼ o ile wczeÅ›niej nieco zaimprowizowaliÅ›my kanaÅ‚y wiadomoÅ›ci, tak w przypadku zdarzeÅ„ mechanizmy te sÄ… czÄ™Å›ciÄ… jÄ™zykÃ³w programowania lub frameworkÃ³w do nich (chociaÅ¼ moÅ¼emy pisaÄ‡ teÅ¼ wÅ‚asne).

### Programowanie zdarzeniowe

ImplementujÄ…c w kodzie architekturÄ™ sterowanÄ… zdarzeniami, skorzystamy z tzw. programowania zdarzeniowego. Jest to paradygmat programowania, w ktÃ³rym dziaÅ‚anie aplikacji, jej przepÅ‚yw sterowania, jest oparte na reagowaniu na zdarzenia. SzczegÃ³lnie czÄ™sto spotyka siÄ™ go tam, gdzie programujemy interfejsy uÅ¼ytkownika, ktÃ³re majÄ… reagowaÄ‡ na akcje uÅ¼ytkownika, chociaÅ¼ zdarzenia nie muszÄ… pochodziÄ‡ z akcji uÅ¼ytkownika, a mogÄ… nawet byÄ‡ wywoÅ‚ane przez inny moduÅ‚ aplikacji.

W programowaniu zdarzeniowym moÅ¼emy wyrÃ³Å¼niÄ‡ dwa komponenty, dziÄ™ki ktÃ³rym to wszystko dziaÅ‚a i moÅ¼emy pisaÄ‡ aplikacje w taki sposÃ³b:

- PÄ™tla zdarzeÅ„ (event loop) â€” jest to pÄ™tla dziaÅ‚ajÄ…ca w gÅ‚Ã³wnym wÄ…tku aplikacji, ktÃ³ra tak dÅ‚ugo, jak system przekazuje do aplikacji komunikaty (zdarzenia), przetwarza je i przekazuje dalej. Dzisiaj w wiÄ™kszoÅ›ci przypadkÃ³w jej nie zobaczysz na wÅ‚asne oczy, poniewaÅ¼ jest ukryta wewnÄ…trz frameworkÃ³w, stanowiÄ…c ich podstawÄ™. Aczkolwiek jeÅ›li ciekawi CiÄ™, jak to wyglÄ…da pod spodem, moÅ¼esz zobaczyÄ‡ np. przykÅ‚ady uÅ¼ycia `GetMessage()` z WinAPI (np. [w dokumentacji WinAPI](https://learn.microsoft.com/pl-pl/windows/win32/api/winuser/nf-winuser-getmessage) lub [na Wikipedii](https://en.wikipedia.org/wiki/Message_loop_in_Microsoft_Windows)). Bardziej abstrakcyjny przykÅ‚ad pokaÅ¼Ä™ dalej w artykule.
- Event handlery (nie wiem, jak siÄ™ to tÅ‚umaczy na jÄ™zyk polski â€” agenci zdarzeÅ„? opiekunowie zdarzeÅ„? â€obsÅ‚ugiwaczeâ€ zdarzeÅ„?) â€” (najczÄ™Å›ciej) funkcje obsÅ‚ugujÄ…ce konkretne zdarzenia zachodzÄ…ce w pÄ™tli.

Zwykle w opisach programowania zdarzeniowego nie wymienia siÄ™ tego, poniewaÅ¼ nie jest to obowiÄ…zkowy element, aczkolwiek ja bym wyrÃ³Å¼niÅ‚ jeszcze dyspozytora zdarzeÅ„ (ang. event dispatcher). Pod tÄ… nazwÄ… rozumiem obiekt, do ktÃ³rego trafiajÄ… informacje o zdarzeniach i ktÃ³ry nastÄ™pnie rozsyÅ‚a je do konsumentÃ³w. Jest to odpowiednik brokera wiadomoÅ›ci w programowaniu zdarzeniowym. W zasadzie gdybyÅ›my mieli implementowaÄ‡ go samodzielnie, zrobilibyÅ›my to w dokÅ‚adnie taki sam sposÃ³b, jak pokazaÅ‚em powyÅ¼ej w implementacji programowej wzorca pub-sub. Dyspozytor moÅ¼e byÄ‡ jeden lub wiele wyspecjalizowanych (np. kaÅ¼dy komponent interfejsu ma wÅ‚asny).

### Schemat frameworkÃ³w

Schemat (w pseudokodzie) frameworka implementujÄ…cego programowanie zdarzeniowe wyglÄ…da nastÄ™pujÄ…co:

```javascript
// gÅ‚Ã³wna funkcja aplikacji
function main() {
    // dyspozytor zdarzeÅ„ moÅ¼e byÄ‡ np. jeden na caÅ‚Ä… aplikacjÄ™
    const dispatcher = new EventDispatcher();
    // uruchamiamy kod aplikacji, przekazujÄ…c dyspozytora zdarzeÅ„
    // w tej funkcji aplikacja powinna zarejestrowaÄ‡ konsumentÃ³w
    bootstrapApp(dispatcher);
    // wszystko odbywa siÄ™ w nieskoÅ„czonej pÄ™tli zdarzeÅ„
    while (true) {
        // pobieramy zdarzenie systemowe (funkcja wymyÅ›lona)
        const systemEvent = getSystemEvent();
        // zakÅ‚adamy, Å¼e system moÅ¼e wysÅ‚aÄ‡ zdarzenie wyÅ‚Ä…czajÄ…ce aplikacjÄ™
        // przykÅ‚adem takiego zdarzenia w systemach Uniksowych jest SIGTERM
        if (systemEvent == 'SIGTERM') {
            // w takim przypadku przerywamy pÄ™tlÄ™
            break;
        }
        // w innych przypadkach przetwarzamy zdarzenie systemowe na zrozumiaÅ‚e dla aplikacji
        const event = processEvent(systemEvent);
        // i wysyÅ‚amy zdarzenie do dyspozytora,
        // aby aplikacja wykonaÅ‚a odpowiedniÄ… akcjÄ™
        dispatcher.dispatch(event);
    }
}
```

Jednak tak jak wspomniaÅ‚em wczeÅ›niej, moÅ¼liwe, Å¼e nigdy nie doÅ›wiadczysz takiego kodu. NiezaleÅ¼nie, czy piszesz aplikacjÄ™ na komputery, smartfony, czy webowÄ…, raczej skorzystasz z gotowego frameworka, ktÃ³ry zrobi to za Ciebie. PodstawÄ… jest wtedy dowiedzieÄ‡ siÄ™, jak wyglÄ…da przekazywanie zdarzeÅ„ i konsumowanie ich, bo to podstawa interakcji na graficznych interfejsach.

### Programowanie zdarzeniowe w JavaScript

W przypadku aplikacji webowych mÃ³wimy najczÄ™Å›ciej o JavaScript, gdzie pÄ™tla zdarzeÅ„ jest wbudowana w przeglÄ…darki internetowe i wykorzystujemy wbudowany dyspozytor zdarzeÅ„ do oprogramowania caÅ‚ej interakcji, bez jakiegokolwiek frameworka.

#### Wykorzystanie wbudowanego dyspozytora zdarzeÅ„

W przeglÄ…darkowym JavaScripcie dyspozytorzy zdarzeÅ„ to obiekty implementujÄ…ce interfejs [`EventTarget`](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget). Jest nimi sporo rzeczy, z ktÃ³rymi mamy do czynienia, m.in. elementy HTML-owe, caÅ‚y dokument (`Document`), okno przeglÄ…darki (`Window`). Implementacje `EventTarget` powinny zawieraÄ‡:

- moÅ¼liwoÅ›Ä‡ rejestracji konsumentÃ³w (obserwatorÃ³w) â€” `addEventListener()`,
- wyrejestrowywanie konsumentÃ³w â€” `removeEventListener()`,
- coÅ›, o czym mniej osÃ³b wie: moÅ¼liwoÅ›Ä‡ publikowania zdarzeÅ„ â€” `dispatchEvent()`. Czasem jednak zdarza siÄ™, Å¼e nie mamy dostÄ™pu do obiektu typu `EventTarget`, ale udostÄ™pniany jest [`MessagePort`](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort). WÃ³wczas moÅ¼emy przesÅ‚aÄ‡ wiadomoÅ›Ä‡ przy uÅ¼yciu `postMessage()`, co skutkuje opublikowaniem wydarzenia.

MÃ³wiÄ…c w skrÃ³cie, przeglÄ…darka przechwytuje zdarzenie systemowe, po czym przekazuje je do wÅ‚aÅ›ciwego dyspozytora zdarzeÅ„. NaciÅ›niesz przycisk, to zdarzenie zostanie przekazane do niego i do obiektÃ³w nadrzÄ™dnych w jego strukturze (elementy HTML-owe sÄ… ustrukturyzowane w drzewo [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)). WykorzystujÄ…c ten fakt, moÅ¼emy zdarzeniami zaprogramowaÄ‡ interakcjÄ™ w aplikacji. Co wiÄ™cej, moÅ¼emy publikowaÄ‡ teÅ¼ wÅ‚asne zdarzenia, co jest przydatne, np. w komunikacji miÄ™dzy oknami przeglÄ…darki (w tym takÅ¼e ramkami z innymi stronami) czy oddzielnymi wÄ…tkami aplikacji ([Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)).

W artykule skupiamy siÄ™ na graficznych interfejsach, stÄ…d mÃ³wiÄ™ o przeglÄ…darkowym JavaScript. Warto jednak dodaÄ‡, Å¼e serwerowe rozwiÄ…zania oparte na JavaScript, jak Node.js, rÃ³wnieÅ¼ posiadajÄ… wbudowane mechanizmy zarzÄ…dzania zdarzeniami (np. [`EventEmitter`](https://nodejs.org/api/events.html) w Node.js). PominÄ™ je w tym artykule.

#### Scentralizowany?

MoÅ¼esz teraz zadaÄ‡ doÅ›Ä‡ trafne pytanie â€” skoro mamy wyspecjalizowany emiter zdarzeÅ„ na kaÅ¼dym elemencie, to czy dalej jest to scentralizowany obserwator? To juÅ¼ zaleÅ¼y od interpretacji. MoÅ¼na uznaÄ‡, Å¼e nie jest scentralizowany, ale na pewno jest wielozadaniowy, implementujÄ…c podobne zaÅ‚oÅ¼enia do tego, co pokazaÅ‚em wczeÅ›niej przy okazji Publish-Subscribe.

Dlatego teÅ¼, mimo Å¼e nie jest to do koÅ„ca scentralizowana wersja obserwatora jak obiecaÅ‚ tytuÅ‚ artykuÅ‚u, stwierdziÅ‚em, Å¼e warto o tym opowiedzieÄ‡. SzczegÃ³lnie Å¼e jest mocno powiÄ…zana z tym, w jaki sposÃ³b dziaÅ‚ajÄ… interfejsy uÅ¼ytkownika, a od tego zaczÄ…Å‚em caÅ‚e opowiadanie na temat wykorzystania wzorca obserwator.

#### PrzykÅ‚ad wykorzystania

DoÅ›Ä‡ teoretyzowania. Zobaczmy, jak to wszystko wyglÄ…da w kodzie. PostaraÅ‚em siÄ™ napisaÄ‡ kod, ktÃ³ry zawiera wszystkie opisane powyÅ¼ej rzeczy, czyli:

- ustawia zdarzenia,
- wysyÅ‚a wÅ‚asne zdarzenia (w tym wykorzystujÄ…c `postMessage()`).

Usuwanie zdarzeÅ„ pominÄ…Å‚em, ale warto pamiÄ™taÄ‡ o nim, szczegÃ³lnie gdy konsumentÃ³w tworzymy w efektach (wyjaÅ›nienie terminu: patrz poprzedni artykuÅ‚), co jest doÅ›Ä‡ powszechne przy pisaniu kodu z uÅ¼yciem frameworkÃ³w.

CzÄ™Å›Ä‡ HTML potrzebna do dziaÅ‚ania kodu:

```html
<body>
  <div id="root">
    <div>Licznik:</div>
    <div id="counter">0</div>
    <button id="increase">ZwiÄ™ksz wartoÅ›Ä‡</button>
    <button id="send-to-child">PrzekaÅ¼ wartoÅ›Ä‡ do ramki niÅ¼ej</button>
    <!-- ramka symulujÄ…ca zewnÄ™trznÄ… zawartoÅ›Ä‡ -->
    <iframe
      id="child-frame"
      srcdoc="<div id='text' style='text-align:center;'></div>
      <script>
        // odbieramy wiadomoÅ›Ä‡ przekazanÄ… z zewnÄ…trz
        // nasÅ‚uchujÄ…c na zdarzenie 'message'
        window.addEventListener('message', (event) => {
          // wpisujemy zawartoÅ›Ä‡ wiadomoÅ›ci do elementu text
          document.getElementById('text').innerText = event.data;
        })
      </script>"
    ></iframe>
  </div>
</body>

```

WÅ‚aÅ›ciwy kod w JavaScript:

```javascript
// dla uproszczenia wyciÄ…gnijmy do zmiennych elementy widoku
const counter = document.getElementById('counter');
const increaseBtn = document.getElementById('increase');
const sendBtn = document.getElementById('send-to-child');
const child = document.getElementById('child-frame');

// tworzymy nasÅ‚uchiwanie na wÅ‚asne zdarzenie 'increase'
// utworzymy je w obiekcie dokumentu
document.addEventListener('increase', () => {
  // pobieramy aktualnÄ… zawartoÅ›Ä‡ licznika
  const value = parseInt(counter.innerText);
  // wyÅ›wietlamy zwiÄ™kszonÄ… wartoÅ›Ä‡
  counter.innerText = value + 1;
});

// dodajemy nasÅ‚uchiwanie na zdarzenie klikniÄ™cia
// na przycisku zwiÄ™kszania licznika
// zrobimy to w jego dyspozytorze zdarzeÅ„
increaseBtn.addEventListener('click', () => {
  // przeÅ›lijmy do dyspozytora zdarzeÅ„ wÅ‚asne zdarzenie 'increase'
  document.dispatchEvent(new CustomEvent('increase'));
});

// analogicznie jak wyÅ¼ej dla przycisku przesÅ‚ania
sendBtn.addEventListener('click', () => {
  // wyÅ›lijmy wiadomoÅ›Ä‡ do ramki (na zewnÄ…trz)
  // przeÅ›lemy zawartoÅ›Ä‡ licznika
  child.contentWindow.postMessage(counter.innerText);
});

```

CaÅ‚oÅ›Ä‡ kodu w wersji interaktywnej znajdziesz na [StackBlitz](https://stackblitz.com/edit/js-ay2emb?file=index.js).

Z czysto kronikarskiego obowiÄ…zku dodam, Å¼e o ile mechanizm tworzenia wÅ‚asnych zdarzeÅ„ i ich przesyÅ‚ania istnieje w JavaScripcie, tak przez wiele lat pracy komercyjnej w tym jÄ™zyku bardzo rzadko widziaÅ‚em jego zastosowania, wiÄ™c traktujÄ™ to jako ciekawostkÄ™. Raczej, w razie potrzeby, stosuje siÄ™ wÅ‚asne implementacje dyspozytora zdarzeÅ„, np. bazujÄ…ce na RxJS. JeÅ›li potrzebowaÅ‚byÅ›/potrzebowaÅ‚abyÅ› takiej, wystarczy przerobiÄ‡ kod, ktÃ³ry pokazaÅ‚em na poczÄ…tku artykuÅ‚u â€” w koÅ„cu przesyÅ‚anie wiadomoÅ›ci a przesyÅ‚anie zdarzeÅ„ to dokÅ‚adnie ten sam mechanizm. WidaÄ‡ to nawet dosÅ‚ownie powyÅ¼ej, gdy przesyÅ‚aliÅ›my wiadomoÅ›Ä‡ do zewnÄ™trznej strony (zawartej w ramce), co tak naprawdÄ™ byÅ‚o wywoÅ‚aniem dyspozytora zdarzeÅ„, tylko z odgÃ³rnie ustalonym zdarzeniem.

## Podsumowanie

NazywajÄ…c podchwytliwie poprzedni artykuÅ‚ â€podstawy dziaÅ‚ania UIâ€, przedstawiÅ‚em najbardziej bazowÄ… wersjÄ™ wzorca obserwator, ktÃ³ra raczej nie stoi typowo za dziaÅ‚aniem UI, co za jego reaktywnoÅ›ciÄ… wzglÄ™dem danych. To, co poznaliÅ›my teraz, jest juÅ¼ dosÅ‚ownie podstawÄ… interfejsÃ³w. Na zdarzeniach i ich oprogramowywaniu opiera siÄ™ w zasadzie kaÅ¼dy graficzny interfejs. A samo przesyÅ‚anie zdarzeÅ„ jest na tyle toÅ¼same z ideÄ… Publish-Subscribe, ktÃ³ra juÅ¼ w ogÃ³le nie ma typowo powiÄ…zaÅ„ z tematem UI, Å¼e warto byÅ‚o teÅ¼ i o tym wspomnieÄ‡.

Warto znaÄ‡ obie strony, bo tworzÄ…c interfejsy, na pewno skorzystasz z wbudowanych dyspozytorÃ³w do zaprogramowania podstawowych interakcji, ale do przesyÅ‚ania danych miÄ™dzy rÃ³Å¼nymi elementami aplikacji napiszesz raczej wÅ‚asne mechanizmy pub-sub. Czasami taki centralny dyspozytor/broker moÅ¼e siÄ™ lepiej sprawdziÄ‡ niÅ¼ wiele tematÃ³w/signalsÃ³w. Jednak decyzja co, gdzie i kiedy uÅ¼ywaÄ‡ zaleÅ¼y caÅ‚kowicie od projektu, potrzeby w nim i programistÃ³w, ktÃ³rzy za nim stojÄ….

## Literatura

- Keeling M., â€Wzorzec publish-subscribeâ€ w *ZostaÅ„ Architektem Oprogramowania*. Wydawnictwo Naukowe PWN SA, Warszawa 2019, s. 97-98
- Richards M., Ford N., â€Event-Driven Architecture Styleâ€ w *Fundamentals of Software Architecture*. O'Reilly Media, 2020, s. 179-209
- Gautam S., *Publisher-Subscriber (An Architectural Design Pattern)*, https://www.enjoyalgorithms.com/blog/publisher-subscriber-pattern (ostatni dostÄ™p: 16.10.2023)
- *What is Pub/Sub? The Publish/Subscribe model explained*, https://ably.com/topic/pub-sub (ostatni dostÄ™p: 16.10.2023)
- *Publisher-Subscriber Model*, https://www.baeldung.com/cs/publisher-subscriber-model (ostatni dostÄ™p: 16.10.2023)
- *Publisher-Subscriber pattern*, https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber (ostatni dostÄ™p: 16.10.2023)
- *Event-driven architecture style*, https://learn.microsoft.com/en-us/azure/architecture/guide/architecture-styles/event-driven (ostatni dostÄ™p: 16.10.2023)
- *Event-driven programming*, https://en.wikipedia.org/w/index.php?title=Event-driven_programming&oldid=1174274696 (ostatni dostÄ™p: 16.10.2023)
- *Event (computing)*, https://en.wikipedia.org/w/index.php?title=Event_(computing)&oldid=1174422514  (ostatni dostÄ™p: 16.10.2023)
- *Event loop*, https://en.wikipedia.org/w/index.php?title=Event_loop&oldid=1146557835 (ostatni dostÄ™p: 16.10.2023)

<small>ZdjÄ™cie na okÅ‚adce wygenerowane przez Stable Diffusion.</small>
