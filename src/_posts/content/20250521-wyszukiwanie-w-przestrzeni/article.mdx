import Link from 'next/link';
import { Image } from '@swistak-codes/components';
import cover from './swistak_poszukiwacz_skarbow.webp';
import { Presentation } from './presentation';
import quadtree from './quadtree.png';
import octree from './Octree2.png';

export const meta = {
  title: 'Wyszukiwanie obiektÃ³w w przestrzeni',
  abstract:
    'ArtykuÅ‚ przedstawia algorytmy wyszukiwania obiektÃ³w w przestrzeni, ktÃ³re sÄ… wykorzystywane w rÃ³Å¼nych dziedzinach, takich jak np. gry komputerowe.',
  firstParagraph: (
    <>
      Podczas nauki algorytmiki jednym z pierwszych algorytmÃ³w, ktÃ³re poznajemy, jest <Link href="/post/wyszukiwanie-w-listach">wyszukiwanie binarne</Link> pokazujÄ…ce jak sprytnie szukaÄ‡ danych w posortowanej liÅ›cie. PÃ³Åºniej poznajemy <Link href="/post/przechodzenie-po-grafie">algorytmy wyszukiwania w grafach</Link>, z czego naturalnie przechodzi siÄ™ do <Link href="/post/szukanie-najkrotszych-sciezek-w-grafie">wyszukiwania Å›cieÅ¼ek</Link>. Jednak tym razem spÃ³jrzmy na jeszcze inny rodzaj wyszukiwania, ktÃ³ry moÅ¼e byÄ‡ przydatny przykÅ‚adowo przy programowaniu gier. A jest to wyszukiwanie obiektÃ³w w przestrzeni. W artykule przedstawiam przykÅ‚adowe podejÅ›cia do tego problemu, ograniczajÄ…c siÄ™ do przestrzeni dwuwymiarowej.
    </>
  ),
  keyword: 'wyszukiwanie',
  categories: ['Algorytmy', 'Gry'],
  tags: [
    'quadtree',
    'drzewo czwÃ³rkowe',
    'spatial hash',
    'haszowanie przestrzenne',
    'wyszukiwanie binarne',
    'typescript',
  ],
  slug: 'wyszukiwanie-w-przestrzeni',
  updateTime: '2025-05-21T07:00:00+00:00',
  publishTime: '2025-05-21T07:00:00+00:00',
  cover,
};

## Wprowadzenie do problemu

### Co nas interesuje?

W problemie, ktÃ³ry rozpatrzymy w tym artykule, zakÅ‚adamy nastÄ™pujÄ…co:

- Mamy listÄ™ obiektÃ³w umieszczonych w przestrzeni dwuwymiarowej.
- KaÅ¼dy obiekt zawiera informacjÄ™ o swoim poÅ‚oÅ¼eniu w przestrzeni i rozmiarze.

To, co chcemy zrobiÄ‡, to mieÄ‡ szybki sposÃ³b, aby sprawdziÄ‡, ktÃ³ry obiekt znajduje siÄ™ w danym miejscu w przestrzeni. PrzykÅ‚adowo, jeÅ›li mamy grÄ™, w ktÃ³rej poruszamy siÄ™ po planszy, chcemy wiedzieÄ‡, czy w danym miejscu znajduje siÄ™ przeszkoda, czy nie.

Co wiÄ™cej, w przypadku tego problemu interesuje nas nie tylko sprawdzenie konkretnego punktu. CzÄ™sto, w zaleÅ¼noÅ›ci od potrzeb, interesujÄ… nas takÅ¼e:

- Wszystkie obiekty znajdujÄ…ce siÄ™ w pewnej odlegÅ‚oÅ›ci (promieniu) od danego punktu.
- Wszystkie obiekty znajdujÄ…ce siÄ™ w danym prostokÄ…cie. Tutaj moÅ¼emy rozbiÄ‡ to na dwa problemy:
    - Znalezienie wszystkich obiektÃ³w, ktÃ³re sÄ… w caÅ‚oÅ›ci w danym prostokÄ…cie.
    - Znalezienie wszystkich obiektÃ³w, ktÃ³re nawet czÄ™Å›ciowo zawierajÄ… siÄ™ w danym prostokÄ…cie.

### Zastosowania

Zanim przejdziemy do konkretnych struktur i algorytmÃ³w, powiedzmy sobie, jakie zastosowania majÄ… te algorytmy. PrzykÅ‚adowe to:

- **OkreÅ›lenie, co rysujemy na ekranie** â€” aby nie rysowaÄ‡ obiektÃ³w, ktÃ³re nie zmieszczÄ… siÄ™ na ekranie uÅ¼ytkownika.
- **Kolizje** â€” pozwolÄ… okreÅ›liÄ‡, czy dwa obiekty siÄ™ ze sobÄ… stykajÄ…, co jest przydatne w grach.
- **Wykrywanie klikniÄ™Ä‡** â€” skoro w ten sposÃ³b wykryjemy kolizje, to takÅ¼e dziÄ™ki temu moÅ¼emy okreÅ›liÄ‡, w ktÃ³ry obiekt aktualnie klikamy myszkÄ….
- **OkreÅ›lenie pola widzenia** â€” przez wyszukiwanie obiektÃ³w w danym promieniu moÅ¼emy okreÅ›liÄ‡, co widzi nasz bohater w grze.

PrzykÅ‚adÃ³w zastosowaÅ„ jest zdecydowanie wiÄ™cej. Te przedstawione powyÅ¼ej sÄ… typowo ze Å›wiata gier komputerowych, ale inne dziedziny rÃ³wnieÅ¼ wykorzystujÄ… te techniki. MogÄ… byÄ‡ wykorzystywane np. w przetwarzaniu obrazÃ³w, przechowywaniu <Link href="/post/macierze-rzadkie">danych rzadkich</Link> czy w bazach danych (przestrzenne bazy danych).

## Rozgrzewka

Zanim przejdÄ™ do opisu struktur, czas na maÅ‚Ä… rozgrzewkÄ™. PoniÅ¼ej znajdziesz siatkÄ™ o wymiarach 16Ã—16, co daje Å‚Ä…cznie 256 pÃ³l. Wybierz sobie w gÅ‚owie jedno z nich. NastÄ™pnie pozwÃ³l komputerowi w prostej zabawie poniÅ¼ej zgadnÄ…Ä‡, ktÃ³re pole masz na myÅ›li. Po rozpoczÄ™ciu wybierz przyciskami, czy wybrane przez Ciebie pole jest zamalowane na czerwono, czy teÅ¼ znajduje siÄ™ w jednym z zakolorowanych pÃ³l. Mimo Å¼e wszystkich pÃ³l jest 256, jestem przekonany, Å¼e komputer znajdzie wybrane przez Ciebie pole maksymalnie w 5 ruchach. SprawdÅº poniÅ¼ej, czy miaÅ‚em racjÄ™.

<Presentation />

JeÅ›li powyÅ¼sza zabawa skojarzyÅ‚a Ci siÄ™ ze <Link href="/post/wyszukiwanie-w-listach/#wyszukiwanie-binarne">strategiÄ… â€dziel i zwyciÄ™Å¼ajâ€ i wyszukiwaniem binarnym</Link>, to bardzo dobrze, bo robimy tutaj dokÅ‚adnie to samo, tylko na dwÃ³ch wymiarach. Z tego teÅ¼ powodu, zamiast dzieliÄ‡ listÄ™ na pÃ³Å‚, dzielimy obszar na Ä‡wiartki (czyli dzielimy na pÃ³Å‚ w pionie i poziomie, co daje 4 oddzielne obszary). W ten sposÃ³b moÅ¼emy znaleÅºÄ‡ odpowiednie pole w maksymalnie $$log_2(n) + 1$$ ruchach, gdzie $$n$$ to dÅ‚ugoÅ›Ä‡ boku planszy ($$+ 1$$ wynika z tego, Å¼e liczymy liczbÄ™ ruchÃ³w, a nie iteracji algorytmu).

Niestety, mimo Å¼e szukamy tutaj binarnie, uÅ¼ywanie tablicy nie jest praktyczne. Dlatego skupimy siÄ™ w tym artykule na wyspecjalizowanych strukturach danych, ktÃ³re sÄ… proste w uÅ¼yciu, a jednoczeÅ›nie pozwalajÄ… na szybkie przeszukiwanie przestrzeni.

## Drzewo czwÃ³rkowe

PierwszÄ… strukturÄ…, z ktÃ³rÄ… siÄ™ zapoznamy, jest drzewo czwÃ³rkowe (po ang. quadtree). ZostaÅ‚a opisana w 1974 r. przez R. Finkela i J.L. Bentleya. Od razu zaznaczÄ™, Å¼e sÄ… rÃ³Å¼ne typy drzew czwÃ³rkowych. To, co opiszÄ™ poniÅ¼ej, to drzewo czwÃ³rkowe punktowo-obszarowe (po ang. point-region quadtree).

### Idea

Na pewno kojarzysz takÄ… strukturÄ™ jak binarne drzewo poszukiwaÅ„ (w skrÃ³cie: BST; nie do koÅ„ca poprawnie nazywanÄ… teÅ¼ drzewem binarnym). JeÅ›li jej nie znasz, to opisaÅ‚em jÄ… <Link href="https://swistak.codes/post/sortowanie-cz-7-inne-podejscia/#binarne-drzewo-poszukiwa%C5%84">w artykule o sortowaniu, gdzie omÃ³wiÅ‚em wykorzystujÄ…ce jÄ… sortowanie drzewiaste</Link>.

W skrÃ³cie, w BST kaÅ¼dy wÄ™zeÅ‚ ma zawsze co najwyÅ¼ej dwÃ³jkÄ™ dzieci, gdzie lewy potomek zawiera wartoÅ›Ä‡ mniejszÄ… od aktualnej, a prawy wiÄ™kszÄ…. Oddaje to w istocie sposÃ³b, jak wykonujemy wyszukiwanie binarne.

Drzewo czwÃ³rkowe dziaÅ‚a analogicznie. WÄ™zeÅ‚ drzewa ma co najwyÅ¼ej czwÃ³rkÄ™ dzieci i te reprezentujÄ… coraz to mniejsze regiony opisywanego obszaru w przestrzeni dwuwymiarowej. Oddaje to w prawie dosÅ‚owny sposÃ³b pokazywanÄ… przeze mnie w prezentacji ideÄ™. RÃ³Å¼nica wzglÄ™dem prezentacji jest taka, Å¼e wÄ™zeÅ‚ nie reprezentuje pojedynczego elementu, tylko obszar. Oznacza to tyle, Å¼e w wÄ™Åºle moÅ¼e byÄ‡ zapisanych wiele elementÃ³w albo Å¼aden â€” wszystko zaleÅ¼y od tego, jak bardzo chcemy dzieliÄ‡ obszary.

### Operacje na drzewie czwÃ³rkowym

Z powyÅ¼szego opisu na razie dowiedzieliÅ›my siÄ™, jaka idea stoi za drzewem czwÃ³rkowym. Jednak nie mÃ³wi ona o tym, jak dokÅ‚adnie z tego drzewa korzystaÄ‡. Zapoznajmy siÄ™ wiÄ™c z podejÅ›ciem do konkretnych operacji.

#### Dodawanie elementÃ³w

Zacznijmy od tego, jak dodawaÄ‡ elementy do drzewa. W przypadku binarnego drzewa przeszukiwaÅ„ sprawa jest prosta, bo jeden wÄ™zeÅ‚ to jedna wartoÅ›Ä‡. Tutaj wÄ™zeÅ‚ reprezentuje obszar. Jak w tym przypadku operujemy?

Idea opisywanego przeze mnie drzewa punktowo-obszarowego jest taka, Å¼e drzewo ma odgÃ³rnie narzuconÄ… pojemnoÅ›Ä‡ wÄ™zÅ‚a. Oznacza to tyle, Å¼e tak dÅ‚ugo, jak nie przekroczymy pojemnoÅ›ci, to dodajemy elementy do aktualnego wÄ™zÅ‚a. JeÅ›li natomiast pojemnoÅ›Ä‡ zostaÅ‚a przekroczona, dzielimy wÄ™zeÅ‚ na cztery mniejsze i rozdzielamy elementy na mniejsze obszary. Z zasady, jeÅ›li wÄ™zeÅ‚ jest podzielony na mniejsze, nie trzymamy juÅ¼ w nim Å¼adnych elementÃ³w\*. Innymi sÅ‚owy: elementy zawierajÄ… jedynie liÅ›cie drzewa.

W praktyce wyglÄ…da to mniej wiÄ™cej tak:

1. Sprawdzamy, czy obiekt, ktÃ³ry chcemy dodaÄ‡, przecina obszar aktualnego wÄ™zÅ‚a. JeÅ›li nie, koÅ„czymy wykonanie algorytmu; jeÅ›li tak, kontynuujemy.
2. Sprawdzamy, czy aktualny wÄ™zeÅ‚ jest podzielony na mniejsze.
    1. JeÅ›li nie jest, sprawdzamy, czy aktualna liczba elementÃ³w w liÅ›cie jest poniÅ¼ej limitu.
        1. JeÅ›li jest poniÅ¼ej limitu, dodajemy element do listy.
        2. JeÅ›li liczba elementÃ³w jest rÃ³wna limitowi:
            1. Dzielimy aktualny obszar na cztery mniejsze, przypisujemy je do nowych wÄ™zÅ‚Ã³w i ustawiamy jako dzieci aktualnego wÄ™zÅ‚a.
            2. Przekazujemy elementy zapisane w aktualnym wÄ™Åºle i nowo dodawany do wszystkich dzieci (tym samym powtarzamy algorytm od poczÄ…tku, ale na kaÅ¼dym z dzieci).
            3. CzyÅ›cimy listÄ™ elementÃ³w.
    2. JeÅ›li jest podzielony, wykonujemy operacjÄ™ dodawania na wszystkich dzieciach.

W ten prosty, rekurencyjny sposÃ³b jesteÅ›my w stanie dodaÄ‡ elementy do odpowiednich wÄ™zÅ‚Ã³w, a takÅ¼e w razie potrzeby utworzyÄ‡ nowe wÄ™zÅ‚y.

PrzykÅ‚adowe drzewo czwÃ³rkowe zawierajÄ…ce 20 elementÃ³w moÅ¼e wyglÄ…daÄ‡ tak:

<Image
  image={quadtree}
  alignCenter
  fullSize
  alt="Schemat drzewa czwÃ³rkowego dla obszaru 512x512. KorzeÅ„ dzieli siÄ™ na 4 regiony, z ktÃ³rych NE i SE zawierajÄ… dalsze podziaÅ‚y. WÄ™zÅ‚y opisujÄ… wspÃ³Å‚rzÄ™dne i liczbÄ™ obiektÃ³w lub sÄ… oznaczone jako puste."
  caption={<>
    PrzykÅ‚adowe drzewo czwÃ³rkowe z 20 elementami (polecam kliknÄ…Ä‡, aby powiÄ™kszyÄ‡).<br />
    Nazwy wierzchoÅ‚kÃ³w wskazujÄ… na kierunek, ktÃ³ry Ä‡wiartka opisuje, np. SE to Ä‡wiartka poÅ‚udniowo-wschodnia. WÄ™zÅ‚y zawierajÄ…ce elementy sÄ… oznaczone na zielono, a puste na szaro. WÄ™zÅ‚y podzielone na mniejsze sÄ… oznaczone na pomaraÅ„czowo.
  </>}
/>

\* IstniejÄ… przypadki, gdy jednak moÅ¼emy chcieÄ‡ trzymaÄ‡ elementy takÅ¼e w innych wÄ™zÅ‚ach niÅ¼ liÅ›cie. PrzykÅ‚adowo, jeÅ›li element jest na tyle duÅ¼y, Å¼e trafiÅ‚by do wszystkich Ä‡wiartek, nie ma sensu go powielaÄ‡ miÄ™dzy nimi â€” tym samym optymalizujemy zÅ‚oÅ¼onoÅ›Ä‡ pamiÄ™ciowÄ… struktury. Jednak w artykule pominÄ™ ten przypadek, aby uproÅ›ciÄ‡ opis.

#### Znajdowanie elementÃ³w na obszarze

KolejnÄ… interesujÄ…cÄ… nas operacjÄ… jest sprawdzenie, czy jakieÅ› elementy znajdujÄ… siÄ™ na wskazanym obszarze, i jeÅ›li tak, to ktÃ³re.

Tutaj sprawa wydaje siÄ™ nieco prostsza niÅ¼ w przypadku dodawania. Wystarczy po kolei sprawdzaÄ‡ kolejne wÄ™zÅ‚y, czy zawierajÄ… wskazany obszar. JeÅ›li tak, to naleÅ¼y sprawdziÄ‡, ktÃ³re elementy zapisane na wÄ™Åºle znajdujÄ… siÄ™ w tym obszarze.

W praktyce wyglÄ…da to mniej wiÄ™cej tak:

1. Sprawdzamy, czy aktualny wÄ™zeÅ‚ zawiera lub przecina zadany obszar. JeÅ›li nie, koÅ„czymy wykonanie algorytmu.
2. Sprawdzamy, czy aktualny wÄ™zeÅ‚ jest podzielony na mniejsze.
    1. JeÅ›li tak, to wykonujemy rekurencyjnie operacjÄ™ wyszukiwania na wszystkich dzieciach.
    2. JeÅ›li nie, to iterujemy po wszystkich elementach zapisanych w aktualnym wÄ™Åºle, i dodajemy do wyniku te znajdujÄ…ce siÄ™ w zadanym obszarze.
3. Zwracamy wynik.

Warto pamiÄ™taÄ‡, Å¼e element moÅ¼e byÄ‡ zawarty w kilku wÄ™zÅ‚ach, dlatego trzeba odfiltrowaÄ‡ duplikaty z listy wynikÃ³w (lub uprzednio zastosowaÄ‡ strukturÄ™ uniemoÅ¼liwiajÄ…cÄ… dodawanie duplikatÃ³w).

### Implementacja

Zaimplementujmy teraz drzewo czwÃ³rkowe. Zrobimy to w jÄ™zyku <Link href="/post/teoria-zbiorow-typescript">TypeScript</Link>, a nie jak zwykle na moim blogu w JavaScript, poniewaÅ¼ adnotacje typÃ³w bÄ™dÄ… tutaj przydatne.

#### Przygotowanie do implementacji

Zanim zaimplementujemy konkretne algorytmy, musimy najpierw stworzyÄ‡ â€bazÄ™â€ stanowiÄ…cÄ… nasze drzewo. PrzyjÄ™Å‚o siÄ™, Å¼e struktury drzewiaste opisuje siÄ™ przy pomocy programowania obiektowego, i tak teÅ¼ my tutaj zrobimy.

Najpopularniejszym sposobem reprezentacji drzewa jest reprezentacja <Link href="/post/rekurencja-co-to-jest">rekurencyjna</Link>. Oznacza to, Å¼e obiekt drzewa zawiera referencjÄ™ na kolejne poddrzewa, ktÃ³re sÄ… jego dzieÄ‡mi i sÄ… tego samego typu. MoÅ¼emy to rozumieÄ‡ w taki sposÃ³b, Å¼e pojedynczy obiekt drzewa to tak naprawdÄ™ jego pojedynczy wÄ™zeÅ‚. Jest to zapis o tyle wygodny, Å¼e operujemy caÅ‚y czas na jednej klasie, a wiÄ™kszoÅ›Ä‡ algorytmÃ³w moÅ¼emy zapisaÄ‡ w prosty, rekurencyjny sposÃ³b (jakkolwiek dziwnie nie brzmiÄ… obok siebie sÅ‚owa â€prostyâ€ i â€rekurencjaâ€).

Co oprÃ³cz dzieci i algorytmÃ³w powinien posiadaÄ‡ obiekt drzewa (albo raczej definicja obiektu, czyli klasa)? Na pewno listÄ™ elementÃ³w przechowywanych przez aktualny wÄ™zeÅ‚. Potrzebujemy takÅ¼e znaÄ‡ obszar, ktÃ³ry dany wÄ™zeÅ‚ pokrywa (najlepiej przekazaÄ‡ go przy tworzeniu obiektu, w konstruktorze). Ponadto, do algorytmÃ³w przyda nam siÄ™ takÅ¼e metoda (czyli funkcja zapisana w obiekcie) pomocnicza sprawdzajÄ…ca, czy dwa prostokÄ…ty siÄ™ przecinajÄ… (dla uproszczenia zawrzemy jÄ… w implementacji drzewa, ale programujÄ…c na porzÄ…dnie, raczej powinniÅ›my jÄ… wydzieliÄ‡ na zewnÄ…trz).

Najpierw jednak zdefiniujmy typ pomocniczy reprezentujÄ…cy prostokÄ…t, ktÃ³ry bÄ™dzie podstawowÄ… jednostkÄ… dla okreÅ›lania obszarÃ³w wÄ™zÅ‚Ã³w, jak i opisu elementÃ³w:

```typescript
// typ reprezentujÄ…cy prostokÄ…t
interface Rectangle {
  x: number;
  y: number;
  width: number;
  height: number;
  // dodatkowa informacja, aby mÃ³c zidentyfikowaÄ‡ elementy
  label?: string;
}
```

Sama klasa reprezentujÄ…ca drzewo/wÄ™zeÅ‚ bÄ™dzie na razie wyglÄ…daÄ‡ tak:

```typescript
// klasa reprezentujÄ…ca wÄ™zeÅ‚ drzewa czwÃ³rkowego
class QuadTree {
  // staÅ‚a opisujÄ…ca pojemnoÅ›Ä‡ kaÅ¼dego z wÄ™zÅ‚Ã³w
  private static readonly CAPACITY = 4;
  // obiekty przechowywane w tym wÄ™Åºle
  private objects: Rectangle[] = [];
  // dzieci aktualnego wÄ™zÅ‚a
  private northwest?: QuadTree;
  private northeast?: QuadTree;
  private southwest?: QuadTree;
  private southeast?: QuadTree;

  // tworzÄ…c wÄ™zeÅ‚, musimy podaÄ‡ obszar, ktÃ³ry ma reprezentowaÄ‡
  constructor(private boundary: Rectangle) {}

  // wartoÅ›Ä‡ pomocnicza opisujÄ…ca, czy wÄ™zeÅ‚ jest podzielony
  private get divided(): boolean {
    return (
      this.northwest != null &&
      this.northeast != null &&
      this.southwest != null &&
      this.southeast != null
    );
  }

  // metoda pomocnicza do sprawdzania, czy dwa prostokÄ…ty siÄ™ przecinajÄ…
  private intersects(a: Rectangle, b: Rectangle): boolean {
    return (
      b.x <= a.x + a.width &&
      b.x + b.width >= a.x &&
      b.y <= a.y + a.height &&
      b.y + b.height >= a.y
    );
  }
}
```

#### Dodawanie elementÃ³w

Najbardziej skomplikowanÄ… operacjÄ… jest dodawanie elementÃ³w. Jak pamiÄ™tasz z opisu wyÅ¼ej, musimy napisaÄ‡ tutaj obsÅ‚ugÄ™:

- przechodzenia w dÃ³Å‚ drzewa w celu znalezienia odpowiedniego wÄ™zÅ‚a
- dodawania elementu do wÄ™zÅ‚a
- w razie potrzeby, podziaÅ‚u wÄ™zÅ‚a na mniejsze elementy

Zacznijmy od tego, Å¼e nasza klasa bÄ™dzie mieÄ‡ publicznÄ… metodÄ™ do wstawiania elementÃ³w. Na razie sama definicja:

```typescript
// metoda dodajÄ…ca obiekt do wÄ™zÅ‚a
public insert(obj: Rectangle): void {
  // tutaj bÄ™dzie kod
}
```

CzÄ™sto bÄ™dziemy wywoÅ‚ywaÄ‡ dodawanie rekurencyjnie u wszystkich dzieci. UproÅ›Ä‡my to sobie prostÄ… metodÄ… pomocniczÄ…, aby za kaÅ¼dym razem nie powielaÄ‡ tego samego:

```typescript
// metoda pomocnicza prÃ³bujÄ…ca wstawiÄ‡ obiekt do wszystkich dzieci
private insertToChildren(obj: Rectangle): void {
  this.northwest!.insert(obj);
  this.northeast!.insert(obj);
  this.southwest!.insert(obj);
  this.southeast!.insert(obj);
}
```

NastÄ™pnie obsÅ‚uÅ¼my przypadek podziaÅ‚u wÄ™zÅ‚a na mniejsze. Musimy w tym przypadku:

- utworzyÄ‡ nowe wÄ™zÅ‚y i przypisaÄ‡ im odpowiednie obszary
- przenieÅ›Ä‡ elementy zapisane na aktualnym wÄ™Åºle na odpowiednie dzieci

Zrobimy to nastÄ™pujÄ…co:

```typescript
// metoda podzielajÄ…ca wÄ™zeÅ‚ na 4 dzieci
private subdivide(): void {
  // wyznaczamy wspÃ³Å‚rzÄ™dne i wymiary dzieci
  const x = this.boundary.x;
  const y = this.boundary.y;
  const w = this.boundary.width / 2;
  const h = this.boundary.height / 2;

  // tworzymy dzieci
  this.northwest = new QuadTree({ x, y, width: w, height: h });
  this.northeast = new QuadTree({ x: x + w, y, width: w, height: h });
  this.southwest = new QuadTree({ x, y: y + h, width: w, height: h });
  this.southeast = new QuadTree({ x: x + w, y: y + h, width: w, height: h });

  // przenosimy zapisane elementy do dzieci
  for (const obj of this.objects) {
    this.insertToChildren(obj);
  }
  // na koniec czyÅ›cimy tablicÄ™ obiektÃ³w w tym wÄ™Åºle
  this.objects = [];
}
```

MajÄ…c gotowe wszystko dookoÅ‚a, poÅ‚Ä…czmy to wszystko, implementujÄ…c metodÄ™ publicznÄ…:

```typescript
// metoda dodajÄ…ca obiekt do wÄ™zÅ‚a
public insert(obj: Rectangle): void {
  // najpierw sprawdzamy, czy obiekt siÄ™ przecina z obszarem wÄ™zÅ‚a
  if (!this.intersects(this.boundary, obj)) {
    // jeÅ›li nie, to nie dodajemy go do wÄ™zÅ‚a
    return;
  }

  // nastÄ™pnie sprawdzamy, czy wÄ™zeÅ‚ jest podzielony
  if (this.divided) {
    // jeÅ›li tak, to prÃ³bujemy dodaÄ‡ obiekt do jego dzieci
    this.insertToChildren(obj);
  } else {
    // jeÅ›li nie, to zostajÄ… dwie moÅ¼liwoÅ›ci
    if (this.objects.length < QuadTree.CAPACITY) {
      // jeÅ›li wÄ™zeÅ‚ nie jest przepeÅ‚niony, to dodajemy obiekt do niego
      this.objects.push(obj);
    } else {
      // jeÅ›li jest przepeÅ‚niony, to dzielimy go i prÃ³bujemy dodaÄ‡ obiekt do jego dzieci
      this.subdivide();
      this.insertToChildren(obj);
    }
  }
}
```

#### Wyszukiwanie elementÃ³w

DuÅ¼o prostsze jest wyszukiwanie, ktÃ³re elementy znajdujÄ… siÄ™ na wskazanym obszarze. Tutaj jedyne co musimy zrobiÄ‡, to metodÄ™, ktÃ³ra rekurencyjnie przejdzie po wszystkich wÄ™zÅ‚ach i znajdzie pasujÄ…ce elementy.

ImplementacjÄ™ rozbijemy na prywatnÄ… metodÄ™ rekurencyjnÄ… oraz publicznÄ…, ktÃ³ra jÄ… w odpowiedni sposÃ³b wywoÅ‚a. Metoda prywatna bÄ™dzie siÄ™ rÃ³Å¼niÄ‡ tym, Å¼e w argumencie przyjmie referencjÄ™ na zbiÃ³r przechowujÄ…cy znalezione elementy. ZbiÃ³r jest strukturÄ… na tyle wygodnÄ…, Å¼e w przypadku gdy element powtÃ³rzyÅ‚ siÄ™ na kilku obszarach, to zachowa jedynie jednÄ… jego kopiÄ™.

W ramach metody wyszukujÄ…cej naleÅ¼y:

- ZobaczyÄ‡, czy jest sens sprawdzaÄ‡ aktualny wÄ™zeÅ‚ bÄ…dÅº teÅ¼ schodziÄ‡ gÅ‚Ä™biej w dÃ³Å‚.
- JeÅ›li wÄ™zeÅ‚ jest podzielony na mniejsze, wywoÅ‚aÄ‡ metodÄ™ rekurencyjnie u wszystkich dzieci.
- JeÅ›li wÄ™zeÅ‚ zawiera elementy, sprawdziÄ‡, ktÃ³re przecinajÄ… siÄ™ z zadanym obszarem.

W kodzie bÄ™dzie to wyglÄ…daÄ‡ nastÄ™pujÄ…co:

```typescript
// metoda pomocnicza do wyszukiwania obiektÃ³w w danym obszarze
private queryInternal(range: Rectangle, found: Set<Rectangle>): void {
  if (!this.intersects(this.boundary, range)) {
    // jeÅ›li obszar wyszukiwania nie przecina siÄ™ z obszarem wÄ™zÅ‚a, to koÅ„czymy
    return;
  }

  if (this.divided) {
    // jeÅ›li wÄ™zeÅ‚ jest podzielony, to szukamy w jego dzieciach
    this.northwest!.queryInternal(range, found);
    this.northeast!.queryInternal(range, found);
    this.southwest!.queryInternal(range, found);
    this.southeast!.queryInternal(range, found);
  } else {
    // jeÅ›li wÄ™zeÅ‚ nie jest podzielony, to sprawdzamy wszystkie przechowywane w nim obiekty
    for (const obj of this.objects) {
      if (this.intersects(range, obj)) {
        // jeÅ›li obiekt przecina siÄ™ z obszarem wyszukiwania, to dodajemy go do zbioru
        found.add(obj);
      }
    }
  }
}
```

Natomiast metoda publiczna wywoÅ‚a jÄ… wraz z przekazaniem referencji na pusty zbiÃ³r:

```typescript
// metoda wyszukujÄ…ca obiekty w danym obszarze
public query(range: Rectangle): Rectangle[] {
  const found = new Set<Rectangle>();
  // wykonujemy pomocniczÄ… metodÄ™ rekurencyjnÄ…, ktÃ³ra wypeÅ‚ni zbiÃ³r found
  this.queryInternal(range, found);
  // konwertujemy zbiÃ³r na tablicÄ™ i jÄ… zwracamy
  return [...found];
}
```

MajÄ…c wyszukiwanie i dodawanie elementÃ³w, moÅ¼emy bez problemu uÅ¼ywaÄ‡ drzewa czwÃ³rkowego w praktyce. CaÅ‚oÅ›Ä‡ kodu wraz z przykÅ‚adowym uÅ¼yciem znajdziesz na [Replit](https://replit.com/@tswistak/quadtree#index.ts).

### Zalety, wady, zastosowania

Na podstawie tego, co wyÅ¼ej zobaczyliÅ›my, moÅ¼emy przeanalizowaÄ‡ wydajnoÅ›Ä‡ drzewa czwÃ³rkowego, a takÅ¼e w jakich przypadkach najlepiej siÄ™ ono sprawdza.

Zacznijmy od wydajnoÅ›ci. ZaprogramowaliÅ›my dwie operacje, ktÃ³rych wydajnoÅ›Ä‡ wyglÄ…da nastÄ™pujÄ…co:

- **Dodawanie elementu** â€” w przypadku drzew Å›rednio operacja wstawiania ma zÅ‚oÅ¼onoÅ›Ä‡ czasowÄ… $$\Omicron(\log(n))$$ ($$n$$ to liczba elementÃ³w). Teoretycznie, w najgorszym przypadku, jeÅ›li drzewo jest Åºle zbalansowane (jest skierowane w jednÄ… stronÄ™), wydajnoÅ›Ä‡ moÅ¼e wynosiÄ‡ $$\Omicron(n)$$.
- **Wyszukiwanie** â€” tak samo, jak wyÅ¼ej. Åšrednio operacja ta ma zÅ‚oÅ¼onoÅ›Ä‡ $$\Omicron(\log(n))$$, bo zakÅ‚adamy, Å¼e przy rÃ³wnomiernym rozÅ‚oÅ¼eniu elementÃ³w taka bÄ™dzie wysokoÅ›Ä‡ drzewa. Aczkolwiek na zÅ‚oÅ¼onoÅ›Ä‡ wpÅ‚ywajÄ… tutaj takÅ¼e wielkoÅ›Ä‡ obszaru wyszukiwania (najwydajniejsze jest szukanie pojedynczego punktu), a takÅ¼e konstrukcja drzewa (tak jak przy dodawaniu).

Drzewo czwÃ³rkowe szczegÃ³lnie dobrze sprawdza siÄ™ w dwÃ³ch przypadkach:

- **Dane sÄ… rozÅ‚oÅ¼one z nierÃ³wnomiernÄ… gÄ™stoÅ›ciÄ…** â€” to znaczy, Å¼e w niektÃ³rych miejscach jest ich wiÄ™cej, a w innych mniej. W takim przypadku drzewo czwÃ³rkowe bÄ™dzie miaÅ‚o mniejsze zÅ‚oÅ¼onoÅ›ci czasowe, bo czÄ™Å›Ä‡ obszarÃ³w nie bÄ™dzie dzielona na mniejsze, wiÄ™c i przeszukiwanie ich bÄ™dzie szybsze.
- **ZbiÃ³r elementÃ³w siÄ™ nie zmienia** (lub tylko dodajemy nowe) â€” drzewo czwÃ³rkowe nie jest drzewem balansujÄ…cym siÄ™, co oznacza, Å¼e jeÅ›li usuwamy elementy, to nie rozmieszczamy elementÃ³w na nowo. MoÅ¼e to powodowaÄ‡ powstawanie niepotrzebnych rozgaÅ‚Ä™zieÅ„ i podziaÅ‚Ã³w. Oznacza to, Å¼e usuwajÄ…c elementy lub modyfikujÄ…c ich pozycjÄ™, moÅ¼emy pogorszyÄ‡ wydajnoÅ›Ä‡ struktury. Ponadto zmiana pozycji to tak naprawdÄ™ usuniÄ™cie i dodanie elementu, co moÅ¼e byÄ‡ kosztowne, bo bÄ™dziemy musieli najpierw znaleÅºÄ‡ wszystkie miejsca w drzewie, gdzie znajduje siÄ™ element, aby go usunÄ…Ä‡.

Sprawia to, Å¼e drzewa czwÃ³rkowe sÄ… szczegÃ³lnie przydatne w:

- **Zapisie otoczenia w grach komputerowych**, szczegÃ³lnie tych z otwartym, rozlegÅ‚ym Å›wiatem.
- **Systemach informacji geograficznej** (GIS), szczegÃ³lnie opisujÄ…cych rozlegÅ‚e obszary rzadko zaludnione.

Natomiast drzewa czwÃ³rkowe nie nadajÄ… siÄ™ do:

- **Wykrywania kolizji w grach pomiÄ™dzy ruchomymi obiektami** â€” przesuwajÄ…ce siÄ™ obiekty szybko sprawiÄ…, Å¼e drzewo stanie siÄ™ nieoptymalne.
- **Opis przestrzeni rÃ³wnomiernie zapeÅ‚nionej** â€” w takim przypadku tracimy najwiÄ™kszÄ… zaletÄ™ drzewa czwÃ³rkowego, czyli brak dzielenia pustych obszarÃ³w na mniejsze.

Warto rÃ³wnieÅ¼ pamiÄ™taÄ‡, Å¼e drzewa czwÃ³rkowe moÅ¼emy stosowaÄ‡ tylko w przestrzeni dwuwymiarowej. Do opisu przestrzeni trÃ³jwymiarowej moÅ¼emy wykorzystaÄ‡ **drzewo Ã³semkowe** (po ang. octree), ktÃ³re dziaÅ‚a na tej samej zasadzie co drzewo czwÃ³rkowe, ale zamiast dzieliÄ‡ obszar na Ä‡wiartki, dzieli go na Ã³semki.

<Image
  image={octree}
  alignCenter
  fullSize
  alt="Schemat drzewa Ã³semkowego: trÃ³jwymiarowy szeÅ›cian dzielony na 8 czÄ™Å›ci, z dalszymi podziaÅ‚ami. Obok drzewo pokazujÄ…ce hierarchiÄ™ wÄ™zÅ‚Ã³w, gdzie kaÅ¼dy wÄ™zeÅ‚ moÅ¼e mieÄ‡ 8 potomkÃ³w."
  caption={<>
    Diagram pokazujÄ…cy podziaÅ‚ przestrzeni w drzewie Ã³semkowym.<br/>(ÅºrÃ³dÅ‚o: <a href="https://commons.wikimedia.org/wiki/File:Octree2.png">NÃ¼</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/">CC BY-SA 3.0</a>, via Wikimedia Commons)
  </>}
/>

## Haszowanie przestrzenne

Przyznam, Å¼e na poczÄ…tku artykuÅ‚u duÅ¼o rozpisaÅ‚em siÄ™ o zastosowaniu przeszukiwania do gier. Jednak drzewo czwÃ³rkowe nie radzi sobie optymalnie z najpowszechniejszym przypadkiem, czyli wykrywaniem kolizji miÄ™dzy ruchomymi obiektami. Dlatego przedstawiÄ™ Ci drugÄ… strukturÄ™, ktÃ³ra siÄ™ lepiej sprawdzi w tym przypadku â€” haszowanie przestrzenne (po ang. spatial hashing).

### Idea

Gdy w drzewie czwÃ³rkowym dzieliliÅ›my obszar stopniowo na coraz mniejsze, tak w haszowaniu przestrzennym tego nie robimy. Zamiast tego operujemy na odgÃ³rnie ustalonym podziale na siatkÄ™, wewnÄ…trz ktÃ³rej przechowujemy elementy. Nie dzielimy na mniejsze obszary, gdy przekroczymy pewnÄ… liczbÄ™ elementÃ³w â€” podziaÅ‚ jest staÅ‚y. DziÄ™ki temu nie musimy siÄ™ martwiÄ‡, Å¼e przy czÄ™stym usuwaniu elementÃ³w struktura stanie siÄ™ nieoptymalna.

Tylko skÄ…d nazwa â€haszowanie przestrzenneâ€? OtÃ³Å¼ kaÅ¼da komÃ³rka w siatce ma przypisany unikalny klucz, po ktÃ³rym moÅ¼na jÄ… znaleÅºÄ‡ i wyciÄ…gnÄ…Ä‡ zapisane w niej elementy. Kieruje nas to w kierunku wykorzystania struktury tablicy haszowanej (po ang. hash table) pozwalajÄ…cej na szybkie dodawanie i wyszukiwanie elementÃ³w po kluczu (zÅ‚oÅ¼onoÅ›Ä‡ czasowa $$\Omicron(1)$$). Na szczÄ™Å›cie struktury tej nie musimy implementowaÄ‡ â€” praktycznie kaÅ¼dy jÄ™zyk programowania posiada jej implementacjÄ™ w swojej bibliotece standardowej pod nazwÄ… â€mapaâ€ (np. [`Map`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) w JavaScript) lub â€sÅ‚ownikâ€ (np. [`Dictionary`](https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.dictionary-2?view=net-9.0) w C#). Jedyne, co nam zostaje do zaprogramowania, to sama logika haszowania przestrzennego.

Dodam, Å¼e teoretycznie zamiast tablicy haszowanej moÅ¼emy uÅ¼yÄ‡ tablicy o staÅ‚ej wielkoÅ›ci. MoÅ¼e siÄ™ jednak okazaÄ‡, Å¼e w przypadku duÅ¼ych obszarÃ³w tablica zajmie duÅ¼o pamiÄ™ci. Dlatego w praktyce lepiej uÅ¼ywaÄ‡ tablic haszowanych, poniewaÅ¼ nie musimy wtedy odgÃ³rnie utworzyÄ‡ caÅ‚ej siatki, a jedynie dodajemy te komÃ³rki, ktÃ³re posiadajÄ… elementy â€” gotowe implementacje potrafiÄ… wydajnie zarzÄ…dzaÄ‡ pamiÄ™ciÄ….

### Operacje w haszowaniu przestrzennym

Podobnie jak przy drzewie czwÃ³rkowym, tak i tutaj musimy zaimplementowaÄ‡ dwie operacje: dodawanie elementÃ³w oraz wyszukiwanie ich w danym obszarze. Na razie opowiedzmy sobie, jak one bÄ™dÄ… dziaÅ‚aÄ‡.

#### Obliczenie klucza docelowej komÃ³rki

OperujÄ…c na siatce o staÅ‚ych wymiarach, musimy wiedzieÄ‡, w jaki sposÃ³b dostaÄ‡ siÄ™ do konkretnej komÃ³rki. Skoro te sÄ… opisane kluczami, to musimy wiedzieÄ‡, jak dany klucz wyznaczyÄ‡.

Pierwsze, co jednak musimy wiedzieÄ‡, to jaki jest rozmiar siatki. DomyÅ›lnie zakÅ‚ada siÄ™, Å¼e wszystkie komÃ³rki siatki sÄ… kwadratami o tym samym rozmiarze. Aby operowaÄ‡ na symbolach, przyjmijmy, Å¼e rozmiar komÃ³rki wynosi $$s$$.

NastÄ™pnie musimy wziÄ…Ä‡ pod uwagÄ™ dwa scenariusze â€” znalezienie komÃ³rki dla konkretnego punktu i dla wskazanego prostokÄ…tnego obszaru.

##### Znalezienie komÃ³rki dla punktu

W przypadku pojedynczego punktu jest to bardzo proste. Skoro mamy do czynienia z siatkÄ… o staÅ‚ym rozmiarze, to jedyne, co musimy zrobiÄ‡, to podzieliÄ‡ wspÃ³Å‚rzÄ™dne punktu $$(x_P, y_P)$$ przez rozmiar i zaokrÄ…gliÄ‡ w dÃ³Å‚:

$$
\begin{align*}
x &= \lfloor \frac{x_P}{s} \rfloor \\
y &= \lfloor \frac{y_P}{s} \rfloor
\end{align*}
$$

W przypadku gdy korzystamy z gotowych tablic haszowanych, tyle wystarczy. Zwykle indeksujemy je dowolnymi typami, wiÄ™c moÅ¼emy uÅ¼yÄ‡ pary wartoÅ›ci $$x$$ i $$y$$ jako klucza.

JeÅ›li natomiast chcielibyÅ›my wartoÅ›Ä‡ liczbowÄ…, moÅ¼emy uÅ¼yÄ‡ prostego wzoru, ktÃ³ry wykorzystuje siÄ™ do jednowymiarowego indeksowania dwuwymiarowych tablic. PokazywaÅ‚em to juÅ¼ kiedyÅ› w artykule o <Link href="/post/sudoku">sudoku</Link> i chÄ™tnych do niego odsyÅ‚am. OczywiÅ›cie pokazanego tam wzoru nie uÅ¼yjemy wprost, poniewaÅ¼ musimy obliczyÄ‡, ile komÃ³rek znajduje siÄ™ w jednym wierszu, ale pozostawiam tÄ™ prostÄ… matematykÄ™ dla zainteresowanych.

##### Znalezienie komÃ³rki dla prostokÄ…tnego obszaru

Z racji tego, Å¼e nie operujemy na punktach, tylko na prostokÄ…tach, to zdarzÄ… siÄ™ sytuacje, Å¼e zarÃ³wno przy dodawaniu, jak i wyszukiwaniu bÄ™dzie nas interesowaÄ‡ wiÄ™cej niÅ¼ jedna komÃ³rka. Jak do tego podejÅ›Ä‡?

Najpierw musimy byÄ‡ w stanie obliczyÄ‡ pierwszÄ… i ostatniÄ… komÃ³rkÄ™, w ktÃ³rej zawiera siÄ™ dany obszar. Dla dowolnej jednej wspÃ³Å‚rzÄ™dnej (aby nie mieszaÄ‡, przyjmijmy zmiennÄ… $$c$$ â€” opisuje ona punkt w lewym gÃ³rnym rogu prostokÄ…ta) i wielkoÅ›ci obszaru (przyjmijmy zmiennÄ… $$s_c$$ â€” pamiÄ™tajmy, Å¼e skoro mÃ³wimy o prostokÄ…tach, to dla kaÅ¼dej wspÃ³Å‚rzÄ™dnej jest inny rozmiar) moÅ¼emy to zrobiÄ‡ w ten sposÃ³b:

$$
\begin{align*}
min_c &= \lfloor \frac{c}{s} \rfloor \\
max_c &= \lfloor \frac{c + s_c}{s} \rfloor
\end{align*}
$$

WyliczajÄ…c wartoÅ›ci `min` i `max` dla wszystkich wspÃ³Å‚rzÄ™dnych, musimy nastÄ™pnie przeiterowaÄ‡ po wszystkich moÅ¼liwych kombinacjach wartoÅ›ci od `min` do `max` i spisaÄ‡ klucze odpowiadajÄ…cych im komÃ³rek.

#### Dodawanie elementÃ³w

Skoro wiemy juÅ¼, jak znaleÅºÄ‡ komÃ³rki, w ktÃ³rych bÄ™dziemy przechowywaÄ‡ elementy, to moÅ¼emy przejÅ›Ä‡ do ich dodawania.

Tak naprawdÄ™ wiÄ™kszoÅ›Ä‡ logiki opisaliÅ›my juÅ¼ powyÅ¼ej. Aby dodaÄ‡ element, musimy:

1. ObliczyÄ‡ klucze komÃ³rek, w ktÃ³rych element siÄ™ znajduje.
2. SprawdziÄ‡, czy komÃ³rki sÄ… juÅ¼ utworzone.
3. JeÅ›li nie, to je utworzyÄ‡.
4. DodaÄ‡ element do odpowiednich komÃ³rek.

#### Wyszukiwanie elementÃ³w

A co z wyszukiwaniem elementÃ³w? DosÅ‚ownie tak samo jak przy dodawaniu. Musimy:

1. ObliczyÄ‡ klucze komÃ³rek odpowiadajÄ…ce zadanemu obszarowi wyszukiwania.
2. WyciÄ…gnÄ…Ä‡ elementy z istniejÄ…cych komÃ³rek.

NaleÅ¼y tylko pamiÄ™taÄ‡ o tym, Å¼e jeden element moÅ¼e byÄ‡ zapisany w wielu komÃ³rkach. StÄ…d, tak samo jak przy drzewie czwÃ³rkowym, naleÅ¼y pamiÄ™taÄ‡ o odsianiu duplikatÃ³w.

### Implementacja

Skoro juÅ¼ wiemy wszystko w teorii, czas przejÅ›Ä‡ do praktyki. Podobnie jak przy drzewie czwÃ³rkowym, tutaj rÃ³wnieÅ¼ napiszemy wszystko w TypeScript, korzystajÄ…c z programowania obiektowego.

#### Przygotowanie do implementacji

Tak jak ostatnio, stwÃ³rzmy klasÄ™, w ktÃ³rej zaimplementujemy naszÄ… strukturÄ™. Jednak tym razem struktura nie bÄ™dzie rekurencyjna. Pojedyncza instancja klasy przechowa caÅ‚Ä… siatkÄ™, a nie pojedynczy wÄ™zeÅ‚.

StwÃ³rzmy wiÄ™c klasÄ™ `SpatialHash`. Przy jej inicjalizacji podamy rozmiar pojedynczej komÃ³rki (w teorii powinien odpowiadaÄ‡ Å›redniemu rozmiarowi elementÃ³w, ktÃ³re bÄ™dziemy przechowywaÄ‡). Od razu utworzymy teÅ¼ mapÄ™, czyli tablicÄ™ haszowanÄ… przechowujÄ…cÄ… komÃ³rki. OprÃ³cz tego skorzystamy nieco z napisanego juÅ¼ wczeÅ›niej kodu â€” typu `Rectangle` (pominÄ™ pisanie go tutaj) i metody sprawdzajÄ…cej, czy dwa prostokÄ…ty siÄ™ przecinajÄ….

```typescript
// klasa reprezentujÄ…ca siatkÄ™ przestrzennÄ…
class SpatialHash {
  // mapa przechowujÄ…ca komÃ³rki siatki i obiekty w nich zawarte
  private hashTable: Map<string, Rectangle[]> = new Map();

  // tworzÄ…c siatkÄ™, decydujemy o rozmiarze komÃ³rek
  constructor(private cellSize: number) {}

  // metoda pomocnicza do sprawdzania, czy dwa prostokÄ…ty siÄ™ przecinajÄ…
  private intersects(a: Rectangle, b: Rectangle): boolean {
    return (
      b.x <= a.x + a.width &&
      b.x + b.width >= a.x &&
      b.y <= a.y + a.height &&
      b.y + b.height >= a.y
    );
  }
}
```

#### Obliczanie klucza docelowej komÃ³rki

Jak widzieliÅ›my wczeÅ›niej, najbardziej rozbudowanymi operacjami w haszowaniu przestrzennym jest okreÅ›lanie, ktÃ³re komÃ³rki siatki interesujÄ… nas w danym momencie. Zajmijmy siÄ™ wiÄ™c implementacjÄ….

Najpierw okreÅ›lenie klucza komÃ³rki. Skoro typ `Map` w JavaScript/TypeScript moÅ¼e mieÄ‡ klucze bÄ™dÄ…ce ciÄ…gami znakÃ³w, nie bÄ™dziemy kombinowaÄ‡ i generowanie kluczy zrobimy w najprostszy moÅ¼liwy sposÃ³b:

```typescript
// metoda zwracajÄ…ca klucz komÃ³rki na podstawie jej wspÃ³Å‚rzÄ™dnych
private getCellKey(gridX: number, gridY: number): string {
  // klucz bÄ™dzie prostym stringiem zawierajÄ…cym wspÃ³Å‚rzÄ™dne komÃ³rki
  return `${gridX},${gridY}`;
}
```

Z racji tego, Å¼e przechowujemy prostokÄ…ty, pominiemy obliczanie klucza dla pojedynczego punktu. Zamiast tego zajmiemy siÄ™ obliczaniem kluczy dla prostokÄ…tÃ³w. Najpierw zacznijmy od znalezienia zakresu komÃ³rek na jednej osi:

```typescript
// metoda zwracajÄ…ca zakres komÃ³rek zajmowanych przez obiekt na jednej osi
private getCellRange(startPos: number, size: number): [number, number] {
  // wyznaczamy poczÄ…tek i koniec zakresu komÃ³rek
  const start = Math.floor(startPos / this.cellSize);
  const end = Math.floor((startPos + size) / this.cellSize);
  // zwracamy zakres jako parÄ™ liczb
  return [start, end];
}
```

NastÄ™pnie, wykorzystujÄ…c tÄ™ metodÄ™, moÅ¼emy obliczyÄ‡ klucze dla wskazanego prostokÄ…ta:

```typescript
// metoda zwracajÄ…ca komÃ³rki zajmowane przez obiekt
private getObjectCells(obj: Rectangle): string[] {
  // wyznaczamy zakres komÃ³rek zajmowanych przez obiekt na osi X
  const [minX, maxX] = this.getCellRange(obj.x, obj.width || 0);
  // oraz na osi Y
  const [minY, maxY] = this.getCellRange(obj.y, obj.height || 0);
  // tworzymy tablicÄ™ zawierajÄ…cÄ… klucze wszystkich komÃ³rek
  const cells: string[] = [];
  // iterujemy po wszystkich komÃ³rkach w zakresie
  for (let x = minX; x <= maxX; x++) {
    for (let y = minY; y <= maxY; y++) {
      // dodajemy klucz komÃ³rki do tablicy
      cells.push(this.getCellKey(x, y));
    }
  }
  // zwracamy tablicÄ™ kluczy
  return cells;
}
```

Warto zauwaÅ¼yÄ‡, Å¼e wszystkie metody sÄ… prywatne. Nie ma sensu ich udostÄ™pniaÄ‡ na zewnÄ…trz, poniewaÅ¼ nie bÄ™dÄ… wykorzystywane poza klasÄ… `SpatialHash`.

#### Dodawanie elementÃ³w

PrzejdÅºmy teraz do pierwszej operacji, ktÃ³rÄ… â€wystawimyâ€ publicznie, czyli dodawania elementÃ³w. Jak moÅ¼esz spodziewaÄ‡ siÄ™ po wczeÅ›niejszym lakonicznym opisie, kodu teÅ¼ tu zbyt wiele nie bÄ™dzie:

```typescript
// metoda dodajÄ…ca obiekt do siatki
public insert(obj: Rectangle): void {
  // wyznaczamy komÃ³rki zajmowane przez obiekt
  const cells = this.getObjectCells(obj);
  // iterujemy po wszystkich komÃ³rkach
  for (const key of cells) {
    // jeÅ›li komÃ³rka nie istnieje, tworzymy jÄ…
    if (!this.hashTable.has(key)) {
      this.hashTable.set(key, []);
    }
    // dodajemy obiekt do komÃ³rki
    this.hashTable.get(key)!.push(obj);
  }
}
```

#### Wyszukiwanie elementÃ³w

Podobnie bÄ™dzie z wyszukiwaniem elementÃ³w â€” majÄ…c juÅ¼ `getObjectCells`, teraz wystarczy tylko przeiterowaÄ‡ po wszystkich komÃ³rkach i wyciÄ…gnÄ…Ä‡ z nich elementy:

```typescript
// metoda zwracajÄ…ca obiekty przecinajÄ…ce siÄ™ z zadanym prostokÄ…tem
public query(range: Rectangle): Rectangle[] {
  // tworzymy zbiÃ³r wynikÃ³w
  const result = new Set<Rectangle>();
  // wyznaczamy komÃ³rki zajmowane przez zadany prostokÄ…t
  const cells = this.getObjectCells(range);
  // iterujemy po wszystkich komÃ³rkach
  for (const key of cells) {
    // pobieramy obiekty z komÃ³rki
    const objects = this.hashTable.get(key);
    if (objects) {
      // jeÅ›li komÃ³rka istnieje, iterujemy po wszystkich obiektach w niej zawartych
      for (const obj of objects) {
        // sprawdzamy, czy obiekt przecina siÄ™ z zadanym prostokÄ…tem
        if (this.intersects(obj, range)) {
          // jeÅ›li tak, dodajemy go do zbioru wynikÃ³w
          result.add(obj);
        }
      }
    }
  }
  // zwracamy tablicÄ™ wynikÃ³w
  return [...result];
}
```

Podobnie jak w drzewie czwÃ³rkowym, uÅ¼yliÅ›my tutaj zbioru, aby uniknÄ…Ä‡ duplikatÃ³w. CaÅ‚oÅ›Ä‡ implementacji znajdziesz na [Replit](https://replit.com/@tswistak/spatial-hashing#index.ts), gdzie takÅ¼e zamieÅ›ciÅ‚em przykÅ‚adowe uÅ¼ycie.

### Zalety, wady, zastosowania

Jak zobaczyliÅ›my, haszowanie przestrzenne jest o wiele prostsze w implementacji niÅ¼ drzewo czwÃ³rkowe. Tylko jak siÄ™ to przekÅ‚ada na wydajnoÅ›Ä‡?

W ramach interesujÄ…cych nas dwÃ³ch operacji wyglÄ…da to nastÄ™pujÄ…co:

- **Wstawianie** â€” w optymistycznym przypadku zÅ‚oÅ¼onoÅ›Ä‡ tej operacji wynosi $$\Omicron(1)$$, poniewaÅ¼ dodajemy element do tablicy haszowanej. Jednak element moÅ¼e zawieraÄ‡ siÄ™ w wielu komÃ³rkach, przez co zÅ‚oÅ¼onoÅ›Ä‡ operacji jest liniowa, zaleÅ¼na od liczby komÃ³rek, w ktÃ³rych siÄ™ znajduje: $$\Omicron(m)$$, gdzie $$m$$ to liczba komÃ³rek zajmowanych przez element ($$1 \leqslant m \leqslant n$$, gdzie $$n$$ to liczba wszystkich komÃ³rek). Dodam tylko, Å¼e nie rozpatrujemy tutaj zÅ‚oÅ¼onoÅ›ci operacji dodawania do listy tablicowej przechowujÄ…cej elementy w komÃ³rce (wiÄ™cej w artykule *<Link href="/post/tablice-i-listy-tablicowe">Tablice i listy tablicowe</Link>*).
- **Wyszukiwanie** â€” wyszukiwanie niczym siÄ™ tutaj nie rÃ³Å¼ni od dodawania. Optymistycznie (np. rozpatrujÄ…c pojedynczy punkt) zÅ‚oÅ¼onoÅ›Ä‡ wynosi $$\Omicron(1)$$, a w najgorszym przypadku $$\Omicron(m)$$.

Haszowanie przestrzenne szczegÃ³lnie dobrze sprawdza siÄ™ w przypadku:

- **Ruchomych obiektÃ³w** â€” poniewaÅ¼ nie musimy siÄ™ martwiÄ‡ o podziaÅ‚ przestrzeni, haszowanie przestrzenne jest idealne do wykrywania kolizji miÄ™dzy ruchomymi obiektami. UsuwajÄ…c i dodajÄ…c elementy, nie musimy siÄ™ martwiÄ‡ o to, Å¼e struktura stanie siÄ™ nieoptymalna. Tym samym idealnie sprawdza siÄ™ to przy **wykrywaniu kolizji w grach komputerowych**.
- **RÃ³wnomiernie zapeÅ‚nionej przestrzeni** â€” poniewaÅ¼ nie dzielimy przestrzeni na mniejsze komÃ³rki, haszowanie przestrzenne sprawdzi siÄ™ w przypadku, gdy elementy sÄ… rÃ³wnomiernie rozÅ‚oÅ¼one.
- **ZapytaÅ„ punktowych** â€” poniewaÅ¼ haszowanie przestrzenne dziaÅ‚a na siatce, idealnie nadaje siÄ™ do zapytaÅ„ punktowych. Od razu otrzymujemy komÃ³rkÄ™, w ktÃ³rej znajduje siÄ™ punkt; nie musimy jej wyszukiwaÄ‡ wgÅ‚Ä…b struktury.

Natomiast haszowanie przestrzenne nie najlepiej sprawdza siÄ™ w przypadkach, gdy:

- **Obiekty majÄ… zrÃ³Å¼nicowane rozmiary** â€” wÃ³wczas moÅ¼e siÄ™ zdarzyÄ‡, Å¼e obiekt bÄ™dzie zapisany na wielu komÃ³rkach, tym samym zajmujÄ…c wiÄ™cej pamiÄ™ci. Teoretycznie moglibyÅ›my zwiÄ™kszyÄ‡ rozmiar komÃ³rki, jednak wÃ³wczas stracimy na wydajnoÅ›ci, poniewaÅ¼ niektÃ³re komÃ³rki bÄ™dÄ… mogÅ‚y przechowywaÄ‡ zbyt duÅ¼o elementÃ³w (a te sÄ… przeszukiwane wewnÄ…trz komÃ³rki liniowo).
- **Mamy nierÃ³wnomierny rozkÅ‚ad obiektÃ³w** â€” w takim przypadku moÅ¼e siÄ™ zdarzyÄ‡, Å¼e niektÃ³re komÃ³rki bÄ™dÄ… przepeÅ‚nione, a inne puste. WÃ³wczas haszowanie przestrzenne straci na wydajnoÅ›ci, poniewaÅ¼ bÄ™dziemy musieli przeszukiwaÄ‡ liniowo po przepeÅ‚nionych komÃ³rkach.

Tym samym moÅ¼esz zauwaÅ¼yÄ‡, Å¼e obie struktury idealnie siÄ™ uzupeÅ‚niajÄ…. Drzewo czwÃ³rkowe sprawdzi siÄ™ w przypadku, gdy mamy nierÃ³wnomierny rozkÅ‚ad obiektÃ³w, a haszowanie przestrzenne w przypadku rÃ³wnomiernego. StÄ…d teÅ¼ w praktyce tworzy siÄ™ hybrydy tych struktur. Na przykÅ‚ad, moÅ¼emy obszar dzieliÄ‡ drzewem czwÃ³rkowym, a juÅ¼ wewnÄ…trz wÄ™zÅ‚a stosowaÄ‡ haszowanie przestrzenne. Ewentualnie czÄ™Å›Ä‡ informacji trzymaÄ‡ w drzewie czwÃ³rkowym (nieruchome obiekty), a czÄ™Å›Ä‡ w haszowaniu przestrzennym (ruchome obiekty). Warto pokombinowaÄ‡, co najlepiej sprawdzi siÄ™ w Twoim przypadku.

## Inne struktury

Dwie pokazane przeze mnie struktury nie sÄ… oczywiÅ›cie jedynymi dostÄ™pnymi. SÄ… za to najprostszymi, a tym samym czÄ™sto stosowanymi. Inne struktury, ktÃ³re mogÄ… siÄ™ przydaÄ‡ w przypadku przeszukiwania przestrzennego, to:

- **Drzewo R** (po ang. R-tree) â€” struktura, ktÃ³ra dzieli przestrzeÅ„ na prostokÄ…tne obszary mogÄ…ce mieÄ‡ rÃ³Å¼ne rozmiary. Warto tutaj wymieniÄ‡ odmianÄ™ R*-Tree â€” jest to struktura balansujÄ…ca siÄ™, wiÄ™c dobrze sprawdzi siÄ™ w przypadku usuwania elementÃ³w.
- **Drzewo BSP** (skrÃ³t od Binary Space Partitioning; binarne dzielenie przestrzeni) â€” struktura, ktÃ³ra dzieli rekurencyjnie przestrzeÅ„ na <Link href="/post/otoczka-wypukla">zbiory wypukÅ‚e</Link>. Dobrze siÄ™ sprawdzi w przypadku renderowania grafiki 3D, poniewaÅ¼ pozwala na szybkie okreÅ›lenie, ktÃ³re obiekty sÄ… widoczne z danej perspektywy. Z tego teÅ¼ powodu wykorzystuje siÄ™ jÄ… szeroko w silnikach gier 3D.
- **Drzewo kd** (drzewo k-wymiarowe, po ang. k-d tree) â€” struktura, ktÃ³ra pozwala zorganizowaÄ‡ punkty w przestrzeni k-wymiarowej. SwojÄ… ideÄ… przypomina w pewnym stopniu drzewo czwÃ³rkowe, jednak w swojej implementacji jest bardziej ogÃ³lna (dowolna liczba wymiarÃ³w) i w inny sposÃ³b dzieli przestrzeÅ„.

Struktury te sÄ… jednak bardziej zaawansowane i jest moÅ¼liwe, Å¼e opisane tutaj drzewa czwÃ³rkowe i haszowanie przestrzenne zupeÅ‚nie wystarczÄ… Ci do wiÄ™kszoÅ›ci zastosowaÅ„. Warto teÅ¼ pamiÄ™taÄ‡, Å¼e nie wszystko musimy implementowaÄ‡ samodzielnie. Wiele silnikÃ³w gier posiada juÅ¼ wbudowane struktury do przeszukiwania przestrzennego. JeÅ›li nie interesujÄ… nas gry, to bazy danych rÃ³wnieÅ¼ mogÄ… mieÄ‡ obsÅ‚ugÄ™ przeszukiwania przestrzennego (np. PostgreSQL przez rozszerzenie [PostGIS](https://postgis.net/)).

## Podsumowanie

Jak zobaczyliÅ›my wyÅ¼ej, wykorzystujÄ…c dwie stosunkowo proste struktury, jesteÅ›my w stanie zaprogramowaÄ‡ wydajne przeszukiwanie przestrzenne. Obie sprawdzajÄ… siÄ™ w innych zastosowaniach, moÅ¼na teÅ¼ je Å‚Ä…czyÄ‡ ze sobÄ…. LiczÄ™, Å¼e wiedza ta przyda Ci siÄ™ w przyszÅ‚oÅ›ci, aby zoptymalizowaÄ‡ swÃ³j kod albo po prostu lepiej zrozumieÄ‡, jak to dziaÅ‚a w gotowcach.

MaÅ‚a ciekawostka â€” w literaturze poniÅ¼ej jeden z autorÃ³w jest takÅ¼e twÃ³rcÄ… jednego z najpopularniejszych programÃ³w do tworzenia gier. JeÅ›li wiesz, o kogo chodzi i o ktÃ³ry program, moÅ¼esz zostawiÄ‡ odpowiedÅº w komentarzu ğŸ˜‰

## Literatura

- Hanan Samet. 1984. The Quadtree and Related Hierarchical Data Structures. ACM Comput. Surv. 16, 2 (June 1984), 187â€“260. [doi:10.1145/356924.356930](https://doi.org/10.1145/356924.356930)
- de Berg, M., van Kreveld, M., Overmars, M., & Schwarzkopf, O. (2000). **Quadtrees: Non-Uniform Mesh Generation**. In *Computational Geometry: Algorithms and Applications* (2nd rev. ed., pp. 291â€“306). Springer-Verlag Berlin Heidelberg.
- Quadtree, https://en.wikipedia.org/w/index.php?title=Quadtree&oldid=1280122514 (ostatnie odwiedziny 10.05.2025).
- Quadtrees - RonanDoherty.com, https://www.ronandoherty.com/blog/quadtrees (ostatnie odwiedziny 10.05.2025).
- Spatial Hashing - RonanDoherty.com, https://www.ronandoherty.com/blog/spatial-hashing (ostatnie odwiedziny 10.05.2025).
- Spatial hashing implementation for fast 2D collisions | The mind of Conkerjo, https://conkerjo.wordpress.com/2009/06/13/spatial-hashing-implementation-for-fast-2d-collisions/ (ostatnie odwiedziny 10.05.2025).

<small>ZdjÄ™cie na okÅ‚adce wygenerowane przez Midjourney.</small>
